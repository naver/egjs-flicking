{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///flicking.min.js","webpack:///webpack/bootstrap 554af3a090da75e42503?13c7","webpack:///./src/browser.js?c6b7","webpack:///./src/consts.js?5723","webpack:///./src/Flicking.js?ad30","webpack:///./src/config.js?4264","webpack:///./src/eventHandler.js?e040","webpack:///./src/index.js?9552","webpack:///./src/utils.js?2ff8","webpack:///external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}?e192","webpack:///external {\"commonjs\":\"@egjs/movablecoord\",\"commonjs2\":\"@egjs/movablecoord\",\"amd\":\"@egjs/movablecoord\",\"root\":[\"eg\",\"MovableCoord\"]}?931d"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_7__","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","win","window","Math","self","Function","document","DATA_HEIGHT","IS_ANDROID2","SUPPORT_WILLCHANGE","SUPPORT_TRANSFORM","EVENTS","undefined","_browser","beforeFlickStart","beforeRestore","flick","flickEnd","restore","style","documentElement","CSS","supports","test","navigator","userAgent","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_component","_component2","_movablecoord","_movablecoord2","_utils","_consts","consts","newObj","key","_config","_eventHandler","_eventHandler2","Flicking","_Mixin$with","element","options","_prefix","_this","$wrapper","utils","$","$children","children","length","Error","_setOptions","_setConfig","hasClickBug","_setPointerEvents","_build","_bindEvents","_applyPanelsCss","_arrangePanels","hwAccelerable","_setHint","adaptiveHeight","_setAdaptiveHeight","_adjustContainerCss","arrVal","previewPadding","bounce","extend","OPTIONS","val","isArray","padding","$nodes","classList","contains","prefix","$container","slice","conf","_conf","CONFIG","panel","$list","minCount","origPanelStyle","wrapper","className","getAttribute","container","list","map","v","useLayerHack","eventPrefix","horizontal","forEach","dirData","push","concat","panelCount","count","origCount","_setPadding","sizeValue","_getDataByDirection","size","cssValue","position","zIndex","width","height","top","css","$parent","parentNode","createElement","appendChild","add","getUnitValue","boxSizing","left","_addClonePanels","_mcInst","min","max","margin","circular","easing","panelEffect","deceleration","_setDefaultPanel","defaultIndex","build","paddingSum","reverse","join","overflow","keys","wrapperStyle","getComputedStyle","paddingType","getNumValue","_this2","cloneCount","cloneNodes","cloneNode","_movePanelPosition","append","listToMove","splice","index","lastIndex","coords","baseIndex","_getBasePositionIndex","_setPanelNo","no","currNo","currIndex","_setTranslate","_setMovableCoord","abs","sort","indexToMove","touch","customEvent","direction","_arrangePanelPosition","_applyPanelsPos","bind","_setMoveStyle","$el","coordsValue","$element","transform","translate","$dummyAnchor","phase","coordValue","paddingTop","parseInt","_getCoordsValue","x","y","focus","method","isDirVal","duration","coord","willChange","data","next","floor","mcInst","scale","interruptable","inputType","thresholdAngle","on","hold","_holdHandler","change","_changeHandler","release","_releaseHandler","animationStart","_animationStartHandler","animationEnd","_animationEndHandler","unbind","off","$panel","DIRECTION_LEFT","DIRECTION_RIGHT","$first","querySelector","outerHeight","setAttribute","_triggerBeforeRestore","e","replace","_triggerEvent","depaPos","destPos","stop","animating","_triggerRestore","restoreCall","_setPhaseValue","pos","changed","_isMovable","distance","_getNumByDirection","_revertPanelNo","num","isObject","pointer","holding","hammerEvent","preventSystemEvent","pointerEvents","isMovable","threshold","currPos","param","trigger","eventType","_getElement","physical","result","total","currentIndex","_setValueToMove","getIndex","getElement","getNextElement","getNextIndex","getAllElements","getPrevElement","getPrevIndex","getTotalCount","isPlaying","_movePanel","_movePanelByPhase","durationValue","prev","moveTo","noValue","isPositive","_checkPadding","split","Number","resize","_utils$css","panelSize","maxCoords","querySelectorAll","removeAttribute","enableInput","disableInput","destroy","removeChild","Mixin","with","holdPos","lastPos","pow","superclass","_superclass","_class","apply","arguments","posIndex","eventRes","movedPx","indexOf","round","_Flicking","_Flicking2","VERSION","_typeof","Symbol","iterator","el","match","attr","trim","nodeName","nodeType","arr","Array","target","_len","objectN","_key","source","shift","getAsNumber","applyStyle","defVal","isNaN","rx","String","getOuter","type","toLocaleLowerCase","outerWidth","isHWAccelerable","ua","version","useragent","isHA","MixinBuilder","_len2","mixins","_key2","reduce"],"mappings":"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","file":"flicking.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@egjs/component\"), require(\"@egjs/movablecoord\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@egjs/component\", \"@egjs/movablecoord\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Flicking\"] = factory(require(\"@egjs/component\"), require(\"@egjs/movablecoord\"));\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"Flicking\"] = factory(root[\"eg\"][\"Component\"], root[\"eg\"][\"MovableCoord\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@egjs/component\"), require(\"@egjs/movablecoord\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@egjs/component\", \"@egjs/movablecoord\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Flicking\"] = factory(require(\"@egjs/component\"), require(\"@egjs/movablecoord\"));\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"Flicking\"] = factory(root[\"eg\"][\"Component\"], root[\"eg\"][\"MovableCoord\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win = typeof window !== \"undefined\" && window.Math === Math ? window : typeof self !== \"undefined\" && self.Math === Math ? self : Function(\"return this\")();\n/* eslint-enable no-new-func, no-nested-ternary */\n\nvar document = win.document;\n\nexports.window = win;\nexports.document = document;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.DATA_HEIGHT = exports.IS_ANDROID2 = exports.SUPPORT_WILLCHANGE = exports.SUPPORT_TRANSFORM = exports.EVENTS = undefined;\n\nvar _browser = __webpack_require__(0);\n\n// define custom events name\nvar EVENTS = {\n\tbeforeFlickStart: \"beforeFlickStart\",\n\tbeforeRestore: \"beforeRestore\",\n\tflick: \"flick\",\n\tflickEnd: \"flickEnd\",\n\trestore: \"restore\"\n};\n\n// check for css transform support\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nvar SUPPORT_TRANSFORM = function () {\n\tvar style = _browser.document.documentElement.style;\n\n\treturn \"transform\" in style || \"webkitTransform\" in style;\n}();\n\n// check for will-change support\nvar SUPPORT_WILLCHANGE = _browser.window.CSS && _browser.window.CSS.supports && _browser.window.CSS.supports(\"will-change\", \"transform\");\n\n// check for Android 2.x\nvar IS_ANDROID2 = /Android 2\\./.test(navigator.userAgent);\n\n// data-height attribute's name for adaptiveHeight option\nvar DATA_HEIGHT = \"data-height\";\n\nexports.EVENTS = EVENTS;\nexports.SUPPORT_TRANSFORM = SUPPORT_TRANSFORM;\nexports.SUPPORT_WILLCHANGE = SUPPORT_WILLCHANGE;\nexports.IS_ANDROID2 = IS_ANDROID2;\nexports.DATA_HEIGHT = DATA_HEIGHT;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _component = __webpack_require__(7);\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _movablecoord = __webpack_require__(8);\n\nvar _movablecoord2 = _interopRequireDefault(_movablecoord);\n\nvar _utils = __webpack_require__(6);\n\nvar _consts = __webpack_require__(1);\n\nvar consts = _interopRequireWildcard(_consts);\n\nvar _config = __webpack_require__(3);\n\nvar _browser = __webpack_require__(0);\n\nvar _eventHandler = __webpack_require__(4);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2015 NAVER Corp.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * egjs projects are licensed under the MIT license\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\n/**\n * A module used to implement flicking interactions. With this module, you can make flicking gestures, which are ways to navigate left and right to move between panels arranged side by side.\n * @ko 플리킹 UI를 구현하는 모듈. 나란히 배치한 패널을 쓸어 넘겨 다음 패널이나 이전 패널로 이동하는 플리킹 UI를 만들 수 있다.\n * @alias eg.Flicking\n * @extends eg.Component\n *\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.3+ (except 3.x)\"}\n */\nvar Flicking = function (_Mixin$with) {\n\t_inherits(Flicking, _Mixin$with);\n\n\t/**\n  * Constructor\n  * @param {HTMLElement|String|jQuery} element A base element for the eg.Flicking module <ko>eg.Flicking 모듈을 사용할 기준 엘리먼트</ko>\n * @param {Object} options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n * @param {Boolean} [options.hwAccelerable=eg.isHWAccelerable()] Force hardware compositing <ko>하드웨어 가속 사용 여부</ko>\n * @param {String} [options.prefix=eg-flick] A prefix for class names of the panel elements <ko>패널 엘리먼트의 클래스 이름에 설정할 접두사</ko>\n * @param {Number} [options.deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>\n * @param {Boolean} [options.horizontal=true] Direction of the panel movement (true: horizontal, false: vertical) <ko>패널 이동 방향 (true 가로방향, false 세로방향)</ko>\n * @param {Boolean} [options.circular=false] Indicates whether a circular panel is available <ko>패널 순환 여부</ko>\n * @param {Number|Array} [options.previewPadding=[0,0]] The preview size for the previous or next panel. If direction is set to \"horizontal\", the preview section will be displayed on the left and right of the panel. If direction is set to \"vertical\", it will be displayed on the top and bottom of the panel <ko>이전 패널과 다음 패널을 미리 보는 영역의 크기. 패널 이동 방향이 가로 방향이면 패널 왼쪽과 오른쪽에 미리 보는 영역이 나타난다. 패널 이동 방향이 세로 방향이면 패널 위쪽과 아래쪽에 미리 보는 영역이 나타난다</ko>\n * @param {Number|Array} [options.bounce=[10,10]] −\tThe size of bouncing area. If a panel is set to \"non-circulable\", the start and end panels can exceed the base element area and move further as much as the bouncing area. If a panel is dragged to the bouncing area and then dropped, the panel where bouncing effects are applied is retuned back into the base element area. <ko>바운스 영역의 크기. 패널이 순환하지 않도록 설정됐다면 시작 패널과 마지막 패널은 기준 엘리먼트 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 패널을 바운스 영역까지 끌었다가 놓으면, 바운스 효과가 적용된 패널이 다시 기준 엘리먼트 영역 안으로 들어온다</ko>\n * @param {Number} [options.threshold=40] Distance threshold. If the drag exceeds the threshold value, it will be changed to the next panel <ko>다음 패널로 바뀌는 기준 이동 거리. 패널을 기준 이동 거리 이상 끌었다 놓으면 패널이 다음 패널로 바뀐다</ko>\n * @param {Number} [options.duration=100] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n * @param {Function} [options.panelEffect=easeOutCubic] The easing function to apply to a panel moving animation <ko>패널 이동 애니메이션에 적용할 easing 함수</ko>\n * @param {Number} [options.defaultIndex=0] The index number of a panel to be selected upon module initialization <ko>모듈이 초기화될 때 선택할 패널의 인덱스 번호</ko>\n * @param {Array} [options.inputType] Types of input devices.<br>- touch: A touch screen can be used to move a panel.<br>- mouse: A mouse can be used to move a panel. <ko>입력 장치 종류.<br>- touch: 터치 입력 장치로 패널을 이동할 수 있다.<br>- mouse: 마우스로 패널을 이동할 수 있다.</ko>\n * @param {Number} [options.thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>\n * @param {Boolean} [options.adaptiveHeight=false] Set container's height be adaptive according panel's height.<br>(Note: on Android 4.1.x stock browser, has rendering bug which not correctly render height value on panel with single node. To avoid just append another empty node at the end.)<ko>컨테이너 영역이 패널의 높이값에 따라 변경될지 여부<br>(참고: Android 4.1.x 스톡 브라우저에서 단일 노드로 구성된 패널의 높이값 변경이 제대로 렌더링 되지 않는 버그가 있음. 비어있는 노드를 추가하면 해결이 가능하다.)</ko>\n *\n * @see Easing Functions Cheat Sheet {@link http://easings.net/}\n * @see If you want to try a different easing function, use the jQuery easing plugin ({@link http://gsgd.co.uk/sandbox/jquery/easing}) or the jQuery UI easing library ({@link https://jqueryui.com/easing}). <ko>다른 easing 함수를 사용하려면 jQuery easing 플러그인({@link http://gsgd.co.uk/sandbox/jquery/easing})이나, jQuery UI easing 라이브러리({@link https://jqueryui.com/easing})를 사용한다</ko>\n */\n\tfunction Flicking(element, options, _prefix) {\n\t\t_classCallCheck(this, Flicking);\n\n\t\tvar _this = _possibleConstructorReturn(this, _Mixin$with.call(this));\n\n\t\t_this.$wrapper = _utils.utils.$(element);\n\t\tvar $children = _this.$wrapper && _this.$wrapper.children;\n\n\t\tif (!_this.$wrapper || !$children || !$children.length) {\n\t\t\t// eslint-disable validateLineBreaks, maximumLineLength\n\t\t\tthrow new Error(\"Given base element doesn't exist or it hasn't proper DOM structure to be initialized.\");\n\n\t\t\t// eslint-enable validateLineBreaks, maximumLineLength\n\t\t}\n\n\t\t_this._setOptions(options);\n\t\t_this._setConfig($children, _prefix);\n\n\t\t!_utils.utils.hasClickBug() && (_this._setPointerEvents = function () {});\n\n\t\t_this._build();\n\t\t_this._bindEvents(true);\n\n\t\t_this._applyPanelsCss();\n\t\t_this._arrangePanels();\n\n\t\t_this.options.hwAccelerable && consts.SUPPORT_WILLCHANGE && _this._setHint();\n\t\t_this.options.adaptiveHeight && _this._setAdaptiveHeight();\n\n\t\t_this._adjustContainerCss(\"end\");\n\t\treturn _this;\n\t}\n\n\t/**\n  * Set options values\n  * @param {Object} options\n  */\n\n\n\tFlicking.prototype._setOptions = function _setOptions(options) {\n\t\t// default value of previewPadding and bounce\n\t\tvar arrVal = {\n\t\t\tpreviewPadding: [0, 0],\n\t\t\tbounce: [10, 10]\n\t\t};\n\n\t\tthis.options = _utils.utils.extend(_utils.utils.extend({}, _config.OPTIONS), arrVal, options);\n\n\t\tfor (var key in arrVal) {\n\t\t\tvar val = this.options[key];\n\n\t\t\tif (typeof val === \"number\") {\n\t\t\t\tval = [val, val];\n\t\t\t} else if (!_utils.utils.isArray(val)) {\n\t\t\t\tval = arrVal[key];\n\t\t\t}\n\n\t\t\tthis.options[key] = val;\n\t\t}\n\t};\n\n\t/**\n  * Set config values\n  * @param {HTMLCollection} $children wrappers' children elements\n  * @param {String} _prefix event prefix\n  * @return {HTMLElement}\n  */\n\n\n\tFlicking.prototype._setConfig = function _setConfig($children, _prefix) {\n\t\tvar options = this.options;\n\t\tvar padding = options.previewPadding;\n\t\tvar $nodes = $children;\n\n\t\tif ($nodes[0].classList.contains(options.prefix + \"-container\")) {\n\t\t\t$nodes = $nodes[0];\n\t\t\tthis.$container = $nodes;\n\t\t\t$nodes = $nodes.children;\n\t\t}\n\n\t\t// convert to array\n\t\t$nodes = [].slice.call($nodes);\n\n\t\t// config value\n\t\tvar conf = this._conf = _utils.utils.extend(_utils.utils.extend({}, _config.CONFIG), {\n\t\t\tpanel: {\n\t\t\t\t$list: $nodes,\n\t\t\t\tminCount: padding[0] + padding[1] > 0 ? 5 : 3 // minimum panel count\n\t\t\t},\n\t\t\t// remember original class and inline style in case of restoration on destroy()\n\t\t\torigPanelStyle: {\n\t\t\t\twrapper: {\n\t\t\t\t\tclassName: this.$wrapper.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: this.$wrapper.getAttribute(\"style\") || null\n\t\t\t\t},\n\t\t\t\tcontainer: {\n\t\t\t\t\tclassName: this.$container && this.$container.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: this.$container && this.$container.getAttribute(\"style\") || null\n\t\t\t\t},\n\t\t\t\tlist: $nodes.map(function (v) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tclassName: v.getAttribute(\"class\") || null,\n\t\t\t\t\t\tstyle: v.getAttribute(\"style\") || null\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t},\n\t\t\tuseLayerHack: options.hwAccelerable && !consts.SUPPORT_WILLCHANGE,\n\t\t\teventPrefix: _prefix || \"\"\n\t\t});\n\n\t\t[[\"LEFT\", \"RIGHT\"], [\"UP\", \"DOWN\"]][+!options.horizontal].forEach(function (v) {\n\t\t\treturn conf.dirData.push(_movablecoord2.default[\"DIRECTION_\" + v]);\n\t\t});\n\t};\n\n\t/**\n  * Build and set panel nodes to make flicking structure\n  */\n\n\n\tFlicking.prototype._build = function _build() {\n\t\tvar panel = this._conf.panel;\n\t\tvar options = this.options;\n\t\tvar $children = panel.$list;\n\t\tvar padding = options.previewPadding.concat();\n\t\tvar prefix = options.prefix;\n\t\tvar horizontal = options.horizontal;\n\t\tvar panelCount = panel.count = panel.origCount = $children.length;\n\t\tvar bounce = options.bounce;\n\n\t\tthis._setPadding(padding, true);\n\t\tvar sizeValue = this._getDataByDirection([panel.size, \"100%\"]);\n\n\t\t// container element style\n\t\tvar cssValue = {\n\t\t\tposition: \"relative\",\n\t\t\tzIndex: 2000,\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\"\n\t\t};\n\n\t\thorizontal && (cssValue.top = \"0px\");\n\n\t\tif (this.$container) {\n\t\t\t_utils.utils.css(this.$container, cssValue);\n\t\t} else {\n\t\t\tvar $parent = $children[0].parentNode;\n\t\t\tvar $container = _browser.document.createElement(\"div\");\n\n\t\t\t$container.className = prefix + \"-container\";\n\t\t\t_utils.utils.css($container, cssValue);\n\n\t\t\t$children.forEach(function (v) {\n\t\t\t\treturn $container.appendChild(v);\n\t\t\t});\n\n\t\t\t$parent.appendChild($container);\n\t\t\tthis.$container = $container;\n\t\t}\n\n\t\t// panels' css values\n\t\t$children.forEach(function (v) {\n\t\t\tv.classList.add(prefix + \"-panel\");\n\n\t\t\t_utils.utils.css(v, {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\twidth: _utils.utils.getUnitValue(sizeValue[0]),\n\t\t\t\theight: _utils.utils.getUnitValue(sizeValue[1]),\n\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t});\n\t\t});\n\n\t\tif (this._addClonePanels()) {\n\t\t\tpanelCount = panel.count = (panel.$list = [].slice.call(this.$container.children)).length;\n\t\t}\n\n\t\t// create MovableCoord instance\n\t\tthis._mcInst = new _movablecoord2.default({\n\t\t\tmin: [0, 0],\n\t\t\tmax: this._getDataByDirection([panel.size * (panelCount - 1), 0]),\n\t\t\tmargin: 0,\n\t\t\tcircular: false,\n\t\t\teasing: options.panelEffect,\n\t\t\tdeceleration: options.deceleration,\n\t\t\tbounce: this._getDataByDirection([0, bounce[1], 0, bounce[0]])\n\t\t});\n\n\t\tthis._setDefaultPanel(options.defaultIndex);\n\t};\n\n\t/**\n  * Set preview padding value\n  * @param {Array} padding\n  * @param {Boolean} build\n  */\n\n\n\tFlicking.prototype._setPadding = function _setPadding(padding, build) {\n\t\tvar horizontal = this.options.horizontal;\n\t\tvar panel = this._conf.panel;\n\t\tvar paddingSum = padding[0] + padding[1];\n\t\tvar cssValue = {};\n\n\t\tif (paddingSum || !build) {\n\t\t\tcssValue.padding = horizontal ? \"0 \" + padding.reverse().join(\"px 0 \") + \"px\" : padding.join(\"px 0 \") + \"px\";\n\t\t}\n\n\t\tif (build) {\n\t\t\tcssValue.overflow = \"hidden\";\n\t\t\tcssValue.boxSizing = \"border-box\";\n\t\t}\n\n\t\tObject.keys(cssValue).length && _utils.utils.css(this.$wrapper, cssValue);\n\n\t\tvar wrapperStyle = getComputedStyle(this.$wrapper);\n\t\tvar paddingType = horizontal ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"];\n\n\t\tpanel.size = _utils.utils.getNumValue(wrapperStyle[horizontal ? \"width\" : \"height\"]) - (_utils.utils.getNumValue(wrapperStyle[\"padding\" + paddingType[0]]) + _utils.utils.getNumValue(wrapperStyle[\"padding\" + paddingType[1]]));\n\t};\n\n\t/**\n  * To fulfill minimum panel count cloning original node when circular or previewPadding option are set\n  * @return {Boolean} true : added clone node, false : not added\n  */\n\n\n\tFlicking.prototype._addClonePanels = function _addClonePanels() {\n\t\tvar _this2 = this;\n\n\t\tvar panel = this._conf.panel;\n\t\tvar panelCount = panel.origCount;\n\t\tvar cloneCount = panel.minCount - panelCount;\n\t\tvar list = panel.$list;\n\t\tvar cloneNodes = void 0;\n\n\t\t// if panels are given less than required when circular option is set, then clone node to apply circular mode\n\t\tif (this.options.circular && panelCount < panel.minCount) {\n\t\t\tcloneNodes = list.map(function (v) {\n\t\t\t\treturn v.cloneNode(true);\n\t\t\t});\n\n\t\t\twhile (cloneNodes.length < cloneCount) {\n\t\t\t\tcloneNodes = cloneNodes.concat(list.map(function (v) {\n\t\t\t\t\treturn v.cloneNode(true);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tcloneNodes.forEach(function (v) {\n\t\t\t\treturn _this2.$container.appendChild(v);\n\t\t\t});\n\n\t\t\treturn !!cloneNodes.length;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n  * Move panel's position within array\n  * @param {Number} count element counts to move\n  * @param {Boolean} append where the list to be appended(moved) (true: to the end, false: to the beginning)\n  */\n\n\n\tFlicking.prototype._movePanelPosition = function _movePanelPosition(count, append) {\n\t\tvar panel = this._conf.panel;\n\t\tvar list = panel.$list;\n\t\tvar listToMove = list.splice(append ? 0 : panel.count - count, count);\n\n\t\tpanel.$list = append ? list.concat(listToMove) : listToMove.concat(list);\n\t};\n\n\t/**\n  * Set default panel to show\n  * @param {Number} index\n  */\n\n\n\tFlicking.prototype._setDefaultPanel = function _setDefaultPanel(index) {\n\t\tvar panel = this._conf.panel;\n\t\tvar lastIndex = panel.count - 1;\n\t\tvar coords = void 0;\n\t\tvar baseIndex = void 0;\n\n\t\tif (this.options.circular) {\n\t\t\t// if default index is given, then move correspond panel to the first position\n\t\t\tif (index > 0 && index <= lastIndex) {\n\t\t\t\tthis._movePanelPosition(index, true);\n\t\t\t}\n\n\t\t\t// set first panel's position according physical node length\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\t\t\tthis._movePanelPosition(baseIndex, false);\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tno: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\t\t\t// if defaultIndex option is given, then move to that index panel\n\t\t} else if (index > 0 && index <= lastIndex) {\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex: index,\n\t\t\t\tno: index,\n\t\t\t\tcurrIndex: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\n\t\t\tcoords = [-(panel.size * index), 0];\n\n\t\t\tthis._setTranslate(coords);\n\t\t\tthis._setMovableCoord(\"setTo\", [Math.abs(coords[0]), Math.abs(coords[1])], true, 0);\n\t\t}\n\t};\n\n\t/**\n  * Arrange panels' position\n  * @param {Boolean} sort Need to sort panel's position\n  * @param {Number} indexToMove Number to move from current position (negative: left, positive: right)\n  */\n\n\n\tFlicking.prototype._arrangePanels = function _arrangePanels(sort, indexToMove) {\n\t\tvar conf = this._conf;\n\t\tvar panel = conf.panel;\n\t\tvar touch = conf.touch;\n\t\tvar dirData = conf.dirData;\n\t\tvar baseIndex = void 0;\n\n\t\tif (this.options.circular) {\n\t\t\t// when arranging panels, set flag to not trigger flick custom event\n\t\t\tconf.customEvent.flick = false;\n\n\t\t\t// move elements according direction\n\t\t\tif (sort) {\n\t\t\t\tindexToMove && (touch.direction = dirData[+!(indexToMove > 0)]);\n\t\t\t\tthis._arrangePanelPosition(touch.direction, indexToMove);\n\t\t\t}\n\n\t\t\t// set index for base element's position\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex: baseIndex,\n\t\t\t\tcurrIndex: baseIndex\n\t\t\t});\n\n\t\t\t// arrange MovableCoord's coord position\n\t\t\tconf.customEvent.flick = !!this._setMovableCoord(\"setTo\", [panel.size * panel.index, 0], true, 0);\n\t\t}\n\n\t\tthis._applyPanelsPos();\n\t};\n\n\t/**\n  * Set each panel's position in DOM\n  */\n\n\n\tFlicking.prototype._applyPanelsPos = function _applyPanelsPos() {\n\t\tthis._conf.panel.$list.forEach(this._applyPanelsCss.bind(this));\n\t};\n\n\t/**\n  * Set CSS style values to move elements\n  *\n  * Initialize setting up checking if browser support transform css property.\n  * If browser doesn't support transform, then use left/top properties instead.\n  * @param {HTMLElement} $element\n  * @param {Array} coords\n  */\n\n\n\tFlicking.prototype._setMoveStyle = function _setMoveStyle($el, coordsValue) {\n\t\tthis._setMoveStyle = consts.SUPPORT_TRANSFORM ? function moveStyle($element, coords) {\n\t\t\t_utils.utils.css($element, {\n\t\t\t\ttransform: _utils.utils.translate(coords[0], coords[1], this._conf.useLayerHack)\n\t\t\t});\n\t\t} : function ($element, coords) {\n\t\t\t_utils.utils.css($element, { left: coords[0], top: coords[1] });\n\t\t};\n\n\t\tthis._setMoveStyle($el, coordsValue);\n\t};\n\n\t/**\n  * Callback function for applying CSS values to each panels\n  *\n  * Need to be initialized before use, to set up for Android 2.x browsers or others.\n  */\n\n\n\tFlicking.prototype._applyPanelsCss = function _applyPanelsCss() {\n\t\tvar conf = this._conf;\n\t\tvar dummyAnchorClassName = \"__dummy_anchor\";\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tconf.$dummyAnchor = _utils.utils.$(\".\" + dummyAnchorClassName);\n\n\t\t\t!conf.$dummyAnchor && this.$wrapper.appendChild(conf.$dummyAnchor = _utils.utils.$(\"<a href=\\\"javascript:void(0)\\\" class=\\\"\" + dummyAnchorClassName + \"\\\" style=\\\"position:absolute;height:0px;width:0px\\\">\"));\n\n\t\t\tthis._applyPanelsCss = function applyCss(v, i) {\n\t\t\t\tvar coords = this._getDataByDirection([this._conf.panel.size * i + \"px\", 0]);\n\n\t\t\t\t_utils.utils.css(v, {\n\t\t\t\t\tleft: coords[0],\n\t\t\t\t\ttop: coords[1]\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis._applyPanelsCss = function applyCss(v, i) {\n\t\t\t\tvar coords = this._getDataByDirection([consts.SUPPORT_TRANSFORM ? 100 * i + \"%\" : this._conf.panel.size * i + \"px\", 0]);\n\n\t\t\t\tthis._setMoveStyle(v, coords);\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n  * Adjust container's css value to handle Android 2.x link highlighting bug\n  *\n  * @param {String} phase\n  *    start - set left/top value to 0\n  *    end - set translate value to 0\n  * @param {Array} coordValue coordinate value\n  */\n\n\n\tFlicking.prototype._adjustContainerCss = function _adjustContainerCss(phase, coordValue) {\n\t\tvar conf = this._conf;\n\t\tvar panel = conf.panel;\n\t\tvar options = this.options;\n\t\tvar horizontal = options.horizontal;\n\t\tvar paddingTop = options.previewPadding[0];\n\t\tvar container = this.$container;\n\t\tvar coords = coordValue;\n\t\tvar value = void 0;\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tif (!coords) {\n\t\t\t\tcoords = [-panel.size * panel.index, 0];\n\t\t\t}\n\n\t\t\tif (phase === \"start\") {\n\t\t\t\tcontainer = container.style;\n\t\t\t\tvalue = parseInt(container[horizontal ? \"left\" : \"top\"], 10);\n\n\t\t\t\tif (horizontal) {\n\t\t\t\t\tvalue && (container.left = \"0px\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue !== paddingTop && (container.top = \"0px\");\n\t\t\t\t}\n\n\t\t\t\tthis._setTranslate([-coords[+!options.horizontal], 0]);\n\t\t\t} else if (phase === \"end\") {\n\t\t\t\tcoords = this._getCoordsValue(coords);\n\n\t\t\t\t_utils.utils.css(container, {\n\t\t\t\t\tleft: coords.x,\n\t\t\t\t\ttop: coords.y,\n\t\t\t\t\ttransform: _utils.utils.translate(0, 0, conf.useLayerHack)\n\t\t\t\t});\n\n\t\t\t\tconf.$dummyAnchor.focus();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Set MovableCoord coord value\n  * @param {String} method\n  * @param {Array} coordValue\n  * @param {Boolean} isDirVal\n  * @param {Number} duration\n  * @return {eg.MovableCoord} MovableCoord instance\n  */\n\n\n\tFlicking.prototype._setMovableCoord = function _setMovableCoord(method, coordValue, isDirVal, duration) {\n\t\tvar coord = coordValue;\n\n\t\tif (isDirVal) {\n\t\t\tcoord = this._getDataByDirection(coord);\n\t\t}\n\n\t\treturn this._mcInst[method](coord[0], coord[1], duration);\n\t};\n\n\t/**\n  * Set hint for browser to decide efficient way of doing transform changes(or animation)\n  * https://dev.opera.com/articles/css-will-change-property/\n  */\n\n\n\tFlicking.prototype._setHint = function _setHint() {\n\t\tvar style = { willChange: \"transform\" };\n\n\t\t_utils.utils.css(this.$container, style);\n\t\t_utils.utils.css(this._conf.panel.$list, style);\n\t};\n\n\t/**\n  * Get data according options.horizontal value\n  *\n  * @param {Array} value primary data to handle\n  * @return {Array}\n  */\n\n\n\tFlicking.prototype._getDataByDirection = function _getDataByDirection(value) {\n\t\tvar data = value.concat();\n\n\t\t!this.options.horizontal && data.reverse();\n\t\treturn data;\n\t};\n\n\t/**\n  * Move nodes\n  * @param {Boolean} direction\n  * @param {Number} indexToMove\n  */\n\n\n\tFlicking.prototype._arrangePanelPosition = function _arrangePanelPosition(direction, indexToMove) {\n\t\tvar next = direction === this._conf.dirData[0];\n\n\t\tthis._movePanelPosition(Math.abs(indexToMove || 1), next);\n\t};\n\n\t/**\n  * Get the base position index of the panel\n  */\n\n\n\tFlicking.prototype._getBasePositionIndex = function _getBasePositionIndex() {\n\t\treturn Math.floor(this._conf.panel.count / 2 - 0.1);\n\t};\n\n\t/**\n  * Bind events\n  * @param {Boolean} bind\n  */\n\n\n\tFlicking.prototype._bindEvents = function _bindEvents(bind) {\n\t\tvar options = this.options;\n\t\tvar $wrapper = this.$wrapper;\n\t\tvar mcInst = this._mcInst;\n\n\t\tif (bind) {\n\t\t\tmcInst.bind($wrapper, {\n\t\t\t\tscale: this._getDataByDirection([-1, 0]),\n\t\t\t\tdirection: _movablecoord2.default[\"DIRECTION_\" + (options.horizontal ? \"HORIZONTAL\" : \"VERTICAL\")],\n\t\t\t\tinterruptable: false,\n\t\t\t\tinputType: options.inputType,\n\t\t\t\tthresholdAngle: options.thresholdAngle\n\t\t\t}).on({\n\t\t\t\thold: this._holdHandler.bind(this),\n\t\t\t\tchange: this._changeHandler.bind(this),\n\t\t\t\trelease: this._releaseHandler.bind(this),\n\t\t\t\tanimationStart: this._animationStartHandler.bind(this),\n\t\t\t\tanimationEnd: this._animationEndHandler.bind(this)\n\t\t\t});\n\t\t} else {\n\t\t\tmcInst.unbind($wrapper).off();\n\t\t}\n\t};\n\n\t/**\n  * Set container's height value according to children's height\n  * @param {Number} direction\n  */\n\n\n\tFlicking.prototype._setAdaptiveHeight = function _setAdaptiveHeight(direction) {\n\t\tvar conf = this._conf;\n\t\tvar indexToMove = conf.indexToMove;\n\t\tvar $children = void 0;\n\t\tvar height = void 0;\n\n\t\tvar $panel = indexToMove === 0 ?\n\n\t\t// panel moved by 1\n\t\tthis[\"get\" + (direction === _movablecoord2.default.DIRECTION_LEFT && \"Next\" || direction === _movablecoord2.default.DIRECTION_RIGHT && \"Prev\" || \"\") + \"Element\"]() :\n\n\t\t// panel moved by .moveTo()\n\t\tconf.panel.$list[conf.panel.currIndex + indexToMove];\n\n\t\tvar $first = $panel.querySelector(\":first-child\");\n\n\t\theight = $first.getAttribute(consts.DATA_HEIGHT);\n\n\t\tif (!height) {\n\t\t\t$children = $panel.children;\n\t\t\theight = _utils.utils.outerHeight($children.length > 1 ? ($panel.style.height = \"auto\", $panel) : $first);\n\n\t\t\t$first.setAttribute(consts.DATA_HEIGHT, height);\n\t\t}\n\n\t\tthis.$wrapper.style.height = height + \"px\";\n\t};\n\n\t/**\n  * Trigger beforeRestore event\n  * @param {Object} e event object\n  */\n\n\n\tFlicking.prototype._triggerBeforeRestore = function _triggerBeforeRestore(e) {\n\t\tvar conf = this._conf;\n\t\tvar touch = conf.touch;\n\n\t\t// reverse direction value when restore\n\t\ttouch.direction = ~~conf.dirData.join(\"\").replace(touch.direction, \"\");\n\n\t\t/**\n   * This event is fired before an element is restored to its original position when user action is done while the element is not dragged until a certain distance threshold is reached\n   * @ko 다음 패널로 바뀌는 기준 이동 거리만큼 이동하기 전에 사용자의 동작이 끝났을 때 원래 패널로 복원되기 전에 발생하는 이벤트\n   * @name eg.Flicking#beforeRestore\n   * @event\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {String} param.eventType The name of the event <ko>이름명</ko>\n   * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM. (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다. (@deprecated since 1.3.0)</ko>\n   * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content.<ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n   * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n   * @param {Array} param.depaPos Start coordinate <ko>출발점 좌표</ko>\n   * @param {Number} param.depaPos.0 x-coordinate <ko>x 좌표</ko>\n   * @param {Number} param.depaPos.1 y-coordinate <ko>y 좌표</ko>\n   * @param {Array} param.destPos End coordinate <ko>도착점 좌표</ko>\n   * @param {Number} param.destPos.0 x-coordinate <ko>x 좌표</ko>\n   * @param {Number} param.destPos.1 y-coordinate <ko>y 좌표</ko>\n   */\n\t\tconf.customEvent.restore = this._triggerEvent(consts.EVENTS.beforeRestore, {\n\t\t\tdepaPos: e.depaPos,\n\t\t\tdestPos: e.destPos\n\t\t});\n\n\t\tif (!conf.customEvent.restore) {\n\t\t\t\"stop\" in e && e.stop();\n\t\t\tconf.panel.animating = false;\n\t\t}\n\t};\n\n\t/**\n  * Trigger restore event\n  */\n\n\n\tFlicking.prototype._triggerRestore = function _triggerRestore() {\n\t\tvar customEvent = this._conf.customEvent;\n\n\t\t/**\n   * This event is fired after an element is restored to its original position when user action is done while the element is not dragged until a certain distance threshold is reached.\n   * @ko 다음 패널로 바뀌는 기준 이동 거리만큼 이동하기 전에 사용자의 동작이 끝났을 때 원래 패널로 복원된 다음 발생하는 이벤트\n   * @name eg.Flicking#restore\n   * @event\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {String} param.eventType The name of the event <ko>이름명</ko>\n   * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM(@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n   * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content. <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n   * @param {Number} param.direction Direction of the panel move (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n   */\n\t\tcustomEvent.restore && this._triggerEvent(consts.EVENTS.restore);\n\t\tcustomEvent.restoreCall = false;\n\t};\n\n\t/**\n  * Set value when panel changes\n  * @param {String} phase - [start|end]\n  * @param {Object} pos\n  */\n\n\n\tFlicking.prototype._setPhaseValue = function _setPhaseValue(phase, pos) {\n\t\tvar conf = this._conf;\n\t\tvar options = this.options;\n\t\tvar panel = conf.panel;\n\n\t\tif (phase === \"start\" && (panel.changed = this._isMovable())) {\n\t\t\t/**\n    * This event is fired before flicking starts\n    * @ko 플리킹이 시작하기 전에 발생하는 이벤트\n    * @name eg.Flicking#beforeFlickStart\n    * @event\n    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n    * @param {String} param.eventType The name of the event <ko>이름명</ko>\n    * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM. (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n    * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content.<ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n    * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>−\t이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n    * @param {Array} param.depaPos Start coordinate <ko>출발점 좌표</ko>\n    * @param {Number} param.depaPos.0 x-coordinate <ko>x 좌표</ko>\n    * @param {Number} param.depaPos.1 y-coordinate <ko>y 좌표</ko>\n    * @param {Array} param.destPos End coordinate <ko>도착점 좌표</ko>\n    * @param {Number} param.destPos.0 x-coordinate <ko>x 좌표</ko>\n    * @param {Number} param.destPos.1 y-coordinate <ko>y 좌표</ko>\n    */\n\t\t\tif (!this._triggerEvent(consts.EVENTS.beforeFlickStart, pos)) {\n\t\t\t\tpanel.changed = panel.animating = false;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\toptions.adaptiveHeight && this._setAdaptiveHeight(conf.touch.direction);\n\t\t\t}\n\n\t\t\tconf.indexToMove === 0 && this._setPanelNo();\n\t\t} else if (phase === \"end\") {\n\t\t\tif (options.circular && panel.changed) {\n\t\t\t\tthis._arrangePanels(true, conf.indexToMove);\n\t\t\t}\n\n\t\t\t!consts.IS_ANDROID2 && this._setTranslate([-panel.size * panel.index, 0]);\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\n\t\t\t/**\n    * This event is fired after panel moves.\n    * @ko 패널이 이동한 다음 발생하는 이벤트\n    * @name eg.Flicking#flickEnd\n    * @event\n    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n    * @param {String} param.eventType The name of the event <ko>이름명</ko>\n    * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n    * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content. <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n    * @param {Number} param.direction Direction of the movemen (see eg.MovableCoord.DIRECTION_* constant) <ko>−\t이동 방향(eg.MovableCoord.DIRECTION_* constant 참고</ko>\n    */\n\t\t\tpanel.changed && this._triggerEvent(consts.EVENTS.flickEnd);\n\t\t}\n\n\t\tthis._adjustContainerCss(phase);\n\t\treturn true;\n\t};\n\n\t/**\n  * Get positive or negative according direction\n  */\n\n\n\tFlicking.prototype._getNumByDirection = function _getNumByDirection() {\n\t\tvar conf = this._conf;\n\n\t\treturn conf.touch.direction === conf.dirData[0] ? 1 : -1;\n\t};\n\n\t/**\n  * Revert panel number\n  */\n\n\n\tFlicking.prototype._revertPanelNo = function _revertPanelNo() {\n\t\tvar panel = this._conf.panel;\n\t\tvar num = this._getNumByDirection();\n\n\t\tvar index = panel.currIndex >= 0 ? panel.currIndex : panel.index - num;\n\t\tvar no = panel.currNo >= 0 ? panel.currNo : panel.no - num;\n\n\t\tthis._setPanelNo({\n\t\t\tindex: index,\n\t\t\tno: no\n\t\t});\n\t};\n\n\t/**\n  * Set the panel number\n  * @param {Object} obj number object\n  */\n\n\n\tFlicking.prototype._setPanelNo = function _setPanelNo(obj) {\n\t\tvar panel = this._conf.panel;\n\t\tvar count = panel.origCount - 1;\n\t\tvar num = this._getNumByDirection();\n\n\t\tif (_utils.utils.isObject(obj)) {\n\t\t\tfor (var key in obj) {\n\t\t\t\tpanel[key] = obj[key];\n\t\t\t}\n\t\t} else {\n\t\t\t// remember current value\n\t\t\tpanel.currIndex = panel.index;\n\t\t\tpanel.currNo = panel.no;\n\n\t\t\tpanel.index += num;\n\t\t\tpanel.no += num;\n\t\t}\n\n\t\tif (panel.no > count) {\n\t\t\tpanel.no = 0;\n\t\t} else if (panel.no < 0) {\n\t\t\tpanel.no = count;\n\t\t}\n\t};\n\n\t/**\n  * Set pointerEvents css property on container element due to the iOS click bug\n  * @param {Event} e\n  */\n\n\n\tFlicking.prototype._setPointerEvents = function _setPointerEvents(e) {\n\t\tvar pointer = _utils.utils.css(this.$container, \"pointerEvents\");\n\t\tvar val = void 0;\n\n\t\tif (e && e.holding && e.hammerEvent && e.hammerEvent.preventSystemEvent && pointer !== \"none\") {\n\t\t\tval = \"none\";\n\t\t} else if (!e && pointer !== \"auto\") {\n\t\t\tval = \"auto\";\n\t\t}\n\n\t\tval && _utils.utils.css(this.$container, { pointerEvents: val });\n\t};\n\n\t/**\n  * Get coordinate value with unit\n  * @param coords {Array} x,y numeric value\n  * @return {Object} x,y coordinate value with unit\n  */\n\n\n\tFlicking.prototype._getCoordsValue = function _getCoordsValue(coordsValue) {\n\t\t// the param comes as [ val, 0 ], whatever the direction. So reorder the value depend the direction.\n\t\tvar coords = this._getDataByDirection(coordsValue);\n\n\t\treturn {\n\t\t\tx: _utils.utils.getUnitValue(coords[0]),\n\t\t\ty: _utils.utils.getUnitValue(coords[1])\n\t\t};\n\t};\n\n\t/**\n  * Set translate property value\n  * @param {Array} coords coordinate x,y value\n  */\n\n\n\tFlicking.prototype._setTranslate = function _setTranslate(coordsValue) {\n\t\tvar coords = this._getCoordsValue(coordsValue);\n\n\t\tthis._setMoveStyle(this.$container, [coords.x, coords.y]);\n\t};\n\n\t/**\n  * Check if panel passed through threshold pixel\n  */\n\n\n\tFlicking.prototype._isMovable = function _isMovable() {\n\t\tvar options = this.options;\n\t\tvar mcInst = this._mcInst;\n\t\tvar isMovable = Math.abs(this._conf.touch.distance) >= options.threshold;\n\t\tvar max = void 0;\n\t\tvar currPos = void 0;\n\n\t\tif (!options.circular && isMovable) {\n\t\t\tmax = this._getDataByDirection(mcInst.options.max)[0];\n\t\t\tcurrPos = this._getDataByDirection(mcInst.get())[0];\n\n\t\t\t// if current position out of range\n\t\t\tif (currPos < 0 || currPos > max) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn isMovable;\n\t};\n\n\t/**\n  * Trigger custom events\n  * @param {String} name - event name\n  * @param {Object} param - additional event value\n  * @return {Boolean}\n  */\n\n\n\tFlicking.prototype._triggerEvent = function _triggerEvent(name, param) {\n\t\tvar conf = this._conf;\n\t\tvar panel = conf.panel;\n\n\t\t// pass changed panel no only on 'flickEnd' event\n\t\tif (name === consts.EVENTS.flickEnd) {\n\t\t\tpanel.currNo = panel.no;\n\t\t\tpanel.currIndex = panel.index;\n\t\t}\n\n\t\treturn this.trigger(conf.eventPrefix + name, _utils.utils.extend({\n\t\t\teventType: name,\n\t\t\tindex: panel.currIndex,\n\t\t\tno: panel.currNo,\n\t\t\tdirection: conf.touch.direction\n\t\t}, param));\n\t};\n\n\t/**\n  * Get next/prev panel element/index.\n  * @param {Boolean} direction\n  * @param {Boolean} element - true:to get element, false:to get index\n  * @param {Number} physical - true : physical, false : logical\n  * @return {HTMLElement|Number}\n  */\n\n\n\tFlicking.prototype._getElement = function _getElement(direction, element, physical) {\n\t\tvar panel = this._conf.panel;\n\t\tvar circular = this.options.circular;\n\t\tvar pos = panel.currIndex;\n\t\tvar next = direction === this._conf.dirData[0];\n\t\tvar result = null;\n\t\tvar total = void 0;\n\t\tvar index = void 0;\n\n\t\tif (physical) {\n\t\t\ttotal = panel.count;\n\t\t\tindex = pos;\n\t\t} else {\n\t\t\ttotal = panel.origCount;\n\t\t\tindex = panel.currNo;\n\t\t}\n\n\t\tvar currentIndex = index;\n\n\t\tif (next) {\n\t\t\tif (index < total - 1) {\n\t\t\t\tindex++;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (index > 0) {\n\t\t\t\tindex--;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = total - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (currentIndex !== index) {\n\t\t\tresult = element ? panel.$list[next ? pos + 1 : pos - 1] : index;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n  * Set value to force move panels when duration is 0\n  * @param {Boolean} next\n  */\n\n\n\tFlicking.prototype._setValueToMove = function _setValueToMove(next) {\n\t\tvar conf = this._conf;\n\n\t\tconf.touch.distance = this.options.threshold + 1;\n\t\tconf.touch.direction = conf.dirData[+!next];\n\t};\n\n\t/**\n  * Returns the index number of the current panel element.\n  * @ko 현재 패널 엘리먼트의 인덱스 번호를 반환한다\n  * @method eg.Flicking#getIndex\n  * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n  * @return {Number} Index number of the current panel element <ko>현재 패널의 인덱스 번호</ko>\n  */\n\n\n\tFlicking.prototype.getIndex = function getIndex(physical) {\n\t\treturn this._conf.panel[physical ? \"currIndex\" : \"currNo\"];\n\t};\n\n\t/**\n  * Returns the reference of the current panel element.\n  * @ko 현재 패널 엘리먼트의 레퍼런스를 반환한다\n  * @method eg.Flicking#getElement\n  * @return {HTMLElement} Current element <ko>현재 엘리먼트</ko>\n  */\n\n\n\tFlicking.prototype.getElement = function getElement() {\n\t\tvar panel = this._conf.panel;\n\n\t\treturn panel.$list[panel.currIndex];\n\t};\n\n\t/**\n  * Returns the reference of the next panel element.\n  * @ko 다음 패널 엘리먼트의 레퍼런스를 반환한다.\n  * @method eg.Flicking#getNextElement\n  * @return {HTMLElement|null} Next panel element or null if it does not exist.<ko>다음 패널 엘리먼트. 패널이 없으면 'null'을 반환한다.</ko>\n  */\n\n\n\tFlicking.prototype.getNextElement = function getNextElement() {\n\t\treturn this._getElement(this._conf.dirData[0], true);\n\t};\n\n\t/**\n  * Returns the index number of the next panel element.\n  * @ko 다음 패널 엘리먼트의 인덱스 번호를 반환한다\n  * @method eg.Flicking#getNextIndex\n  * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n  * @return {Number|null} Index number of the next panel element or null if it does not exist. <ko>다음 패널 엘리먼트의 인덱스 번호. 패널이 없으면 'null'을 반환한다</ko>\n  */\n\n\n\tFlicking.prototype.getNextIndex = function getNextIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[0], false, physical);\n\t};\n\n\t/**\n  * Returns the references of whole panel elements.\n  * @ko 패널을 구성하는 모든 엘리먼트의 레퍼런스를 반환한다\n  * @method eg.Flicking#getAllElements\n  * @return {HTMLElement} Whole panel elements <ko>모든 패널 엘리먼트</ko>\n  */\n\n\n\tFlicking.prototype.getAllElements = function getAllElements() {\n\t\treturn this._conf.panel.$list;\n\t};\n\n\t/**\n  * Returns the reference of the previous panel element.\n  * @ko 이전 패널 엘리먼트의 레퍼런스를 반환한다.\n  * @method eg.Flicking#getPrevElement\n  * @return {HTMLElement|null} Previous panel element or null if it does not exist. <ko>이전 패널 엘리먼트. 패널이 없으면 'null'을 반환한다</ko>\n  */\n\n\n\tFlicking.prototype.getPrevElement = function getPrevElement() {\n\t\treturn this._getElement(this._conf.dirData[1], true);\n\t};\n\n\t/**\n  * Returns the index number of the previous panel element.\n  * @ko 이전 패널 엘리먼트의 인덱스 번호를 반환한다\n  * @method eg.Flicking#getPrevIndex\n  * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n  * @return {Number|null} Previous element index value or null if no more element exist<ko>이전 패널 인덱스 번호. 패널이 없는 경우에는 null</ko>\n  */\n\n\n\tFlicking.prototype.getPrevIndex = function getPrevIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[1], false, physical);\n\t};\n\n\t/**\n  * Returns the total number of whole panel elements.\n  * @ko 전체 패널 엘리먼트의 개수를 반환한다\n  * @method eg.Flicking#getTotalCount\n  * @deprecated since 1.3.0\n  * @param {Boolean} [physical=false] Number of elements relative to (true: DOM, false: panel content)<ko>엘리먼트 개수의 기준(true: DOM 엘리먼트 기준, false: 패널 콘텐츠 기준)</ko>\n  * @return {Number} Total number of whole panel elements <ko>모든 패널 엘리먼트의 개수</ko>\n  */\n\n\n\tFlicking.prototype.getTotalCount = function getTotalCount(physical) {\n\t\treturn this._conf.panel[physical ? \"count\" : \"origCount\"];\n\t};\n\n\t/**\n  * Checks whether the animated panel is playing.\n  * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n  * @method eg.Flicking#isPlaying\n  * @return {Boolean} Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n  */\n\n\n\tFlicking.prototype.isPlaying = function isPlaying() {\n\t\treturn this._conf.panel.animating;\n\t};\n\n\t/**\n  * Move panel to the given direction\n  * @param {Boolean} next\n  * @param {Number} duration\n  */\n\n\n\tFlicking.prototype._movePanel = function _movePanel(next, duration) {\n\t\tvar conf = this._conf;\n\t\tvar panel = conf.panel;\n\t\tvar options = this.options;\n\n\t\tif (panel.animating || conf.touch.holding) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._setValueToMove(next);\n\n\t\tif (options.circular || this[next ? \"getNextIndex\" : \"getPrevIndex\"]() != null) {\n\t\t\tthis._movePanelByPhase(\"setBy\", [panel.size * (next ? 1 : -1), 0], duration);\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Move panel applying start/end phase value\n  * @param {String} method movableCoord method name\n  * @param {Object} coords coordinate array value\n  * @param {Number} durationValue duration value\n  */\n\n\n\tFlicking.prototype._movePanelByPhase = function _movePanelByPhase(method, coords, durationValue) {\n\t\tvar duration = _utils.utils.getNumValue(durationValue, this.options.duration);\n\n\t\tif (this._setPhaseValue(\"start\") !== false) {\n\t\t\tthis._setMovableCoord(method, coords, true, duration);\n\t\t\t!duration && this._setPhaseValue(\"end\");\n\t\t}\n\t};\n\n\t/**\n  * Moves an element to the next panel.\n  * @ko 다음 패널로 이동한다.\n  * @method eg.Flicking#next\n  * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n  * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tFlicking.prototype.next = function next(duration) {\n\t\treturn this._movePanel(true, duration);\n\t};\n\n\t/**\n  * Moves an element to the previous panel.\n  * @ko 이전 패널로 이동한다.\n  * @method eg.Flicking#prev\n  * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n  * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tFlicking.prototype.prev = function prev(duration) {\n\t\treturn this._movePanel(false, duration);\n\t};\n\n\t/**\n  * Moves an element to the indicated panel.\n  * @ko 지정한 패널로 이동한다.\n  * @method eg.Flicking#moveTo\n  * @param {Number} no Logical index number of the target panel element, which is relative to the panel content. <ko>이동할 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n  * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n  * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tFlicking.prototype.moveTo = function moveTo(noValue, duration) {\n\t\tvar conf = this._conf;\n\t\tvar panel = conf.panel;\n\t\tvar circular = this.options.circular;\n\t\tvar currentIndex = panel.index;\n\t\tvar indexToMove = void 0;\n\t\tvar isPositive = void 0;\n\t\tvar no = noValue;\n\n\t\tno = _utils.utils.getNumValue(no, -1);\n\n\t\tif (no < 0 || no >= panel.origCount || no === panel.no || panel.animating || conf.touch.holding) {\n\t\t\treturn this;\n\t\t}\n\n\t\tindexToMove = no - (circular ? panel.no : currentIndex);\n\t\tisPositive = indexToMove > 0;\n\n\t\t// check for real panel count which can be moved on each sides in circular mode\n\t\tif (circular && Math.abs(indexToMove) > (isPositive ? panel.count - (currentIndex + 1) : currentIndex)) {\n\t\t\tindexToMove += (isPositive ? -1 : 1) * panel.count;\n\t\t\tisPositive = indexToMove > 0;\n\t\t}\n\n\t\tthis._setPanelNo(circular ? { no: no } : { no: no, index: no });\n\t\tthis._conf.indexToMove = indexToMove;\n\t\tthis._setValueToMove(isPositive);\n\n\t\tthis._movePanelByPhase(circular ? \"setBy\" : \"setTo\", [panel.size * (circular ? indexToMove : no), 0], duration);\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Update panel's previewPadding size according options.previewPadding\n  */\n\n\n\tFlicking.prototype._checkPadding = function _checkPadding() {\n\t\tvar options = this.options;\n\t\tvar previewPadding = options.previewPadding.concat();\n\t\tvar padding = _utils.utils.css(this.$wrapper, \"padding\").split(\" \");\n\n\t\toptions.horizontal && padding.reverse();\n\n\t\t// get current padding value\n\t\tpadding = [padding[0]];\n\t\tpadding.push(padding[padding.length === 2 ? 0 : 2]);\n\n\t\tpadding = padding.map(Number);\n\n\t\t// update padding when current and given are different\n\t\tif (previewPadding.length === 2 && previewPadding[0] !== padding[0] || previewPadding[1] !== padding[1]) {\n\t\t\tthis._setPadding(previewPadding);\n\t\t}\n\t};\n\n\t/**\n  * Updates the size of the panel.\n  * @ko 패널의 크기를 갱신한다\n  * @method eg.Flicking#resize\n  * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  let some = new eg.Flicking(\"#mflick\", {\n \t\t\t\tpreviewPadding: [10,10]\n \t\t\t});\n \t // when device orientaion changes\n  some.resize();\n \t // or when changes previewPadding option from its original value\n  some.options.previewPadding = [20, 30];\n  some.resize();\n  */\n\n\n\tFlicking.prototype.resize = function resize() {\n\t\tvar _utils$css;\n\n\t\tvar conf = this._conf;\n\t\tvar options = this.options;\n\t\tvar panel = conf.panel;\n\t\tvar horizontal = options.horizontal;\n\t\tvar panelSize = void 0;\n\n\t\tif (~~options.previewPadding.join(\"\")) {\n\t\t\tthis._checkPadding();\n\t\t\tpanelSize = panel.size;\n\t\t} else if (horizontal) {\n\t\t\tpanelSize = panel.size = _utils.utils.css(this.$wrapper, \"width\", true);\n\t\t}\n\n\t\tvar maxCoords = this._getDataByDirection([panelSize * (panel.count - 1), 0]);\n\n\t\t// resize elements\n\t\thorizontal && _utils.utils.css(this.$container, { width: maxCoords[0] + panelSize + \"px\" });\n\t\t_utils.utils.css(panel.$list, (_utils$css = {}, _utils$css[horizontal ? \"width\" : \"height\"] = _utils.utils.getUnitValue(panelSize), _utils$css));\n\n\t\t// remove data-height attribute and re-evaluate panel's height\n\t\tif (options.adaptiveHeight) {\n\t\t\tvar $panel = this.$container.querySelectorAll(\"[\" + consts.DATA_HEIGHT + \"]\");\n\n\t\t\tif ($panel.length) {\n\t\t\t\t[].slice.call($panel).forEach(function (v) {\n\t\t\t\t\treturn v.removeAttribute(consts.DATA_HEIGHT);\n\t\t\t\t});\n\n\t\t\t\tthis._setAdaptiveHeight();\n\t\t\t}\n\t\t}\n\n\t\tthis._mcInst.options.max = maxCoords;\n\t\tthis._setMovableCoord(\"setTo\", [panelSize * panel.index, 0], true, 0);\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tthis._applyPanelsPos();\n\t\t\tthis._adjustContainerCss(\"end\");\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Restores an element to its original position when it movement stops while the element is not dragged until a certain distance threshold is reached.\n  * @ko 다음 패널로 바뀌기 전에 패널 이동이 멈췄을 때 원래 패널로 복원한다\n  * @method eg.Flicking#restore\n  * @param {Number} [durationValue=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n  * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * let some = new eg.Flicking(\"#mflick\").on({\n  *\t\t\t\tbeforeFlickStart : function(e) {\n  *\t\t\t\t\tif(e.no === 2) {\n  *\t\t\t\t\t\te.stop();  // stop flicking\n  *\t\t\t\t\t\tthis.restore(100);  // restoring to previous position\n  *\t\t\t\t\t}\n  *\t\t\t\t}\n  *\t\t\t);\n  */\n\n\n\tFlicking.prototype.restore = function restore(durationValue) {\n\t\tvar conf = this._conf;\n\t\tvar panel = conf.panel;\n\t\tvar currPos = this._getDataByDirection(this._mcInst.get());\n\t\tvar duration = durationValue;\n\t\tvar destPos = void 0;\n\n\t\t// check if the panel isn't in right position\n\t\tif (currPos[0] !== panel.currIndex * panel.size) {\n\t\t\tconf.customEvent.restoreCall = true;\n\t\t\tduration = _utils.utils.getNumValue(duration, this.options.duration);\n\n\t\t\tthis._revertPanelNo();\n\t\t\tdestPos = this._getDataByDirection([panel.size * panel.index, 0]);\n\n\t\t\tthis._triggerBeforeRestore({ depaPos: currPos, destPos: destPos });\n\t\t\tthis._setMovableCoord(\"setTo\", destPos, true, duration);\n\n\t\t\tif (!duration) {\n\t\t\t\tthis._adjustContainerCss(\"end\");\n\t\t\t\tthis._triggerRestore();\n\t\t\t}\n\n\t\t\t// to handle on api call\n\t\t} else if (panel.changed) {\n\t\t\tthis._revertPanelNo();\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Enables input devices.\n  * @ko 입력 장치를 사용할 수 있게 한다\n  * @method eg.Flicking#enableInput\n  * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tFlicking.prototype.enableInput = function enableInput() {\n\t\tthis._mcInst.enableInput();\n\t\treturn this;\n\t};\n\n\t/**\n  * Disables input devices.\n  * @ko 입력 장치를 사용할 수 없게 한다.\n  * @method eg.Flicking#disableInput\n  * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tFlicking.prototype.disableInput = function disableInput() {\n\t\tthis._mcInst.disableInput();\n\t\treturn this;\n\t};\n\n\t/**\n  * Destroys elements, properties, and events used in a panel.\n  * @ko 패널에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n  * @method eg.Flicking#destroy\n  */\n\n\n\tFlicking.prototype.destroy = function destroy() {\n\t\tvar conf = this._conf;\n\t\tvar origPanelStyle = conf.origPanelStyle;\n\t\tvar wrapper = origPanelStyle.wrapper;\n\t\tvar container = origPanelStyle.container;\n\t\tvar list = origPanelStyle.list;\n\n\t\t// unwrap container element and restore original inline style\n\t\t// restore wrapper style\n\t\tvar $wrapper = this.$wrapper;\n\n\t\t$wrapper.setAttribute(\"class\", wrapper.className);\n\t\t$wrapper[wrapper.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", wrapper.style);\n\n\t\t// restore container style\n\t\tvar $container = this.$container;\n\t\tvar $children = [].slice.call($container.children);\n\n\t\tif (origPanelStyle.container.className) {\n\t\t\t$container.setAttribute(\"class\", container.className);\n\t\t\t$container[container.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", container.style);\n\t\t} else {\n\t\t\t$children.forEach(function (v) {\n\t\t\t\treturn $wrapper.appendChild(v);\n\t\t\t});\n\t\t\t$container.parentNode.removeChild($container);\n\t\t}\n\n\t\tfor (var i = 0, $el; $el = $children[i]; i++) {\n\t\t\tif (i > list.length - 1) {\n\t\t\t\t$el.parentNode.removeChild($el);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar className = list[i].className;\n\t\t\tvar style = list[i].style;\n\n\t\t\t$el[className ? \"setAttribute\" : \"removeAttribute\"](\"class\", className);\n\t\t\t$el[style ? \"setAttribute\" : \"removeAttribute\"](\"style\", style);\n\t\t}\n\n\t\t// unbind events\n\t\tthis._bindEvents(false);\n\t\tthis.off();\n\n\t\t// release resources\n\t\tfor (var x in this) {\n\t\t\tthis[x] = null;\n\t\t}\n\t};\n\n\treturn Flicking;\n}((0, _utils.Mixin)(_component2.default).with(_eventHandler2.default));\n\nexports.default = Flicking;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n// internal config values\nvar CONFIG = {\n\tpanel: {\n\t\t$list: null, // panel list\n\t\tindex: 0, // dom index used among process\n\t\tno: 0, // panel no used among process\n\t\tcurrIndex: 0, // current physical dom index\n\t\tcurrNo: 0, // current logical panel number\n\t\tsize: 0, // panel size\n\t\tcount: 0, // total physical panel count\n\t\torigCount: 0, // total count of given original panels\n\t\tchanged: false, // if panel changed\n\t\tanimating: false, // current animating status boolean\n\t\tminCount: 3 // minimum panel count\n\t},\n\ttouch: {\n\t\tholdPos: [0, 0], // hold x,y coordinate\n\t\tdestPos: [0, 0], // destination x,y coordinate\n\t\tdistance: 0, // touch distance pixel of start to end touch\n\t\tdirection: null, // touch direction\n\t\tlastPos: 0, // to determine move on holding\n\t\tholding: false\n\t},\n\tcustomEvent: { // for custom events value\n\t\tflick: true,\n\t\trestore: false,\n\t\trestoreCall: false\n\t},\n\tdirData: [], // direction constant value according horizontal or vertical\n\tindexToMove: 0,\n\t$dummyAnchor: null // For buggy link highlighting on Android 2.x\n};\n\n// default options\nvar OPTIONS = {\n\thwAccelerable: true, // ns.isHWAccelerable(),  // check weather hw acceleration is available\n\tprefix: \"eg-flick\", // prefix value of class name\n\tdeceleration: 0.0006, // deceleration value\n\thorizontal: true, // move direction (true == horizontal, false == vertical)\n\tcircular: false, // circular mode. In this mode at least 3 panels are required.\n\tpreviewPadding: null, // preview padding value in left(up) to right(down) order. In this mode at least 5 panels are required.\n\tbounce: null, // bounce value in left(up) to right(down) order. Works only in non-circular mode.\n\tthreshold: 40, // the distance pixel threshold value for change panel\n\tduration: 100, // duration ms for animation\n\tpanelEffect: function panelEffect(x) {\n\t\treturn 1 - Math.pow(1 - x, 3);\n\t}, // easing function for panel change animation\n\tdefaultIndex: 0, // initial panel index to be shown\n\tinputType: [// input type\n\t\"touch\", \"mouse\"],\n\tthresholdAngle: 45, // the threshold value that determines whether user action is horizontal or vertical (0~90)\n\tadaptiveHeight: false // Set container's height be adaptive according panel's height\n};\n\nexports.CONFIG = CONFIG;\nexports.OPTIONS = OPTIONS;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _consts = __webpack_require__(1);\n\nvar consts = _interopRequireWildcard(_consts);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2015 NAVER Corp.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * egjs projects are licensed under the MIT license\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nexports.default = function (superclass) {\n\treturn function (_superclass) {\n\t\t_inherits(_class, _superclass);\n\n\t\tfunction _class() {\n\t\t\t_classCallCheck(this, _class);\n\n\t\t\treturn _possibleConstructorReturn(this, _superclass.apply(this, arguments));\n\t\t}\n\n\t\t/**\n   * 'hold' event handler\n   */\n\t\t_class.prototype._holdHandler = function _holdHandler(e) {\n\t\t\tvar conf = this._conf;\n\n\t\t\tconf.touch.holdPos = e.pos;\n\t\t\tconf.touch.holding = true;\n\t\t\tconf.panel.changed = false;\n\n\t\t\tthis._adjustContainerCss(\"start\", e.pos);\n\t\t};\n\n\t\t/**\n   * 'change' event handler\n   */\n\n\n\t\t_class.prototype._changeHandler = function _changeHandler(e) {\n\t\t\tvar conf = this._conf;\n\t\t\tvar touch = conf.touch;\n\t\t\tvar posIndex = +!this.options.horizontal;\n\t\t\tvar pos = e.pos[posIndex];\n\t\t\tvar holdPos = touch.holdPos[posIndex];\n\t\t\tvar direction = void 0;\n\t\t\tvar eventRes = null;\n\t\t\tvar movedPx = void 0;\n\n\t\t\tthis._setPointerEvents(e); // for \"click\" bug\n\n\t\t\t/**\n    * This event is fired when panel moves.\n    * @ko 패널이 이동할 때 발생하는 이벤트\n    * @name eg.Flicking#flick\n    * @event\n    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n    * @param {String} param.eventType The name of the event<ko>이름명</ko>\n    * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n    * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n    * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n    * @param {Array} param.pos Start coordinate <ko>출발점 좌표</ko>\n    * @param {Number} param.pos.0 x-coordinate <ko>x 좌표</ko>\n    * @param {Number} param.pos.1 y-coordinate <ko>y 좌표</ko>\n    * @param {Boolean} param.holding Indicates whether a user holds an element on the screen of the device. <ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>\n    * @param {Number} param.distance Distance moved from then starting point. According the move direction, positive on eg.MovableCoord.DIRECTION_LEFT/UP and negative on eg.MovableCoord.DIRECTION_RIGHT/DOWN <ko>시작점부터 이동된 거리의 값. 이동 방향에 따라 eg.MovableCoord.DIRECTION_LEFT/UP의 경우 양수를 eg.MovableCoord.DIRECTION_RIGHT/DOWN의 경우는 음수를 반환</ko>\n    */\n\t\t\tif (e.hammerEvent) {\n\t\t\t\tdirection = e.hammerEvent.direction;\n\n\t\t\t\t// Adjust direction in case of diagonal touch move\n\t\t\t\tmovedPx = e.hammerEvent[this.options.horizontal ? \"deltaX\" : \"deltaY\"];\n\n\t\t\t\tif (!~conf.dirData.indexOf(direction)) {\n\t\t\t\t\tdirection = conf.dirData[+(Math.abs(touch.lastPos) <= movedPx)];\n\t\t\t\t}\n\n\t\t\t\ttouch.lastPos = movedPx;\n\t\t\t} else {\n\t\t\t\ttouch.lastPos = null;\n\t\t\t}\n\n\t\t\tconf.customEvent.flick && (eventRes = this._triggerEvent(consts.EVENTS.flick, {\n\t\t\t\tpos: e.pos,\n\t\t\t\tholding: e.holding,\n\t\t\t\tdirection: direction || touch.direction,\n\t\t\t\tdistance: pos - (holdPos || (touch.holdPos[posIndex] = pos))\n\t\t\t}));\n\n\t\t\t(eventRes || eventRes === null) && this._setTranslate([-pos, 0]);\n\t\t};\n\n\t\t/**\n   * 'release' event handler\n   */\n\n\n\t\t_class.prototype._releaseHandler = function _releaseHandler(e) {\n\t\t\tvar touch = this._conf.touch;\n\t\t\tvar pos = e.destPos;\n\t\t\tvar posIndex = +!this.options.horizontal;\n\t\t\tvar holdPos = touch.holdPos[posIndex];\n\t\t\tvar panelSize = this._conf.panel.size;\n\n\t\t\ttouch.distance = e.depaPos[posIndex] - touch.holdPos[posIndex];\n\n\t\t\ttouch.direction = this._conf.dirData[+!(touch.holdPos[posIndex] < e.depaPos[posIndex])];\n\n\t\t\tpos[posIndex] = Math.max(holdPos - panelSize, Math.min(holdPos, pos[posIndex]));\n\n\t\t\ttouch.destPos[posIndex] = pos[posIndex] = Math.round(pos[posIndex] / panelSize) * panelSize;\n\n\t\t\ttouch.distance === 0 && this._adjustContainerCss(\"end\");\n\t\t\ttouch.holding = false;\n\n\t\t\tthis._setPointerEvents(); // for \"click\" bug\n\t\t};\n\n\t\t/**\n   * 'animationStart' event handler\n   */\n\n\n\t\t_class.prototype._animationStartHandler = function _animationStartHandler(e) {\n\t\t\tvar conf = this._conf;\n\t\t\tvar panel = conf.panel;\n\t\t\tvar customEvent = conf.customEvent;\n\n\t\t\tpanel.animating = true;\n\n\t\t\tif (!customEvent.restoreCall && e.hammerEvent && this._setPhaseValue(\"start\", {\n\t\t\t\tdepaPos: e.depaPos,\n\t\t\t\tdestPos: e.destPos\n\t\t\t}) === false) {\n\t\t\t\te.stop();\n\t\t\t}\n\n\t\t\tif (e.hammerEvent) {\n\t\t\t\te.duration = this.options.duration;\n\n\t\t\t\te.destPos[+!this.options.horizontal] = panel.size * (panel.index + conf.indexToMove);\n\t\t\t}\n\n\t\t\tif (this._isMovable()) {\n\t\t\t\t!customEvent.restoreCall && (customEvent.restore = false);\n\t\t\t} else {\n\t\t\t\tthis._triggerBeforeRestore(e);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * 'animationEnd' event handler\n   */\n\n\n\t\t_class.prototype._animationEndHandler = function _animationEndHandler() {\n\t\t\tthis._setPhaseValue(\"end\");\n\n\t\t\tthis._conf.panel.animating = false;\n\t\t\tthis._triggerRestore();\n\t\t};\n\n\t\treturn _class;\n\t}(superclass);\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _Flicking = __webpack_require__(2);\n\nvar _Flicking2 = _interopRequireDefault(_Flicking);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_Flicking2.default.VERSION = \"2.0.0-rc.3\"; /**\n                                            * Copyright (c) 2015 NAVER Corp.\n                                            * egjs projects are licensed under the MIT license\n                                            */\n\nmodule.exports = _Flicking2.default;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Mixin = exports.utils = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * Copyright (c) 2015 NAVER Corp.\n                                                                                                                                                                                                                                                                               * egjs projects are licensed under the MIT license\n                                                                                                                                                                                                                                                                               */\n\n\nvar _browser = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar utils = {\n\t/**\n  * Select or create element\n  * @param {String|HTMLElement} param\n  *  when string given is as HTML tag, then create element\n  *  otherwise it returns selected elements\n  * @returns {HTMLElement}\n  */\n\t$: function $(param) {\n\t\tvar el = null;\n\n\t\tif (typeof param === \"string\") {\n\t\t\t// check if string is HTML tag format\n\t\t\tvar match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n\t\t\t// creating element\n\t\t\tif (match) {\n\t\t\t\tel = _browser.document.createElement(match[1]);\n\n\t\t\t\t// attributes\n\t\t\t\tmatch.length === 3 && match[2].split(\" \").forEach(function (v) {\n\t\t\t\t\tvar attr = v.split(\"=\");\n\n\t\t\t\t\tel.setAttribute(attr[0], attr[1].trim().replace(/(^[\"']|[\"']$)/g, \"\"));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel = _browser.document.querySelectorAll(param);\n\n\t\t\t\tif (!el.length) {\n\t\t\t\t\tel = null;\n\t\t\t\t} else if (el.length === 1) {\n\t\t\t\t\tel = el[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (param.nodeName && param.nodeType === 1) {\n\t\t\tel = param;\n\t\t}\n\n\t\treturn el;\n\t},\n\n\n\t/**\n  * Check if is array\n  * @param arr\n  * @returns {Boolean}\n  */\n\tisArray: function isArray(arr) {\n\t\treturn arr && arr.constructor === Array;\n\t},\n\n\n\t/**\n  * Check if is object\n  * @param {Object} obj\n  * @returns {Boolean}\n  */\n\tisObject: function isObject(obj) {\n\t\treturn obj && !obj.nodeType && (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" && !this.isArray(obj);\n\t},\n\n\n\t/**\n  * Merge object returning new object\n  * @param {Object} target\n  * @param {Object} objectN\n  * @returns {Object} merged target object\n  * @example\n  *  var target = { a: 1 };\n  *  utils.extend(target, { b: 2, c: 3 });\n  *  target;  // { a: 1, b: 2, c: 3 };\n  */\n\textend: function extend(target) {\n\t\tvar _this = this;\n\n\t\tfor (var _len = arguments.length, objectN = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\tobjectN[_key - 1] = arguments[_key];\n\t\t}\n\n\t\tif (!objectN.length || objectN.length === 1 && !objectN[0]) {\n\t\t\treturn target;\n\t\t}\n\n\t\tvar source = objectN.shift();\n\n\t\tif (this.isObject(target) && this.isObject(source)) {\n\t\t\tObject.keys(source).forEach(function (key) {\n\t\t\t\tvar value = source[key];\n\n\t\t\t\tif (_this.isObject(value)) {\n\t\t\t\t\t!target[key] && (target[key] = {});\n\n\t\t\t\t\ttarget[key] = _this.extend(target[key], value);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = _this.isArray(value) ? value.concat() : value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this.extend.apply(this, [target].concat(objectN));\n\t},\n\n\n\t/**\n  * Get or set the style value or apply\n  * @param {HTMLElement} el\n  * @param {String|Object} style\n  *  String: return style property value\n  *  Object: set style value\n  * @parma {Boolean} getAsNumber - get the value as number\n  * @returns {String|HTMLElement}\n  */\n\tcss: function css(el, style, getAsNumber) {\n\t\tif (typeof style === \"string\") {\n\t\t\tvar value = _browser.window.getComputedStyle(el)[style];\n\n\t\t\treturn getAsNumber ? this.getNumValue(value) : value;\n\t\t} else {\n\t\t\tvar applyStyle = function applyStyle(target, source) {\n\t\t\t\treturn Object.keys(source).forEach(function (v) {\n\t\t\t\t\ttarget[v] = source[v];\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tthis.isArray(el) ? el.forEach(function (v) {\n\t\t\t\treturn applyStyle(v.style, style);\n\t\t\t}) : applyStyle(el.style, style);\n\t\t}\n\n\t\treturn el;\n\t},\n\n\n\t/**\n  * Check and parse value to number\n  * @param {Number|String} val\n  * @param {Number} defVal\n  * @return {Number}\n  */\n\tgetNumValue: function getNumValue(val, defVal) {\n\t\tvar num = val;\n\n\t\treturn isNaN(num = parseInt(num, 10)) ? defVal : num;\n\t},\n\n\n\t/**\n  * Return unit formatted value\n  * @param {Number|String} val\n  * @return {String} val Value formatted with unit\n  */\n\tgetUnitValue: function getUnitValue(val) {\n\t\tvar rx = /(?:[a-z]{2,}|%)$/;\n\n\t\treturn (parseInt(val, 10) || 0) + (String(val).match(rx) || \"px\");\n\t},\n\n\n\t/**\n  * Get element's outer value\n  * @param {HTMLElement} el\n  * @param {String} type - [outerWidth|outerHeight]\n  * @returns {Number} outer's value\n  */\n\tgetOuter: function getOuter(el, type) {\n\t\tvar style = _browser.window.getComputedStyle(el);\n\t\tvar margin = type === \"outerWidth\" ? [\"marginLeft\", \"marginRight\"] : [\"marginTop\", \"marginBottom\"];\n\n\t\treturn this.getNumValue(style[type.replace(\"outer\", \"\").toLocaleLowerCase()]) + this.getNumValue(style[margin[0]]) + this.getNumValue(style[margin[1]]);\n\t},\n\n\n\t/**\n  * Get element's outerWidth value with margin\n  * @param {HTMLElement} el\n  * @returns {Number}\n  */\n\touterWidth: function outerWidth(el) {\n\t\treturn this.getOuter(el, \"outerWidth\");\n\t},\n\n\n\t/**\n  * Get element's outerHeight value with margin\n  * @param {HTMLElement} el\n  * @returns {Number}\n  */\n\touterHeight: function outerHeight(el) {\n\t\treturn this.getOuter(el, \"outerHeight\");\n\t},\n\n\n\t/**\n  * Checks whether hardware acceleration is enabled.\n  *\n  * @ko 하드웨어 가속을 사용할 수 있는 환경인지 확인한다\n  * @method eg#isHWAccelerable\n  * @return {Boolean} Indicates whether hardware acceleration is enabled. <ko>하드웨어 가속 사용 가능 여부</ko>\n  */\n\tisHWAccelerable: function isHWAccelerable() {\n\t\tvar ua = _browser.window.navigator.userAgent;\n\t\tvar result = false;\n\t\tvar match = void 0;\n\n\t\t// chrome 25- has a text blur bug (except Samsung's sbrowser)\n\t\tif (match = ua.match(/Chrome\\/(\\d+)/)) {\n\t\t\tresult = match[1] >= \"25\";\n\t\t} else if (/ie|edge|firefox|safari|inapp/.test(ua)) {\n\t\t\tresult = true;\n\t\t} else if (match = ua.match(/Android ([\\d.]+)/)) {\n\t\t\tvar version = match[1];\n\t\t\tvar useragent = (ua.match(/\\(.*\\)/) || [null])[0];\n\n\t\t\t// android 4.1+ blacklist\n\t\t\t// EK-GN120 : Galaxy Camera, SM-G386F : Galaxy Core LTE\n\t\t\t// SHW-M420 : Galaxy Nexus , SHW-M200 : NexusS , GT-S7562 : Galaxy S duos\n\t\t\tresult = version >= \"4.1.0\" && !/EK-GN120|SM-G386F/.test(useragent) || version >= \"4.0.3\" && /SHW-|SHV-|GT-|SCH-|SGH-|SPH-|LG-F160|LG-F100|LG-F180|LG-F200|EK-|IM-A|LG-F240|LG-F260/.test(useragent) && !/SHW-M420|SHW-M200|GT-S7562/.test(useragent);\n\t\t}\n\n\t\tthis.isHWAccelerable = function () {\n\t\t\treturn result;\n\t\t};\n\t\treturn result;\n\t},\n\n\n\t/**\n  * Returns the syntax of the translate style which is applied to CSS transition properties.\n  *\n  * @ko CSS 트랜지션 속성에 적용할 translate 스타일 구문을 반환한다\n  * @method eg#translate\n  * @param {String} x Distance to move along the X axis <ko>x축을 따라 이동할 거리</ko>\n  * @param {String} y Distance to move along the Y axis <ko>y축을 따라 이동할 거리</ko>\n  * @param {Boolean} [isHA] Force hardware acceleration <ko>하드웨어 가속 사용 여부</ko>\n  * @return {String} Syntax of the translate style <ko>translate 스타일 구문</ko>\n  */\n\ttranslate: function translate(x, y, isHA) {\n\t\treturn isHA || false ? \"translate3d(\" + x + \",\" + y + \",0)\" : \"translate(\" + x + \",\" + y + \")\";\n\t},\n\n\n\t// 1. user press one position on screen.\n\t// 2. user moves to the other position on screen.\n\t// 3. when user releases fingers on screen, 'click' event is fired at previous position.\n\thasClickBug: function hasClickBug() {\n\t\tvar ua = _browser.window.navigator.userAgent;\n\t\tvar result = /Safari/.test(ua);\n\n\t\tthis.hasClickBug = function () {\n\t\t\treturn result;\n\t\t};\n\t\treturn result;\n\t}\n};\n\nvar MixinBuilder = function () {\n\tfunction MixinBuilder(superclass) {\n\t\t_classCallCheck(this, MixinBuilder);\n\n\t\tthis.superclass = superclass || function () {\n\t\t\tfunction _class() {\n\t\t\t\t_classCallCheck(this, _class);\n\t\t\t}\n\n\t\t\treturn _class;\n\t\t}();\n\t}\n\n\tMixinBuilder.prototype.with = function _with() {\n\t\tfor (var _len2 = arguments.length, mixins = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\tmixins[_key2] = arguments[_key2];\n\t\t}\n\n\t\treturn mixins.reduce(function (c, m) {\n\t\t\treturn m(c);\n\t\t}, this.superclass);\n\t};\n\n\treturn MixinBuilder;\n}();\n\nvar Mixin = function Mixin(superclass) {\n\treturn new MixinBuilder(superclass);\n};\n\nexports.utils = utils;\nexports.Mixin = Mixin;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// flicking.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 554af3a090da75e42503","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable no-new-func, no-nested-ternary */\nconst win = typeof window !== \"undefined\" &&\n\twindow.Math === Math ?\n        window : typeof self !== \"undefined\" && self.Math === Math ?\n            self : Function(\"return this\")();\n/* eslint-enable no-new-func, no-nested-ternary */\n\nconst document = win.document;\n\nexport {\n    win as window,\n    document\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/browser.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport {window as global, document as doc} from \"./browser\";\n\n// define custom events name\nconst EVENTS = {\n\tbeforeFlickStart: \"beforeFlickStart\",\n\tbeforeRestore: \"beforeRestore\",\n\tflick: \"flick\",\n\tflickEnd: \"flickEnd\",\n\trestore: \"restore\"\n};\n\n// check for css transform support\nconst SUPPORT_TRANSFORM = (() => {\n\tconst style = doc.documentElement.style;\n\n\treturn \"transform\" in style || \"webkitTransform\" in style;\n})();\n\n// check for will-change support\nconst SUPPORT_WILLCHANGE = global.CSS && global.CSS.supports &&\n\tglobal.CSS.supports(\"will-change\", \"transform\");\n\n// check for Android 2.x\nconst IS_ANDROID2 = /Android 2\\./.test(navigator.userAgent);\n\n// data-height attribute's name for adaptiveHeight option\nconst DATA_HEIGHT = \"data-height\";\n\nexport {\n\tEVENTS,\n\tSUPPORT_TRANSFORM,\n\tSUPPORT_WILLCHANGE,\n\tIS_ANDROID2,\n\tDATA_HEIGHT\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/consts.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component from \"@egjs/component\";\nimport MovableCoord from \"@egjs/movablecoord\";\nimport {utils, Mixin} from \"./utils\";\nimport * as consts from \"./consts\";\nimport {CONFIG, OPTIONS} from \"./config\";\nimport {document} from \"./browser\";\nimport eventHandler from \"./eventHandler\";\n\n/**\n * A module used to implement flicking interactions. With this module, you can make flicking gestures, which are ways to navigate left and right to move between panels arranged side by side.\n * @ko 플리킹 UI를 구현하는 모듈. 나란히 배치한 패널을 쓸어 넘겨 다음 패널이나 이전 패널로 이동하는 플리킹 UI를 만들 수 있다.\n * @alias eg.Flicking\n * @extends eg.Component\n *\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.3+ (except 3.x)\"}\n */\nexport default class Flicking extends Mixin(Component).with(eventHandler) {\n\t/**\n\t * Constructor\n\t * @param {HTMLElement|String|jQuery} element A base element for the eg.Flicking module <ko>eg.Flicking 모듈을 사용할 기준 엘리먼트</ko>\n\t* @param {Object} options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n\t* @param {Boolean} [options.hwAccelerable=eg.isHWAccelerable()] Force hardware compositing <ko>하드웨어 가속 사용 여부</ko>\n\t* @param {String} [options.prefix=eg-flick] A prefix for class names of the panel elements <ko>패널 엘리먼트의 클래스 이름에 설정할 접두사</ko>\n\t* @param {Number} [options.deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>\n\t* @param {Boolean} [options.horizontal=true] Direction of the panel movement (true: horizontal, false: vertical) <ko>패널 이동 방향 (true 가로방향, false 세로방향)</ko>\n\t* @param {Boolean} [options.circular=false] Indicates whether a circular panel is available <ko>패널 순환 여부</ko>\n\t* @param {Number|Array} [options.previewPadding=[0,0]] The preview size for the previous or next panel. If direction is set to \"horizontal\", the preview section will be displayed on the left and right of the panel. If direction is set to \"vertical\", it will be displayed on the top and bottom of the panel <ko>이전 패널과 다음 패널을 미리 보는 영역의 크기. 패널 이동 방향이 가로 방향이면 패널 왼쪽과 오른쪽에 미리 보는 영역이 나타난다. 패널 이동 방향이 세로 방향이면 패널 위쪽과 아래쪽에 미리 보는 영역이 나타난다</ko>\n\t* @param {Number|Array} [options.bounce=[10,10]] −\tThe size of bouncing area. If a panel is set to \"non-circulable\", the start and end panels can exceed the base element area and move further as much as the bouncing area. If a panel is dragged to the bouncing area and then dropped, the panel where bouncing effects are applied is retuned back into the base element area. <ko>바운스 영역의 크기. 패널이 순환하지 않도록 설정됐다면 시작 패널과 마지막 패널은 기준 엘리먼트 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 패널을 바운스 영역까지 끌었다가 놓으면, 바운스 효과가 적용된 패널이 다시 기준 엘리먼트 영역 안으로 들어온다</ko>\n\t* @param {Number} [options.threshold=40] Distance threshold. If the drag exceeds the threshold value, it will be changed to the next panel <ko>다음 패널로 바뀌는 기준 이동 거리. 패널을 기준 이동 거리 이상 끌었다 놓으면 패널이 다음 패널로 바뀐다</ko>\n\t* @param {Number} [options.duration=100] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t* @param {Function} [options.panelEffect=easeOutCubic] The easing function to apply to a panel moving animation <ko>패널 이동 애니메이션에 적용할 easing 함수</ko>\n\t* @param {Number} [options.defaultIndex=0] The index number of a panel to be selected upon module initialization <ko>모듈이 초기화될 때 선택할 패널의 인덱스 번호</ko>\n\t* @param {Array} [options.inputType] Types of input devices.<br>- touch: A touch screen can be used to move a panel.<br>- mouse: A mouse can be used to move a panel. <ko>입력 장치 종류.<br>- touch: 터치 입력 장치로 패널을 이동할 수 있다.<br>- mouse: 마우스로 패널을 이동할 수 있다.</ko>\n\t* @param {Number} [options.thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>\n\t* @param {Boolean} [options.adaptiveHeight=false] Set container's height be adaptive according panel's height.<br>(Note: on Android 4.1.x stock browser, has rendering bug which not correctly render height value on panel with single node. To avoid just append another empty node at the end.)<ko>컨테이너 영역이 패널의 높이값에 따라 변경될지 여부<br>(참고: Android 4.1.x 스톡 브라우저에서 단일 노드로 구성된 패널의 높이값 변경이 제대로 렌더링 되지 않는 버그가 있음. 비어있는 노드를 추가하면 해결이 가능하다.)</ko>\n\t*\n * @see Easing Functions Cheat Sheet {@link http://easings.net/}\n * @see If you want to try a different easing function, use the jQuery easing plugin ({@link http://gsgd.co.uk/sandbox/jquery/easing}) or the jQuery UI easing library ({@link https://jqueryui.com/easing}). <ko>다른 easing 함수를 사용하려면 jQuery easing 플러그인({@link http://gsgd.co.uk/sandbox/jquery/easing})이나, jQuery UI easing 라이브러리({@link https://jqueryui.com/easing})를 사용한다</ko>\n\t*/\n\tconstructor(element, options, _prefix) {\n\t\tsuper();\n\n\t\tthis.$wrapper = utils.$(element);\n\t\tconst $children = this.$wrapper && this.$wrapper.children;\n\n\t\tif (!this.$wrapper || !$children || !$children.length) {\n\t\t\t// eslint-disable validateLineBreaks, maximumLineLength\n\t\t\tthrow new Error(\"Given base element doesn't exist or it hasn't proper DOM structure to be initialized.\");\n\n\t\t\t// eslint-enable validateLineBreaks, maximumLineLength\n\t\t}\n\n\t\tthis._setOptions(options);\n\t\tthis._setConfig($children, _prefix);\n\n\t\t!utils.hasClickBug() && (this._setPointerEvents = () => {});\n\n\t\tthis._build();\n\t\tthis._bindEvents(true);\n\n\t\tthis._applyPanelsCss();\n\t\tthis._arrangePanels();\n\n\t\tthis.options.hwAccelerable && consts.SUPPORT_WILLCHANGE && this._setHint();\n\t\tthis.options.adaptiveHeight && this._setAdaptiveHeight();\n\n\t\tthis._adjustContainerCss(\"end\");\n\t}\n\n\t/**\n\t * Set options values\n\t * @param {Object} options\n\t */\n\t_setOptions(options) {\n\t\t// default value of previewPadding and bounce\n\t\tconst arrVal = {\n\t\t\tpreviewPadding: [0, 0],\n\t\t\tbounce: [10, 10]\n\t\t};\n\n\t\tthis.options = utils.extend(utils.extend({}, OPTIONS), arrVal, options);\n\n\t\tfor (const key in arrVal) {\n\t\t\tlet val = this.options[key];\n\n\t\t\tif (typeof(val) === \"number\") {\n\t\t\t\tval = [val, val];\n\t\t\t} else if (!utils.isArray(val)) {\n\t\t\t\tval = arrVal[key];\n\t\t\t}\n\n\t\t\tthis.options[key] = val;\n\t\t}\n\t}\n\n\t/**\n\t * Set config values\n\t * @param {HTMLCollection} $children wrappers' children elements\n\t * @param {String} _prefix event prefix\n\t * @return {HTMLElement}\n\t */\n\t_setConfig($children, _prefix) {\n\t\tconst options = this.options;\n\t\tconst padding = options.previewPadding;\n\t\tlet $nodes = $children;\n\n\t\tif ($nodes[0].classList.contains(`${options.prefix}-container`)) {\n\t\t\t$nodes = $nodes[0];\n\t\t\tthis.$container = $nodes;\n\t\t\t$nodes = $nodes.children;\n\t\t}\n\n\t\t// convert to array\n\t\t$nodes = [].slice.call($nodes);\n\n\t\t// config value\n\t\tconst conf = this._conf = utils.extend(utils.extend({}, CONFIG), {\n\t\t\tpanel: {\n\t\t\t\t$list: $nodes,\n\t\t\t\tminCount: padding[0] + padding[1] > 0 ? 5 : 3  // minimum panel count\n\t\t\t},\n\t\t\t// remember original class and inline style in case of restoration on destroy()\n\t\t\torigPanelStyle: {\n\t\t\t\twrapper: {\n\t\t\t\t\tclassName: this.$wrapper.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: this.$wrapper.getAttribute(\"style\") || null\n\t\t\t\t},\n\t\t\t\tcontainer: {\n\t\t\t\t\tclassName: (this.$container && this.$container.getAttribute(\"class\")) || null,\n\t\t\t\t\tstyle: (this.$container && this.$container.getAttribute(\"style\")) || null\n\t\t\t\t},\n\t\t\t\tlist: $nodes.map(v => ({\n\t\t\t\t\tclassName: v.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: v.getAttribute(\"style\") || null\n\t\t\t\t}))\n\t\t\t},\n\t\t\tuseLayerHack: options.hwAccelerable && !consts.SUPPORT_WILLCHANGE,\n\t\t\teventPrefix: _prefix || \"\"\n\t\t});\n\n\t\t[[\"LEFT\", \"RIGHT\"], [\"UP\", \"DOWN\"]][+!options.horizontal]\n\t\t\t.forEach(v => conf.dirData.push(MovableCoord[`DIRECTION_${v}`]));\n\t}\n\n\t/**\n\t * Build and set panel nodes to make flicking structure\n\t */\n\t_build() {\n\t\tconst panel = this._conf.panel;\n\t\tconst options = this.options;\n\t\tconst $children = panel.$list;\n\t\tconst padding = options.previewPadding.concat();\n\t\tconst prefix = options.prefix;\n\t\tconst horizontal = options.horizontal;\n\t\tlet panelCount = panel.count = panel.origCount = $children.length;\n\t\tconst bounce = options.bounce;\n\n\t\tthis._setPadding(padding, true);\n\t\tconst sizeValue = this._getDataByDirection([panel.size, \"100%\"]);\n\n\t\t// container element style\n\t\tconst cssValue = {\n\t\t\tposition: \"relative\",\n\t\t\tzIndex: 2000,\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\"\n\t\t};\n\n\t\thorizontal && (cssValue.top = \"0px\");\n\n\t\tif (this.$container) {\n\t\t\tutils.css(this.$container, cssValue);\n\t\t} else {\n\t\t\tconst $parent = $children[0].parentNode;\n\t\t\tconst $container = document.createElement(\"div\");\n\n\t\t\t$container.className = `${prefix}-container`;\n\t\t\tutils.css($container, cssValue);\n\n\t\t\t$children.forEach(v => $container.appendChild(v));\n\n\t\t\t$parent.appendChild($container);\n\t\t\tthis.$container = $container;\n\t\t}\n\n\t\t// panels' css values\n\t\t$children.forEach(v => {\n\t\t\tv.classList.add(`${prefix}-panel`);\n\n\t\t\tutils.css(v, {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\twidth: utils.getUnitValue(sizeValue[0]),\n\t\t\t\theight: utils.getUnitValue(sizeValue[1]),\n\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t});\n\t\t});\n\n\t\tif (this._addClonePanels()) {\n\t\t\tpanelCount = panel.count = (\n\t\t\t\tpanel.$list = [].slice.call(this.$container.children)\n\t\t\t).length;\n\t\t}\n\n\t\t// create MovableCoord instance\n\t\tthis._mcInst = new MovableCoord({\n\t\t\tmin: [0, 0],\n\t\t\tmax: this._getDataByDirection([panel.size * (panelCount - 1), 0]),\n\t\t\tmargin: 0,\n\t\t\tcircular: false,\n\t\t\teasing: options.panelEffect,\n\t\t\tdeceleration: options.deceleration,\n\t\t\tbounce: this._getDataByDirection([0, bounce[1], 0, bounce[0]])\n\t\t});\n\n\t\tthis._setDefaultPanel(options.defaultIndex);\n\t}\n\n\t/**\n\t * Set preview padding value\n\t * @param {Array} padding\n\t * @param {Boolean} build\n\t */\n\t_setPadding(padding, build) {\n\t\tconst horizontal = this.options.horizontal;\n\t\tconst panel = this._conf.panel;\n\t\tconst paddingSum = padding[0] + padding[1];\n\t\tconst cssValue = {};\n\n\t\tif (paddingSum || !build) {\n\t\t\tcssValue.padding = horizontal ?\n\t\t\t\t`0 ${padding.reverse().join(\"px 0 \")}px` :\n\t\t\t\t`${padding.join(\"px 0 \")}px`;\n\t\t}\n\n\t\tif (build) {\n\t\t\tcssValue.overflow = \"hidden\";\n\t\t\tcssValue.boxSizing = \"border-box\";\n\t\t}\n\n\t\tObject.keys(cssValue).length &&\n\t\tutils.css(this.$wrapper, cssValue);\n\n\t\tconst wrapperStyle = getComputedStyle(this.$wrapper);\n\t\tconst paddingType = horizontal ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"];\n\n\t\tpanel.size = utils.getNumValue(wrapperStyle[horizontal ? \"width\" : \"height\"]) - (\n\t\t\t\tutils.getNumValue(wrapperStyle[`padding${paddingType[0]}`]) +\n\t\t\t\tutils.getNumValue(wrapperStyle[`padding${paddingType[1]}`])\n\t\t\t);\n\t}\n\n\t/**\n\t * To fulfill minimum panel count cloning original node when circular or previewPadding option are set\n\t * @return {Boolean} true : added clone node, false : not added\n\t */\n\t_addClonePanels() {\n\t\tconst panel = this._conf.panel;\n\t\tconst panelCount = panel.origCount;\n\t\tconst cloneCount = panel.minCount - panelCount;\n\t\tconst list = panel.$list;\n\t\tlet cloneNodes;\n\n\t\t// if panels are given less than required when circular option is set, then clone node to apply circular mode\n\t\tif (this.options.circular && panelCount < panel.minCount) {\n\t\t\tcloneNodes = list.map(v => v.cloneNode(true));\n\n\t\t\twhile (cloneNodes.length < cloneCount) {\n\t\t\t\tcloneNodes = cloneNodes.concat(\n\t\t\t\t\tlist.map(v => v.cloneNode(true))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcloneNodes.forEach(v => this.$container.appendChild(v));\n\n\t\t\treturn !!cloneNodes.length;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Move panel's position within array\n\t * @param {Number} count element counts to move\n\t * @param {Boolean} append where the list to be appended(moved) (true: to the end, false: to the beginning)\n\t */\n\t_movePanelPosition(count, append) {\n\t\tconst panel = this._conf.panel;\n\t\tconst list = panel.$list;\n\t\tconst listToMove = list.splice(append ? 0 : panel.count - count, count);\n\n\t\tpanel.$list = append ?\n\t\t\tlist.concat(listToMove) :\n\t\t\tlistToMove.concat(list);\n\t}\n\n\t/**\n\t * Set default panel to show\n\t * @param {Number} index\n\t */\n\t_setDefaultPanel(index) {\n\t\tconst panel = this._conf.panel;\n\t\tconst lastIndex = panel.count - 1;\n\t\tlet coords;\n\t\tlet baseIndex;\n\n\t\tif (this.options.circular) {\n\t\t\t// if default index is given, then move correspond panel to the first position\n\t\t\tif (index > 0 && index <= lastIndex) {\n\t\t\t\tthis._movePanelPosition(index, true);\n\t\t\t}\n\n\t\t\t// set first panel's position according physical node length\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\t\t\tthis._movePanelPosition(baseIndex, false);\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tno: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\t\t\t// if defaultIndex option is given, then move to that index panel\n\t\t} else if (index > 0 && index <= lastIndex) {\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex,\n\t\t\t\tno: index,\n\t\t\t\tcurrIndex: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\n\t\t\tcoords = [-(panel.size * index), 0];\n\n\t\t\tthis._setTranslate(coords);\n\t\t\tthis._setMovableCoord(\"setTo\", [\n\t\t\t\tMath.abs(coords[0]), Math.abs(coords[1])\n\t\t\t], true, 0);\n\t\t}\n\t}\n\n\t/**\n\t * Arrange panels' position\n\t * @param {Boolean} sort Need to sort panel's position\n\t * @param {Number} indexToMove Number to move from current position (negative: left, positive: right)\n\t */\n\t_arrangePanels(sort, indexToMove) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst touch = conf.touch;\n\t\tconst dirData = conf.dirData;\n\t\tlet baseIndex;\n\n\t\tif (this.options.circular) {\n\t\t\t// when arranging panels, set flag to not trigger flick custom event\n\t\t\tconf.customEvent.flick = false;\n\n\t\t\t// move elements according direction\n\t\t\tif (sort) {\n\t\t\t\tindexToMove && (touch.direction = dirData[+!(indexToMove > 0)]);\n\t\t\t\tthis._arrangePanelPosition(touch.direction, indexToMove);\n\t\t\t}\n\n\t\t\t// set index for base element's position\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex: baseIndex,\n\t\t\t\tcurrIndex: baseIndex\n\t\t\t});\n\n\t\t\t// arrange MovableCoord's coord position\n\t\t\tconf.customEvent.flick = !!this._setMovableCoord(\"setTo\", [\n\t\t\t\tpanel.size * panel.index, 0\n\t\t\t], true, 0);\n\t\t}\n\n\t\tthis._applyPanelsPos();\n\t}\n\n\t/**\n\t * Set each panel's position in DOM\n\t */\n\t_applyPanelsPos() {\n\t\tthis._conf.panel.$list.forEach(this._applyPanelsCss.bind(this));\n\t}\n\n\t/**\n\t * Set CSS style values to move elements\n\t *\n\t * Initialize setting up checking if browser support transform css property.\n\t * If browser doesn't support transform, then use left/top properties instead.\n\t * @param {HTMLElement} $element\n\t * @param {Array} coords\n\t */\n\t_setMoveStyle($el, coordsValue) {\n\t\tthis._setMoveStyle = consts.SUPPORT_TRANSFORM ?\n\t\t\tfunction moveStyle($element, coords) {\n\t\t\t\tutils.css($element, {\n\t\t\t\t\ttransform: utils.translate(coords[0], coords[1], this._conf.useLayerHack)\n\t\t\t\t});\n\t\t\t} : ($element, coords) => {\n\t\t\t\tutils.css($element, {left: coords[0], top: coords[1]});\n\t\t\t};\n\n\t\tthis._setMoveStyle($el, coordsValue);\n\t}\n\n\t/**\n\t * Callback function for applying CSS values to each panels\n\t *\n\t * Need to be initialized before use, to set up for Android 2.x browsers or others.\n\t */\n\t_applyPanelsCss() {\n\t\tconst conf = this._conf;\n\t\tconst dummyAnchorClassName = \"__dummy_anchor\";\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tconf.$dummyAnchor = utils.$(`.${dummyAnchorClassName}`);\n\n\t\t\t!conf.$dummyAnchor && this.$wrapper.appendChild(\n\t\t\t\t\tconf.$dummyAnchor = utils.$(`<a href=\"javascript:void(0)\" class=\"${dummyAnchorClassName}\" style=\"position:absolute;height:0px;width:0px\">`)\n\t\t\t\t);\n\n\t\t\tthis._applyPanelsCss = function applyCss(v, i) {\n\t\t\t\tconst coords = this._getDataByDirection([\n\t\t\t\t\t`${this._conf.panel.size * i}px`, 0\n\t\t\t\t]);\n\n\t\t\t\tutils.css(v, {\n\t\t\t\t\tleft: coords[0],\n\t\t\t\t\ttop: coords[1]\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis._applyPanelsCss = function applyCss(v, i) {\n\t\t\t\tconst coords = this._getDataByDirection([\n\t\t\t\t\tconsts.SUPPORT_TRANSFORM ?\n\t\t\t\t\t\t`${100 * i}%` :\n\t\t\t\t\t\t`${this._conf.panel.size * i}px`, 0\n\t\t\t\t]);\n\n\t\t\t\tthis._setMoveStyle(v, coords);\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Adjust container's css value to handle Android 2.x link highlighting bug\n\t *\n\t * @param {String} phase\n\t *    start - set left/top value to 0\n\t *    end - set translate value to 0\n\t * @param {Array} coordValue coordinate value\n\t */\n\t_adjustContainerCss(phase, coordValue) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst options = this.options;\n\t\tconst horizontal = options.horizontal;\n\t\tconst paddingTop = options.previewPadding[0];\n\t\tlet container = this.$container;\n\t\tlet coords = coordValue;\n\t\tlet value;\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tif (!coords) {\n\t\t\t\tcoords = [-panel.size * panel.index, 0];\n\t\t\t}\n\n\t\t\tif (phase === \"start\") {\n\t\t\t\tcontainer = container.style;\n\t\t\t\tvalue = parseInt(container[horizontal ? \"left\" : \"top\"], 10);\n\n\t\t\t\tif (horizontal) {\n\t\t\t\t\tvalue && (container.left = \"0px\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue !== paddingTop && (container.top = \"0px\");\n\t\t\t\t}\n\n\t\t\t\tthis._setTranslate([-coords[+!options.horizontal], 0]);\n\t\t\t} else if (phase === \"end\") {\n\t\t\t\tcoords = this._getCoordsValue(coords);\n\n\t\t\t\tutils.css(container, {\n\t\t\t\t\tleft: coords.x,\n\t\t\t\t\ttop: coords.y,\n\t\t\t\t\ttransform: utils.translate(0, 0, conf.useLayerHack)\n\t\t\t\t});\n\n\t\t\t\tconf.$dummyAnchor.focus();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set MovableCoord coord value\n\t * @param {String} method\n\t * @param {Array} coordValue\n\t * @param {Boolean} isDirVal\n\t * @param {Number} duration\n\t * @return {eg.MovableCoord} MovableCoord instance\n\t */\n\t_setMovableCoord(method, coordValue, isDirVal, duration) {\n\t\tlet coord = coordValue;\n\n\t\tif (isDirVal) {\n\t\t\tcoord = this._getDataByDirection(coord);\n\t\t}\n\n\t\treturn this._mcInst[method](coord[0], coord[1], duration);\n\t}\n\n\t/**\n\t * Set hint for browser to decide efficient way of doing transform changes(or animation)\n\t * https://dev.opera.com/articles/css-will-change-property/\n\t */\n\t_setHint() {\n\t\tconst style = {willChange: \"transform\"};\n\n\t\tutils.css(this.$container, style);\n\t\tutils.css(this._conf.panel.$list, style);\n\t}\n\n\t/**\n\t * Get data according options.horizontal value\n\t *\n\t * @param {Array} value primary data to handle\n\t * @return {Array}\n\t */\n\t_getDataByDirection(value) {\n\t\tconst data = value.concat();\n\n\t\t!this.options.horizontal && data.reverse();\n\t\treturn data;\n\t}\n\n\t/**\n\t * Move nodes\n\t * @param {Boolean} direction\n\t * @param {Number} indexToMove\n\t */\n\t_arrangePanelPosition(direction, indexToMove) {\n\t\tconst next = direction === this._conf.dirData[0];\n\n\t\tthis._movePanelPosition(Math.abs(indexToMove || 1), next);\n\t}\n\n\t/**\n\t * Get the base position index of the panel\n\t */\n\t_getBasePositionIndex() {\n\t\treturn Math.floor(this._conf.panel.count / 2 - 0.1);\n\t}\n\n\t/**\n\t * Bind events\n\t * @param {Boolean} bind\n\t */\n\t_bindEvents(bind) {\n\t\tconst options = this.options;\n\t\tconst $wrapper = this.$wrapper;\n\t\tconst mcInst = this._mcInst;\n\n\t\tif (bind) {\n\t\t\tmcInst.bind($wrapper, {\n\t\t\t\tscale: this._getDataByDirection([-1, 0]),\n\t\t\t\tdirection: MovableCoord[`DIRECTION_${options.horizontal ? \"HORIZONTAL\" : \"VERTICAL\"}`],\n\t\t\t\tinterruptable: false,\n\t\t\t\tinputType: options.inputType,\n\t\t\t\tthresholdAngle: options.thresholdAngle\n\t\t\t}).on({\n\t\t\t\thold: this._holdHandler.bind(this),\n\t\t\t\tchange: this._changeHandler.bind(this),\n\t\t\t\trelease: this._releaseHandler.bind(this),\n\t\t\t\tanimationStart: this._animationStartHandler.bind(this),\n\t\t\t\tanimationEnd: this._animationEndHandler.bind(this)\n\t\t\t});\n\t\t} else {\n\t\t\tmcInst.unbind($wrapper).off();\n\t\t}\n\t}\n\n\t/**\n\t * Set container's height value according to children's height\n\t * @param {Number} direction\n\t */\n\t_setAdaptiveHeight(direction) {\n\t\tconst conf = this._conf;\n\t\tconst indexToMove = conf.indexToMove;\n\t\tlet $children;\n\t\tlet height;\n\n\t\tconst $panel = indexToMove === 0 ?\n\n\t\t\t// panel moved by 1\n\t\t\tthis[`get${\n\t\t\t\t(direction === MovableCoord.DIRECTION_LEFT && \"Next\") ||\n\t\t\t\t(direction === MovableCoord.DIRECTION_RIGHT && \"Prev\") || \"\"\n\t\t\t}Element`]() :\n\n\t\t\t// panel moved by .moveTo()\n\t\t\tconf.panel.$list[\n\t\t\t\tconf.panel.currIndex + indexToMove\n\t\t\t];\n\n\t\tconst $first = $panel.querySelector(\":first-child\");\n\n\t\theight = $first.getAttribute(consts.DATA_HEIGHT);\n\n\t\tif (!height) {\n\t\t\t$children = $panel.children;\n\t\t\theight = utils.outerHeight(\n\t\t\t\t$children.length > 1 ? ($panel.style.height = \"auto\", $panel) : $first\n\t\t\t);\n\n\t\t\t$first.setAttribute(consts.DATA_HEIGHT, height);\n\t\t}\n\n\t\tthis.$wrapper.style.height = `${height}px`;\n\t}\n\n\t/**\n\t * Trigger beforeRestore event\n\t * @param {Object} e event object\n\t */\n\t_triggerBeforeRestore(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\n\t\t// reverse direction value when restore\n\t\ttouch.direction = ~~conf.dirData.join(\"\").replace(touch.direction, \"\");\n\n\t\t/**\n\t\t * This event is fired before an element is restored to its original position when user action is done while the element is not dragged until a certain distance threshold is reached\n\t\t * @ko 다음 패널로 바뀌는 기준 이동 거리만큼 이동하기 전에 사용자의 동작이 끝났을 때 원래 패널로 복원되기 전에 발생하는 이벤트\n\t\t * @name eg.Flicking#beforeRestore\n\t\t * @event\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM. (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다. (@deprecated since 1.3.0)</ko>\n\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content.<ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t * @param {Array} param.depaPos Start coordinate <ko>출발점 좌표</ko>\n\t\t * @param {Number} param.depaPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t * @param {Number} param.depaPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t * @param {Array} param.destPos End coordinate <ko>도착점 좌표</ko>\n\t\t * @param {Number} param.destPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t * @param {Number} param.destPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t */\n\t\tconf.customEvent.restore = this._triggerEvent(consts.EVENTS.beforeRestore, {\n\t\t\tdepaPos: e.depaPos,\n\t\t\tdestPos: e.destPos\n\t\t});\n\n\t\tif (!conf.customEvent.restore) {\n\t\t\t\"stop\" in e && e.stop();\n\t\t\tconf.panel.animating = false;\n\t\t}\n\t}\n\n\t/**\n\t * Trigger restore event\n\t */\n\t_triggerRestore() {\n\t\tconst customEvent = this._conf.customEvent;\n\n\t\t/**\n\t\t * This event is fired after an element is restored to its original position when user action is done while the element is not dragged until a certain distance threshold is reached.\n\t\t * @ko 다음 패널로 바뀌는 기준 이동 거리만큼 이동하기 전에 사용자의 동작이 끝났을 때 원래 패널로 복원된 다음 발생하는 이벤트\n\t\t * @name eg.Flicking#restore\n\t\t * @event\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM(@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content. <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t * @param {Number} param.direction Direction of the panel move (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t */\n\t\tcustomEvent.restore && this._triggerEvent(consts.EVENTS.restore);\n\t\tcustomEvent.restoreCall = false;\n\t}\n\n\t/**\n\t * Set value when panel changes\n\t * @param {String} phase - [start|end]\n\t * @param {Object} pos\n\t */\n\t_setPhaseValue(phase, pos) {\n\t\tconst conf = this._conf;\n\t\tconst options = this.options;\n\t\tconst panel = conf.panel;\n\n\t\tif (phase === \"start\" && (panel.changed = this._isMovable())) {\n\t\t\t/**\n\t\t\t * This event is fired before flicking starts\n\t\t\t * @ko 플리킹이 시작하기 전에 발생하는 이벤트\n\t\t\t * @name eg.Flicking#beforeFlickStart\n\t\t\t * @event\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM. (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content.<ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t\t * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>−\t이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t\t * @param {Array} param.depaPos Start coordinate <ko>출발점 좌표</ko>\n\t\t\t * @param {Number} param.depaPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t\t * @param {Number} param.depaPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t\t * @param {Array} param.destPos End coordinate <ko>도착점 좌표</ko>\n\t\t\t * @param {Number} param.destPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t\t * @param {Number} param.destPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t\t */\n\t\t\tif (!this._triggerEvent(consts.EVENTS.beforeFlickStart, pos)) {\n\t\t\t\tpanel.changed = panel.animating = false;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\toptions.adaptiveHeight && this._setAdaptiveHeight(conf.touch.direction);\n\t\t\t}\n\n\t\t\tconf.indexToMove === 0 && this._setPanelNo();\n\t\t} else if (phase === \"end\") {\n\t\t\tif (options.circular && panel.changed) {\n\t\t\t\tthis._arrangePanels(true, conf.indexToMove);\n\t\t\t}\n\n\t\t\t!consts.IS_ANDROID2 && this._setTranslate([-panel.size * panel.index, 0]);\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\n\t\t\t/**\n\t\t\t * This event is fired after panel moves.\n\t\t\t * @ko 패널이 이동한 다음 발생하는 이벤트\n\t\t\t * @name eg.Flicking#flickEnd\n\t\t\t * @event\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content. <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t\t\t * @param {Number} param.direction Direction of the movemen (see eg.MovableCoord.DIRECTION_* constant) <ko>−\t이동 방향(eg.MovableCoord.DIRECTION_* constant 참고</ko>\n\t\t\t */\n\t\t\tpanel.changed && this._triggerEvent(consts.EVENTS.flickEnd);\n\t\t}\n\n\t\tthis._adjustContainerCss(phase);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get positive or negative according direction\n\t */\n\t_getNumByDirection() {\n\t\tconst conf = this._conf;\n\n\t\treturn conf.touch.direction === conf.dirData[0] ? 1 : -1;\n\t}\n\n\t/**\n\t * Revert panel number\n\t */\n\t_revertPanelNo() {\n\t\tconst panel = this._conf.panel;\n\t\tconst num = this._getNumByDirection();\n\n\t\tconst index = panel.currIndex >= 0 ? panel.currIndex : panel.index - num;\n\t\tconst no = panel.currNo >= 0 ? panel.currNo : panel.no - num;\n\n\t\tthis._setPanelNo({\n\t\t\tindex,\n\t\t\tno\n\t\t});\n\t}\n\n\t/**\n\t * Set the panel number\n\t * @param {Object} obj number object\n\t */\n\t_setPanelNo(obj) {\n\t\tconst panel = this._conf.panel;\n\t\tconst count = panel.origCount - 1;\n\t\tconst num = this._getNumByDirection();\n\n\t\tif (utils.isObject(obj)) {\n\t\t\tfor (const key in obj) {\n\t\t\t\tpanel[key] = obj[key];\n\t\t\t}\n\t\t} else {\n\t\t\t// remember current value\n\t\t\tpanel.currIndex = panel.index;\n\t\t\tpanel.currNo = panel.no;\n\n\t\t\tpanel.index += num;\n\t\t\tpanel.no += num;\n\t\t}\n\n\t\tif (panel.no > count) {\n\t\t\tpanel.no = 0;\n\t\t} else if (panel.no < 0) {\n\t\t\tpanel.no = count;\n\t\t}\n\t}\n\n\t/**\n\t * Set pointerEvents css property on container element due to the iOS click bug\n\t * @param {Event} e\n\t */\n\t_setPointerEvents(e) {\n\t\tconst pointer = utils.css(this.$container, \"pointerEvents\");\n\t\tlet val;\n\n\t\tif (e && e.holding &&\n\t\t\te.hammerEvent && e.hammerEvent.preventSystemEvent &&\n\t\t\tpointer !== \"none\"\n\t\t) {\n\t\t\tval = \"none\";\n\t\t} else if (!e && pointer !== \"auto\") {\n\t\t\tval = \"auto\";\n\t\t}\n\n\t\tval && utils.css(this.$container, {pointerEvents: val});\n\t}\n\n\t/**\n\t * Get coordinate value with unit\n\t * @param coords {Array} x,y numeric value\n\t * @return {Object} x,y coordinate value with unit\n\t */\n\t_getCoordsValue(coordsValue) {\n\t\t// the param comes as [ val, 0 ], whatever the direction. So reorder the value depend the direction.\n\t\tconst coords = this._getDataByDirection(coordsValue);\n\n\t\treturn {\n\t\t\tx: utils.getUnitValue(coords[0]),\n\t\t\ty: utils.getUnitValue(coords[1])\n\t\t};\n\t}\n\n\t/**\n\t * Set translate property value\n\t * @param {Array} coords coordinate x,y value\n\t */\n\t_setTranslate(coordsValue) {\n\t\tconst coords = this._getCoordsValue(coordsValue);\n\n\t\tthis._setMoveStyle(this.$container, [coords.x, coords.y]);\n\t}\n\n\t/**\n\t * Check if panel passed through threshold pixel\n\t */\n\t_isMovable() {\n\t\tconst options = this.options;\n\t\tconst mcInst = this._mcInst;\n\t\tconst isMovable = Math.abs(this._conf.touch.distance) >= options.threshold;\n\t\tlet max;\n\t\tlet currPos;\n\n\t\tif (!options.circular && isMovable) {\n\t\t\tmax = this._getDataByDirection(mcInst.options.max)[0];\n\t\t\tcurrPos = this._getDataByDirection(mcInst.get())[0];\n\n\t\t\t// if current position out of range\n\t\t\tif (currPos < 0 || currPos > max) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn isMovable;\n\t}\n\n\t/**\n\t * Trigger custom events\n\t * @param {String} name - event name\n\t * @param {Object} param - additional event value\n\t * @return {Boolean}\n\t */\n\t_triggerEvent(name, param) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\n\t\t// pass changed panel no only on 'flickEnd' event\n\t\tif (name === consts.EVENTS.flickEnd) {\n\t\t\tpanel.currNo = panel.no;\n\t\t\tpanel.currIndex = panel.index;\n\t\t}\n\n\t\treturn this.trigger(conf.eventPrefix + name, utils.extend({\n\t\t\teventType: name,\n\t\t\tindex: panel.currIndex,\n\t\t\tno: panel.currNo,\n\t\t\tdirection: conf.touch.direction\n\t\t}, param));\n\t}\n\n\t/**\n\t * Get next/prev panel element/index.\n\t * @param {Boolean} direction\n\t * @param {Boolean} element - true:to get element, false:to get index\n\t * @param {Number} physical - true : physical, false : logical\n\t * @return {HTMLElement|Number}\n\t */\n\t_getElement(direction, element, physical) {\n\t\tconst panel = this._conf.panel;\n\t\tconst circular = this.options.circular;\n\t\tconst pos = panel.currIndex;\n\t\tconst next = direction === this._conf.dirData[0];\n\t\tlet result = null;\n\t\tlet total;\n\t\tlet index;\n\n\t\tif (physical) {\n\t\t\ttotal = panel.count;\n\t\t\tindex = pos;\n\t\t} else {\n\t\t\ttotal = panel.origCount;\n\t\t\tindex = panel.currNo;\n\t\t}\n\n\t\tconst currentIndex = index;\n\n\t\tif (next) {\n\t\t\tif (index < total - 1) {\n\t\t\t\tindex++;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (index > 0) {\n\t\t\t\tindex--;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = total - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (currentIndex !== index) {\n\t\t\tresult = element ? panel.$list[next ? pos + 1 : pos - 1] : index;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Set value to force move panels when duration is 0\n\t * @param {Boolean} next\n\t */\n\t_setValueToMove(next) {\n\t\tconst conf = this._conf;\n\n\t\tconf.touch.distance = this.options.threshold + 1;\n\t\tconf.touch.direction = conf.dirData[+!next];\n\t}\n\n\t/**\n\t * Returns the index number of the current panel element.\n\t * @ko 현재 패널 엘리먼트의 인덱스 번호를 반환한다\n\t * @method eg.Flicking#getIndex\n\t * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t * @return {Number} Index number of the current panel element <ko>현재 패널의 인덱스 번호</ko>\n\t */\n\tgetIndex(physical) {\n\t\treturn this._conf.panel[physical ? \"currIndex\" : \"currNo\"];\n\t}\n\n\t/**\n\t * Returns the reference of the current panel element.\n\t * @ko 현재 패널 엘리먼트의 레퍼런스를 반환한다\n\t * @method eg.Flicking#getElement\n\t * @return {HTMLElement} Current element <ko>현재 엘리먼트</ko>\n\t */\n\tgetElement() {\n\t\tconst panel = this._conf.panel;\n\n\t\treturn panel.$list[panel.currIndex];\n\t}\n\n\t/**\n\t * Returns the reference of the next panel element.\n\t * @ko 다음 패널 엘리먼트의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getNextElement\n\t * @return {HTMLElement|null} Next panel element or null if it does not exist.<ko>다음 패널 엘리먼트. 패널이 없으면 'null'을 반환한다.</ko>\n\t */\n\tgetNextElement() {\n\t\treturn this._getElement(this._conf.dirData[0], true);\n\t}\n\n\t/**\n\t * Returns the index number of the next panel element.\n\t * @ko 다음 패널 엘리먼트의 인덱스 번호를 반환한다\n\t * @method eg.Flicking#getNextIndex\n\t * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t * @return {Number|null} Index number of the next panel element or null if it does not exist. <ko>다음 패널 엘리먼트의 인덱스 번호. 패널이 없으면 'null'을 반환한다</ko>\n\t */\n\tgetNextIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[0], false, physical);\n\t}\n\n\t/**\n\t * Returns the references of whole panel elements.\n\t * @ko 패널을 구성하는 모든 엘리먼트의 레퍼런스를 반환한다\n\t * @method eg.Flicking#getAllElements\n\t * @return {HTMLElement} Whole panel elements <ko>모든 패널 엘리먼트</ko>\n\t */\n\tgetAllElements() {\n\t\treturn this._conf.panel.$list;\n\t}\n\n\t/**\n\t * Returns the reference of the previous panel element.\n\t * @ko 이전 패널 엘리먼트의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getPrevElement\n\t * @return {HTMLElement|null} Previous panel element or null if it does not exist. <ko>이전 패널 엘리먼트. 패널이 없으면 'null'을 반환한다</ko>\n\t */\n\tgetPrevElement() {\n\t\treturn this._getElement(this._conf.dirData[1], true);\n\t}\n\n\t/**\n\t * Returns the index number of the previous panel element.\n\t * @ko 이전 패널 엘리먼트의 인덱스 번호를 반환한다\n\t * @method eg.Flicking#getPrevIndex\n\t * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t * @return {Number|null} Previous element index value or null if no more element exist<ko>이전 패널 인덱스 번호. 패널이 없는 경우에는 null</ko>\n\t */\n\tgetPrevIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[1], false, physical);\n\t}\n\n\t/**\n\t * Returns the total number of whole panel elements.\n\t * @ko 전체 패널 엘리먼트의 개수를 반환한다\n\t * @method eg.Flicking#getTotalCount\n\t * @deprecated since 1.3.0\n\t * @param {Boolean} [physical=false] Number of elements relative to (true: DOM, false: panel content)<ko>엘리먼트 개수의 기준(true: DOM 엘리먼트 기준, false: 패널 콘텐츠 기준)</ko>\n\t * @return {Number} Total number of whole panel elements <ko>모든 패널 엘리먼트의 개수</ko>\n\t */\n\tgetTotalCount(physical) {\n\t\treturn this._conf.panel[physical ? \"count\" : \"origCount\"];\n\t}\n\n\t/**\n\t * Checks whether the animated panel is playing.\n\t * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n\t * @method eg.Flicking#isPlaying\n\t * @return {Boolean} Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n\t */\n\tisPlaying() {\n\t\treturn this._conf.panel.animating;\n\t}\n\n\t/**\n\t * Move panel to the given direction\n\t * @param {Boolean} next\n\t * @param {Number} duration\n\t */\n\t_movePanel(next, duration) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst options = this.options;\n\n\t\tif (panel.animating || conf.touch.holding) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._setValueToMove(next);\n\n\t\tif (options.circular ||\n\t\t\tthis[next ? \"getNextIndex\" : \"getPrevIndex\"]() != null\n\t\t) {\n\t\t\tthis._movePanelByPhase(\"setBy\", [\n\t\t\t\tpanel.size * (next ? 1 : -1), 0\n\t\t\t], duration);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Move panel applying start/end phase value\n\t * @param {String} method movableCoord method name\n\t * @param {Object} coords coordinate array value\n\t * @param {Number} durationValue duration value\n\t */\n\t_movePanelByPhase(method, coords, durationValue) {\n\t\tconst duration = utils.getNumValue(durationValue, this.options.duration);\n\n\t\tif (this._setPhaseValue(\"start\") !== false) {\n\t\t\tthis._setMovableCoord(method, coords, true, duration);\n\t\t\t!duration && this._setPhaseValue(\"end\");\n\t\t}\n\t}\n\n\t/**\n\t * Moves an element to the next panel.\n\t * @ko 다음 패널로 이동한다.\n\t * @method eg.Flicking#next\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t */\n\tnext(duration) {\n\t\treturn this._movePanel(true, duration);\n\t}\n\n\t/**\n\t * Moves an element to the previous panel.\n\t * @ko 이전 패널로 이동한다.\n\t * @method eg.Flicking#prev\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tprev(duration) {\n\t\treturn this._movePanel(false, duration);\n\t}\n\n\t/**\n\t * Moves an element to the indicated panel.\n\t * @ko 지정한 패널로 이동한다.\n\t * @method eg.Flicking#moveTo\n\t * @param {Number} no Logical index number of the target panel element, which is relative to the panel content. <ko>이동할 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tmoveTo(noValue, duration) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst circular = this.options.circular;\n\t\tconst currentIndex = panel.index;\n\t\tlet indexToMove;\n\t\tlet isPositive;\n\t\tlet no = noValue;\n\n\t\tno = utils.getNumValue(no, -1);\n\n\t\tif (no < 0 || no >= panel.origCount || no === panel.no ||\n\t\t\tpanel.animating || conf.touch.holding) {\n\t\t\treturn this;\n\t\t}\n\n\t\tindexToMove = no - (circular ? panel.no : currentIndex);\n\t\tisPositive = indexToMove > 0;\n\n\t\t// check for real panel count which can be moved on each sides in circular mode\n\t\tif (circular &&\n\t\t\tMath.abs(indexToMove) >\n\t\t\t(isPositive ? panel.count - (currentIndex + 1) : currentIndex)) {\n\t\t\tindexToMove += (isPositive ? -1 : 1) * panel.count;\n\t\t\tisPositive = indexToMove > 0;\n\t\t}\n\n\t\tthis._setPanelNo(circular ? {no} : {no, index: no});\n\t\tthis._conf.indexToMove = indexToMove;\n\t\tthis._setValueToMove(isPositive);\n\n\t\tthis._movePanelByPhase(\n\t\t\tcircular ? \"setBy\" : \"setTo\",\n\t\t\t[panel.size * (circular ? indexToMove : no), 0],\n\t\t\tduration\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Update panel's previewPadding size according options.previewPadding\n\t */\n\t_checkPadding() {\n\t\tconst options = this.options;\n\t\tconst previewPadding = options.previewPadding.concat();\n\t\tlet padding = utils.css(this.$wrapper, \"padding\").split(\" \");\n\n\t\toptions.horizontal && padding.reverse();\n\n\t\t// get current padding value\n\t\tpadding = [padding[0]];\n\t\tpadding.push(padding[padding.length === 2 ? 0 : 2]);\n\n\t\tpadding = padding.map(Number);\n\n\t\t// update padding when current and given are different\n\t\tif ((previewPadding.length === 2 && previewPadding[0] !== padding[0]) ||\n\t\t\tpreviewPadding[1] !== padding[1]) {\n\t\t\tthis._setPadding(previewPadding);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the size of the panel.\n\t * @ko 패널의 크기를 갱신한다\n\t * @method eg.Flicking#resize\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t let some = new eg.Flicking(\"#mflick\", {\n\t\t\t\t\tpreviewPadding: [10,10]\n\t\t\t\t});\n\n\t // when device orientaion changes\n\t some.resize();\n\n\t // or when changes previewPadding option from its original value\n\t some.options.previewPadding = [20, 30];\n\t some.resize();\n\t */\n\tresize() {\n\t\tconst conf = this._conf;\n\t\tconst options = this.options;\n\t\tconst panel = conf.panel;\n\t\tconst horizontal = options.horizontal;\n\t\tlet panelSize;\n\n\t\tif (~~options.previewPadding.join(\"\")) {\n\t\t\tthis._checkPadding();\n\t\t\tpanelSize = panel.size;\n\t\t} else if (horizontal) {\n\t\t\tpanelSize = panel.size = utils.css(this.$wrapper, \"width\", true);\n\t\t}\n\n\t\tconst maxCoords = this._getDataByDirection(\n\t\t\t[panelSize * (panel.count - 1), 0]\n\t\t);\n\n\t\t// resize elements\n\t\thorizontal && utils.css(this.$container, {width: `${maxCoords[0] + panelSize}px`});\n\t\tutils.css(panel.$list, {\n\t\t\t[horizontal ? \"width\" : \"height\"]: utils.getUnitValue(panelSize)\n\t\t});\n\n\t\t// remove data-height attribute and re-evaluate panel's height\n\t\tif (options.adaptiveHeight) {\n\t\t\tconst $panel = this.$container.querySelectorAll(`[${consts.DATA_HEIGHT}]`);\n\n\t\t\tif ($panel.length) {\n\t\t\t\t[].slice.call($panel)\n\t\t\t\t\t.forEach(v => v.removeAttribute(consts.DATA_HEIGHT));\n\n\t\t\t\tthis._setAdaptiveHeight();\n\t\t\t}\n\t\t}\n\n\t\tthis._mcInst.options.max = maxCoords;\n\t\tthis._setMovableCoord(\"setTo\", [panelSize * panel.index, 0], true, 0);\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tthis._applyPanelsPos();\n\t\t\tthis._adjustContainerCss(\"end\");\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restores an element to its original position when it movement stops while the element is not dragged until a certain distance threshold is reached.\n\t * @ko 다음 패널로 바뀌기 전에 패널 이동이 멈췄을 때 원래 패널로 복원한다\n\t * @method eg.Flicking#restore\n\t * @param {Number} [durationValue=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * let some = new eg.Flicking(\"#mflick\").on({\n\t *\t\t\t\tbeforeFlickStart : function(e) {\n\t *\t\t\t\t\tif(e.no === 2) {\n\t *\t\t\t\t\t\te.stop();  // stop flicking\n\t *\t\t\t\t\t\tthis.restore(100);  // restoring to previous position\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t);\n\t */\n\trestore(durationValue) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst currPos = this._getDataByDirection(this._mcInst.get());\n\t\tlet duration = durationValue;\n\t\tlet destPos;\n\n\t\t// check if the panel isn't in right position\n\t\tif (currPos[0] !== panel.currIndex * panel.size) {\n\t\t\tconf.customEvent.restoreCall = true;\n\t\t\tduration = utils.getNumValue(duration, this.options.duration);\n\n\t\t\tthis._revertPanelNo();\n\t\t\tdestPos = this._getDataByDirection([panel.size * panel.index, 0]);\n\n\t\t\tthis._triggerBeforeRestore({depaPos: currPos, destPos});\n\t\t\tthis._setMovableCoord(\"setTo\", destPos, true, duration);\n\n\t\t\tif (!duration) {\n\t\t\t\tthis._adjustContainerCss(\"end\");\n\t\t\t\tthis._triggerRestore();\n\t\t\t}\n\n\t\t\t// to handle on api call\n\t\t} else if (panel.changed) {\n\t\t\tthis._revertPanelNo();\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enables input devices.\n\t * @ko 입력 장치를 사용할 수 있게 한다\n\t * @method eg.Flicking#enableInput\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t */\n\tenableInput() {\n\t\tthis._mcInst.enableInput();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Disables input devices.\n\t * @ko 입력 장치를 사용할 수 없게 한다.\n\t * @method eg.Flicking#disableInput\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t */\n\tdisableInput() {\n\t\tthis._mcInst.disableInput();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Destroys elements, properties, and events used in a panel.\n\t * @ko 패널에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n\t * @method eg.Flicking#destroy\n\t */\n\tdestroy() {\n\t\tconst conf = this._conf;\n\t\tconst origPanelStyle = conf.origPanelStyle;\n\t\tconst wrapper = origPanelStyle.wrapper;\n\t\tconst container = origPanelStyle.container;\n\t\tconst list = origPanelStyle.list;\n\n\t\t// unwrap container element and restore original inline style\n\t\t// restore wrapper style\n\t\tconst $wrapper = this.$wrapper;\n\n\t\t$wrapper.setAttribute(\"class\", wrapper.className);\n\t\t$wrapper[wrapper.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", wrapper.style);\n\n\t\t// restore container style\n\t\tconst $container = this.$container;\n\t\tconst $children = []\n\t\t\t.slice.call($container.children);\n\n\t\tif (origPanelStyle.container.className) {\n\t\t\t$container.setAttribute(\"class\", container.className);\n\t\t\t$container[container.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", container.style);\n\t\t} else {\n\t\t\t$children.forEach(v => $wrapper.appendChild(v));\n\t\t\t$container.parentNode.removeChild($container);\n\t\t}\n\n\t\tfor (let i = 0, $el; ($el = $children[i]); i++) {\n\t\t\tif (i > list.length - 1) {\n\t\t\t\t$el.parentNode.removeChild($el);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst className = list[i].className;\n\t\t\tconst style = list[i].style;\n\n\t\t\t$el[className ? \"setAttribute\" : \"removeAttribute\"](\"class\", className);\n\t\t\t$el[style ? \"setAttribute\" : \"removeAttribute\"](\"style\", style);\n\t\t}\n\n\t\t// unbind events\n\t\tthis._bindEvents(false);\n\t\tthis.off();\n\n\t\t// release resources\n\t\tfor (const x in this) {\n\t\t\tthis[x] = null;\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Flicking.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n// internal config values\nconst CONFIG = {\n\tpanel: {\n\t\t$list: null,\t    // panel list\n\t\tindex: 0,\t\t\t// dom index used among process\n\t\tno: 0,\t\t\t\t// panel no used among process\n\t\tcurrIndex: 0,       // current physical dom index\n\t\tcurrNo: 0,          // current logical panel number\n\t\tsize: 0,\t\t\t// panel size\n\t\tcount: 0,\t\t\t// total physical panel count\n\t\torigCount: 0,\t\t// total count of given original panels\n\t\tchanged: false,\t\t// if panel changed\n\t\tanimating: false,\t// current animating status boolean\n\t\tminCount: 3         // minimum panel count\n\t},\n\ttouch: {\n\t\tholdPos: [0, 0],    // hold x,y coordinate\n\t\tdestPos: [0, 0],\t// destination x,y coordinate\n\t\tdistance: 0,\t\t// touch distance pixel of start to end touch\n\t\tdirection: null,\t// touch direction\n\t\tlastPos: 0,\t\t\t// to determine move on holding\n\t\tholding: false\n\t},\n\tcustomEvent: {          // for custom events value\n\t\tflick: true,\n\t\trestore: false,\n\t\trestoreCall: false\n\t},\n\tdirData: [],\t\t\t// direction constant value according horizontal or vertical\n\tindexToMove: 0,\n\t$dummyAnchor: null      // For buggy link highlighting on Android 2.x\n};\n\n\n// default options\nconst OPTIONS = {\n\thwAccelerable: true,    // ns.isHWAccelerable(),  // check weather hw acceleration is available\n\tprefix: \"eg-flick\",     // prefix value of class name\n\tdeceleration: 0.0006,   // deceleration value\n\thorizontal: true,       // move direction (true == horizontal, false == vertical)\n\tcircular: false,        // circular mode. In this mode at least 3 panels are required.\n\tpreviewPadding: null,   // preview padding value in left(up) to right(down) order. In this mode at least 5 panels are required.\n\tbounce: null,           // bounce value in left(up) to right(down) order. Works only in non-circular mode.\n\tthreshold: 40,          // the distance pixel threshold value for change panel\n\tduration: 100,          // duration ms for animation\n\tpanelEffect: x => 1 - Math.pow(1 - x, 3),  // easing function for panel change animation\n\tdefaultIndex: 0,        // initial panel index to be shown\n\tinputType: [            // input type\n\t\t\"touch\", \"mouse\"\n\t],\n\tthresholdAngle: 45,     // the threshold value that determines whether user action is horizontal or vertical (0~90)\n\tadaptiveHeight: false   // Set container's height be adaptive according panel's height\n};\n\nexport {\n\tCONFIG,\n\tOPTIONS\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/config.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport * as consts from \"./consts\";\n\nexport default superclass => class extends superclass {\n\n\t/**\n\t * 'hold' event handler\n\t */\n\t_holdHandler(e) {\n\t\tconst conf = this._conf;\n\n\t\tconf.touch.holdPos = e.pos;\n\t\tconf.touch.holding = true;\n\t\tconf.panel.changed = false;\n\n\t\tthis._adjustContainerCss(\"start\", e.pos);\n\t}\n\n\t/**\n\t * 'change' event handler\n\t */\n\t_changeHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\t\tconst posIndex = +!this.options.horizontal;\n\t\tconst pos = e.pos[posIndex];\n\t\tconst holdPos = touch.holdPos[posIndex];\n\t\tlet direction;\n\t\tlet eventRes = null;\n\t\tlet movedPx;\n\n\t\tthis._setPointerEvents(e);  // for \"click\" bug\n\n\t\t/**\n\t\t * This event is fired when panel moves.\n\t\t * @ko 패널이 이동할 때 발생하는 이벤트\n\t\t * @name eg.Flicking#flick\n\t\t * @event\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {String} param.eventType The name of the event<ko>이름명</ko>\n\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t * @param {Array} param.pos Start coordinate <ko>출발점 좌표</ko>\n\t\t * @param {Number} param.pos.0 x-coordinate <ko>x 좌표</ko>\n\t\t * @param {Number} param.pos.1 y-coordinate <ko>y 좌표</ko>\n\t\t * @param {Boolean} param.holding Indicates whether a user holds an element on the screen of the device. <ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>\n\t\t * @param {Number} param.distance Distance moved from then starting point. According the move direction, positive on eg.MovableCoord.DIRECTION_LEFT/UP and negative on eg.MovableCoord.DIRECTION_RIGHT/DOWN <ko>시작점부터 이동된 거리의 값. 이동 방향에 따라 eg.MovableCoord.DIRECTION_LEFT/UP의 경우 양수를 eg.MovableCoord.DIRECTION_RIGHT/DOWN의 경우는 음수를 반환</ko>\n\t\t */\n\t\tif (e.hammerEvent) {\n\t\t\tdirection = e.hammerEvent.direction;\n\n\t\t\t// Adjust direction in case of diagonal touch move\n\t\t\tmovedPx = e.hammerEvent[this.options.horizontal ? \"deltaX\" : \"deltaY\"];\n\n\t\t\tif (!~conf.dirData.indexOf(direction)) {\n\t\t\t\tdirection = conf.dirData[+(Math.abs(touch.lastPos) <= movedPx)];\n\t\t\t}\n\n\t\t\ttouch.lastPos = movedPx;\n\t\t} else {\n\t\t\ttouch.lastPos = null;\n\t\t}\n\n\t\tconf.customEvent.flick && (eventRes =\n\t\t\tthis._triggerEvent(consts.EVENTS.flick, {\n\t\t\t\tpos: e.pos,\n\t\t\t\tholding: e.holding,\n\t\t\t\tdirection: direction || touch.direction,\n\t\t\t\tdistance: pos - (holdPos || (touch.holdPos[posIndex] = pos))\n\t\t\t}\n\t\t));\n\n\t\t(eventRes || eventRes === null) && this._setTranslate([-pos, 0]);\n\t}\n\n\t/**\n\t * 'release' event handler\n\t */\n\t_releaseHandler(e) {\n\t\tconst touch = this._conf.touch;\n\t\tconst pos = e.destPos;\n\t\tconst posIndex = +!this.options.horizontal;\n\t\tconst holdPos = touch.holdPos[posIndex];\n\t\tconst panelSize = this._conf.panel.size;\n\n\t\ttouch.distance = e.depaPos[posIndex] - touch.holdPos[posIndex];\n\n\t\ttouch.direction = this._conf.dirData[\n\t\t\t+!(touch.holdPos[posIndex] < e.depaPos[posIndex])\n\t\t];\n\n\t\tpos[posIndex] = Math.max(\n\t\t\tholdPos - panelSize, Math.min(holdPos, pos[posIndex])\n\t\t);\n\n\t\ttouch.destPos[posIndex] =\n\t\t\tpos[posIndex] = Math.round(pos[posIndex] / panelSize) * panelSize;\n\n\t\ttouch.distance === 0 && this._adjustContainerCss(\"end\");\n\t\ttouch.holding = false;\n\n\t\tthis._setPointerEvents();  // for \"click\" bug\n\t}\n\n\t/**\n\t * 'animationStart' event handler\n\t */\n\t_animationStartHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst customEvent = conf.customEvent;\n\n\t\tpanel.animating = true;\n\n\t\tif (!customEvent.restoreCall && e.hammerEvent &&\n\t\t\tthis._setPhaseValue(\"start\", {\n\t\t\t\tdepaPos: e.depaPos,\n\t\t\t\tdestPos: e.destPos\n\t\t\t}) === false) {\n\t\t\te.stop();\n\t\t}\n\n\t\tif (e.hammerEvent) {\n\t\t\te.duration = this.options.duration;\n\n\t\t\te.destPos[+!this.options.horizontal] =\n\t\t\t\tpanel.size * (\n\t\t\t\t\tpanel.index + conf.indexToMove\n\t\t\t\t);\n\t\t}\n\n\t\tif (this._isMovable()) {\n\t\t\t!customEvent.restoreCall && (customEvent.restore = false);\n\t\t} else {\n\t\t\tthis._triggerBeforeRestore(e);\n\t\t}\n\t}\n\n\t/**\n\t * 'animationEnd' event handler\n\t */\n\t_animationEndHandler() {\n\t\tthis._setPhaseValue(\"end\");\n\n\t\tthis._conf.panel.animating = false;\n\t\tthis._triggerRestore();\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/eventHandler.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"./Flicking\";\n\nFlicking.VERSION = \"2.0.0-rc.3\";\nmodule.exports = Flicking;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport {window, document} from \"./browser\";\n\nconst utils = {\n\t/**\n\t * Select or create element\n\t * @param {String|HTMLElement} param\n\t *  when string given is as HTML tag, then create element\n\t *  otherwise it returns selected elements\n\t * @returns {HTMLElement}\n\t */\n\t$(param) {\n\t\tlet el = null;\n\n\t\tif (typeof param === \"string\") {\n\t\t\t// check if string is HTML tag format\n\t\t\tconst match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n\t\t\t// creating element\n\t\t\tif (match) {\n\t\t\t\tel = document.createElement(match[1]);\n\n\t\t\t\t// attributes\n\t\t\t\tmatch.length === 3 &&\n\t\t\t\t\tmatch[2].split(\" \").forEach(v => {\n\t\t\t\t\t\tconst attr = v.split(\"=\");\n\n\t\t\t\t\t\tel.setAttribute(attr[0], attr[1].trim().replace(/(^[\"']|[\"']$)/g, \"\"));\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel = document.querySelectorAll(param);\n\n\t\t\t\tif (!el.length) {\n\t\t\t\t\tel = null;\n\t\t\t\t} else if (el.length === 1) {\n\t\t\t\t\tel = el[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (param.nodeName && param.nodeType === 1) {\n\t\t\tel = param;\n\t\t}\n\n\t\treturn el;\n\t},\n\n\t/**\n\t * Check if is array\n\t * @param arr\n\t * @returns {Boolean}\n\t */\n\tisArray(arr) {\n\t\treturn arr && arr.constructor === Array;\n\t},\n\n\t/**\n\t * Check if is object\n\t * @param {Object} obj\n\t * @returns {Boolean}\n\t */\n\tisObject(obj) {\n\t\treturn obj && !obj.nodeType && typeof obj === \"object\" && !this.isArray(obj);\n\t},\n\n\t/**\n\t * Merge object returning new object\n\t * @param {Object} target\n\t * @param {Object} objectN\n\t * @returns {Object} merged target object\n\t * @example\n\t *  var target = { a: 1 };\n\t *  utils.extend(target, { b: 2, c: 3 });\n\t *  target;  // { a: 1, b: 2, c: 3 };\n\t */\n\textend(target, ...objectN) {\n\t\tif (!objectN.length || (objectN.length === 1 && !objectN[0])) {\n\t\t\treturn target;\n\t\t}\n\n\t\tconst source = objectN.shift();\n\n\t\tif (this.isObject(target) && this.isObject(source)) {\n\t\t\tObject.keys(source).forEach(key => {\n\t\t\t\tconst value = source[key];\n\n\t\t\t\tif (this.isObject(value)) {\n\t\t\t\t\t!target[key] && (target[key] = {});\n\n\t\t\t\t\ttarget[key] = this.extend(target[key], value);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = this.isArray(value) ?\n\t\t\t\t\t\tvalue.concat() : value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this.extend(target, ...objectN);\n\t},\n\n\t/**\n\t * Get or set the style value or apply\n\t * @param {HTMLElement} el\n\t * @param {String|Object} style\n\t *  String: return style property value\n\t *  Object: set style value\n\t * @parma {Boolean} getAsNumber - get the value as number\n\t * @returns {String|HTMLElement}\n\t */\n\tcss(el, style, getAsNumber) {\n\t\tif (typeof(style) === \"string\") {\n\t\t\tconst value = window.getComputedStyle(el)[style];\n\n\t\t\treturn getAsNumber ? this.getNumValue(value) : value;\n\t\t} else {\n\t\t\tconst applyStyle = (target, source) =>\n\t\t\t\tObject.keys(source).forEach(v => {\n\t\t\t\t\ttarget[v] = source[v];\n\t\t\t\t});\n\n\t\t\tthis.isArray(el) ?\n\t\t\t\tel.forEach(v => applyStyle(v.style, style)) :\n\t\t\t\tapplyStyle(el.style, style);\n\t\t}\n\n\t\treturn el;\n\t},\n\n\t/**\n\t * Check and parse value to number\n\t * @param {Number|String} val\n\t * @param {Number} defVal\n\t * @return {Number}\n\t */\n\tgetNumValue(val, defVal) {\n\t\tlet num = val;\n\n\t\treturn isNaN(num = parseInt(num, 10)) ? defVal : num;\n\t},\n\n\t/**\n\t * Return unit formatted value\n\t * @param {Number|String} val\n\t * @return {String} val Value formatted with unit\n\t */\n\tgetUnitValue(val) {\n\t\tconst rx = /(?:[a-z]{2,}|%)$/;\n\n\t\treturn (parseInt(val, 10) || 0) + (String(val).match(rx) || \"px\");\n\t},\n\n\t/**\n\t * Get element's outer value\n\t * @param {HTMLElement} el\n\t * @param {String} type - [outerWidth|outerHeight]\n\t * @returns {Number} outer's value\n\t */\n\tgetOuter(el, type) {\n\t\tconst style = window.getComputedStyle(el);\n\t\tconst margin = type === \"outerWidth\" ?\n\t\t\t[\"marginLeft\", \"marginRight\"] : [\"marginTop\", \"marginBottom\"];\n\n\t\treturn this.getNumValue(style[type.replace(\"outer\", \"\").toLocaleLowerCase()]) +\n\t\t\tthis.getNumValue(style[margin[0]]) +\n\t\t\tthis.getNumValue(style[margin[1]]);\n\t},\n\n\t/**\n\t * Get element's outerWidth value with margin\n\t * @param {HTMLElement} el\n\t * @returns {Number}\n\t */\n\touterWidth(el) {\n\t\treturn this.getOuter(el, \"outerWidth\");\n\t},\n\n\t/**\n\t * Get element's outerHeight value with margin\n\t * @param {HTMLElement} el\n\t * @returns {Number}\n\t */\n\touterHeight(el) {\n\t\treturn this.getOuter(el, \"outerHeight\");\n\t},\n\n\t/**\n\t * Checks whether hardware acceleration is enabled.\n\t *\n\t * @ko 하드웨어 가속을 사용할 수 있는 환경인지 확인한다\n\t * @method eg#isHWAccelerable\n\t * @return {Boolean} Indicates whether hardware acceleration is enabled. <ko>하드웨어 가속 사용 가능 여부</ko>\n\t */\n\tisHWAccelerable() {\n\t\tconst ua = window.navigator.userAgent;\n\t\tlet result = false;\n\t\tlet match;\n\n\t\t// chrome 25- has a text blur bug (except Samsung's sbrowser)\n\t\tif ((match = ua.match(/Chrome\\/(\\d+)/))) {\n\t\t\tresult = match[1] >= \"25\";\n\t\t} else if (/ie|edge|firefox|safari|inapp/.test(ua)) {\n\t\t\tresult = true;\n\t\t} else if ((match = ua.match(/Android ([\\d.]+)/))) {\n\t\t\tconst version = match[1];\n\t\t\tconst useragent = (ua.match(/\\(.*\\)/) || [null])[0];\n\n\t\t\t// android 4.1+ blacklist\n\t\t\t// EK-GN120 : Galaxy Camera, SM-G386F : Galaxy Core LTE\n\t\t\t// SHW-M420 : Galaxy Nexus , SHW-M200 : NexusS , GT-S7562 : Galaxy S duos\n\t\t\tresult = (version >= \"4.1.0\" && !/EK-GN120|SM-G386F/.test(useragent)) ||\n\t\t\t\t(\n\t\t\t\t\tversion >= \"4.0.3\" &&\n\t\t\t\t\t/SHW-|SHV-|GT-|SCH-|SGH-|SPH-|LG-F160|LG-F100|LG-F180|LG-F200|EK-|IM-A|LG-F240|LG-F260/.test(useragent) &&\n\t\t\t\t\t!/SHW-M420|SHW-M200|GT-S7562/.test(useragent)\n\t\t\t\t);\n\t\t}\n\n\t\tthis.isHWAccelerable = () => result;\n\t\treturn result;\n\t},\n\n\t/**\n\t * Returns the syntax of the translate style which is applied to CSS transition properties.\n\t *\n\t * @ko CSS 트랜지션 속성에 적용할 translate 스타일 구문을 반환한다\n\t * @method eg#translate\n\t * @param {String} x Distance to move along the X axis <ko>x축을 따라 이동할 거리</ko>\n\t * @param {String} y Distance to move along the Y axis <ko>y축을 따라 이동할 거리</ko>\n\t * @param {Boolean} [isHA] Force hardware acceleration <ko>하드웨어 가속 사용 여부</ko>\n\t * @return {String} Syntax of the translate style <ko>translate 스타일 구문</ko>\n\t */\n\ttranslate(x, y, isHA) {\n\t\treturn isHA || false ?\n\t\t\t`translate3d(${x},${y},0)` : `translate(${x},${y})`;\n\t},\n\n\t// 1. user press one position on screen.\n\t// 2. user moves to the other position on screen.\n\t// 3. when user releases fingers on screen, 'click' event is fired at previous position.\n\thasClickBug() {\n\t\tconst ua = window.navigator.userAgent;\n\t\tconst result = /Safari/.test(ua);\n\n\t\tthis.hasClickBug = () => result;\n\t\treturn result;\n\t}\n};\n\nclass MixinBuilder {\n\tconstructor(superclass) {\n\t\tthis.superclass = superclass || class {};\n\t}\n\n\twith(...mixins) {\n\t\treturn mixins.reduce((c, m) => m(c), this.superclass);\n\t}\n}\n\nconst Mixin = superclass => new MixinBuilder(superclass);\n\nexport {utils, Mixin};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}\n// module id = 7\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@egjs/movablecoord\",\"commonjs2\":\"@egjs/movablecoord\",\"amd\":\"@egjs/movablecoord\",\"root\":[\"eg\",\"MovableCoord\"]}\n// module id = 8\n// module chunks = 0 1"],"sourceRoot":""}