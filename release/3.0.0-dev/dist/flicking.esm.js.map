{"version":3,"file":"flicking.esm.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/Viewport.ts","../src/Flicking.ts"],"sourcesContent":["export function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\n\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val < max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n","import { FlickingState, FlickingOptions, EventType, Direction, MovingState } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0006,\n  horizontal: true,\n  circular: false,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n};\n\nexport const MOVING_STATE: MovingState = {\n  IDLE: \"IDLE\",\n  HOLDING: \"HOLDING\",\n  DRAGGING: \"DRAGGING\",\n  MOVING: \"MOVING\",\n  DISABLED: \"DISABLED\",\n};\n\nexport const DEFAULT_STATE: Readonly<FlickingState> = {\n  options: DEFAULT_OPTIONS,\n  currentPanelIndex: DEFAULT_OPTIONS.defaultIndex,\n  movingDirection: undefined,\n  movingState: MOVING_STATE.IDLE,\n  moveStartTriggered: false,\n  lastHoldingDelta: 0,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","import { OriginalStyle, FlickingPanel, ChangeEvent } from \"../types\";\nimport { DEFAULT_PANEL_CSS, EVENTS, DIRECTION } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression, merge } from \"../utils\";\nimport Viewport from \"./Viewport\";\n\nclass Panel {\n  private prevPanel: Panel | null;\n  private nextPanel: Panel | null;\n\n  private viewport: Viewport;\n  private element: HTMLElement;\n  private state: {\n    index: number;\n    horizontal: boolean,\n    position: number;\n    anchorExpression: string;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    originalStyle: OriginalStyle;\n    clonedPanels: Panel[];\n    cachedBbox: ClientRect | null;\n  };\n  private original?: Panel;\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    viewport: Viewport,\n    options: {\n      horizontal: boolean,\n      anchorExpression: string,\n      classPrefix?: string,\n    },\n  ) {\n    this.element = element;\n    this.viewport = viewport;\n\n    this.state = {\n      index,\n      horizontal: options.horizontal,\n      position: 0,\n      anchorExpression: options.anchorExpression,\n      relativeAnchorPosition: 0,\n      size: 0,\n      clonedPanels: [],\n      isClone: false,\n      originalStyle: {\n        className: element.getAttribute(\"class\") || null,\n        style: element.getAttribute(\"style\") || null,\n      },\n      cachedBbox: null,\n    };\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n    this.resize();\n  }\n\n  public update(updateFunction: (element: HTMLElement) => any): void {\n    const state = this.state;\n    // Call original's update function if current panel is cloned one\n    if (state.isClone) {\n      this.original!.update(updateFunction);\n      return;\n    }\n\n    // Call update function for all elements including cloned ones\n    [this.element, ...state.clonedPanels.map(panel => panel.element)].forEach(updateFunction);\n  }\n\n  public resize(): void {\n    const state = this.state;\n\n    // Removed cached bbox, as we're resizing\n    state.cachedBbox = null;\n\n    const bbox = this.getBbox();\n\n    state.size = state.horizontal\n      ? bbox.width\n      : bbox.height;\n  }\n\n  public destroy(): void {\n    const el = this.element;\n    const originalStyle = this.state.originalStyle;\n\n    originalStyle.className\n      ? el.setAttribute(\"class\", originalStyle.className)\n      : el.removeAttribute(\"class\");\n    originalStyle.style\n      ? el.setAttribute(\"style\", originalStyle.style)\n      : el.removeAttribute(\"style\");\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getPrevPanel(): Panel | null {\n    return this.prevPanel;\n  }\n\n  public getNextPanel(): Panel | null {\n    return this.nextPanel;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...state.clonedPanels];\n  }\n\n  public setPosition(pos: number) {\n    const state = this.state;\n    const elementStyle = this.element.style;\n\n    state.position = pos;\n    state.horizontal\n      ? elementStyle.left = `${pos}px`\n      : elementStyle.top = `${pos}px`;\n    state.relativeAnchorPosition = parseArithmeticExpression(state.anchorExpression, state.size);\n  }\n\n  public setPrevPanel(panel: Panel | null): void {\n    this.prevPanel = panel;\n  }\n\n  public setNextPanel(panel: Panel | null): void {\n    this.nextPanel = panel;\n  }\n\n  public clone(): Panel {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const cloneElement = this.element.cloneNode(true) as HTMLElement;\n    const clonedPanel = new Panel(cloneElement, state.index, viewport, {\n      anchorExpression: state.anchorExpression,\n      horizontal: state.horizontal,\n    });\n\n    clonedPanel.original = this;\n    clonedPanel.state.isClone = true;\n    // Can't calc size as it didn't appended to other element yet\n    // So manually set size for it\n    clonedPanel.state.size = state.size;\n\n    viewport.appendPanelElement(cloneElement);\n    state.clonedPanels.push(clonedPanel);\n\n    return clonedPanel;\n  }\n\n  public toReadonlyVersion(): FlickingPanel {\n    const state = this.state;\n    const originalPanel = this;\n\n    return {\n      element: this.element,\n      index: state.index,\n      position: state.position,\n      anchorPosition: state.position + state.relativeAnchorPosition,\n      size: state.size,\n      focus(this: FlickingPanel, duration?: number): void {\n        const viewport = originalPanel.viewport;\n        const flicking = viewport.flicking;\n\n        const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n        const anchorPosition = state.position + state.relativeAnchorPosition;\n        if (hangerPosition === anchorPosition) {\n          return;\n        }\n\n        const direction = hangerPosition > anchorPosition\n          ? DIRECTION.PREV\n          : DIRECTION.NEXT;\n\n        const changeCanceled = flicking.trigger(EVENTS.CHANGE, {\n          index: this.index,\n          panel: this,\n          direction,\n          prevIndex: viewport.getIndex(),\n          prevPanel: viewport.getCurrentPanel().toReadonlyVersion(),\n          isTrusted: false,\n        } as ChangeEvent);\n\n        if (changeCanceled) {\n          return;\n        }\n\n        originalPanel.viewport.moveTo(this, null, duration);\n\n        if (duration != null && duration <= 0) {\n          flicking.trigger(EVENTS.MOVE_END, {\n            direction,\n            isTrusted: false,\n          });\n        }\n      },\n      update: this.update.bind(this),\n      prev(this: FlickingPanel): FlickingPanel | null {\n        const originalPrevPanel = originalPanel.prevPanel;\n        if (originalPrevPanel == null) {\n          return null;\n        }\n\n        const prevPanel = originalPrevPanel.toReadonlyVersion();\n\n        if (this.position < prevPanel.position) {\n          let newPosition = prevPanel.position;\n          const scrollArea = originalPanel.viewport.getScrollArea();\n          const scrollAreaSize = scrollArea.next - scrollArea.prev;\n\n          do {\n            newPosition -= scrollAreaSize;\n          } while (this.position < newPosition);\n\n          return merge({}, prevPanel, {\n            position: newPosition,\n            anchorPosition: newPosition + originalPrevPanel.state.relativeAnchorPosition,\n          }) as FlickingPanel;\n        }\n\n        return prevPanel;\n      },\n      next(this: FlickingPanel): FlickingPanel | null {\n        const originalNextPanel = originalPanel.nextPanel;\n        if (originalNextPanel == null) {\n          return null;\n        }\n\n        const nextPanel = originalNextPanel.toReadonlyVersion();\n\n        if (this.position > nextPanel.position) {\n          let newPosition = nextPanel.position;\n          const scrollArea = originalPanel.viewport.getScrollArea();\n          const scrollAreaSize = scrollArea.next - scrollArea.prev;\n\n          do {\n            newPosition += scrollAreaSize;\n          } while (this.position > newPosition);\n\n          return merge({}, nextPanel, {\n            position: newPosition,\n            anchorPosition: newPosition + originalNextPanel.state.relativeAnchorPosition,\n          }) as FlickingPanel;\n        }\n\n        return nextPanel;\n      },\n    };\n  }\n}\n\nexport default Panel;\n","import Panel from \"./Panel\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray } from \"../utils\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS } from \"../consts\";\nimport Axes, { PanInput } from \"@egjs/axes\";\nimport { FlickingOptions, FlickingPanel } from \"../types\";\nimport Flicking from \"../Flicking\";\n\nexport default class Viewport {\n  public flicking: Flicking;\n\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private panels: Panel[];\n  private clonedPanels: Panel[];\n\n  private state: {\n    index: number;\n    size: number;\n    position: number;\n    hangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    options: FlickingOptions;\n  };\n\n  constructor(\n    viewportElement: HTMLElement,\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n\n    this.state = {\n      index: options.defaultIndex,\n      size: -1,\n      position: 0,\n      hangerPosition: 0,\n      scrollArea: {\n        prev: -1,\n        next: -1,\n      },\n      translate: TRANSFORM,\n      options,\n    };\n\n    this.build();\n  }\n\n  public moveTo(panel: FlickingPanel, axesEvent: any, duration: number = this.state.options.duration): void {\n    const state = this.state;\n    let targetPos = panel.anchorPosition - state.hangerPosition;\n\n    targetPos = this.canSetBoundMode()\n      ? clamp(targetPos, state.scrollArea.prev, state.scrollArea.next)\n      : targetPos;\n\n    state.index = panel.index;\n    axesEvent\n      ? axesEvent.setTo({ flick: targetPos }, duration)\n      : this.axes.setTo({ flick: targetPos }, duration);\n  }\n\n  public moveCamera(pos: number): void {\n    const state = this.state;\n    pos = Math.round(pos);\n\n    const transform = state.translate.name;\n    const moveVector = state.options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${coord}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n\n    // Update position\n    state.position = pos;\n  }\n\n  public resize(): void {\n    const bbox = this.viewportElement.getBoundingClientRect();\n    const state = this.state;\n    const options = state.options;\n    const panels = this.panels;\n\n    panels.forEach(panel => panel.resize());\n\n    this.adjustSize();\n\n    state.size = state.options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.hangerPosition = parseArithmeticExpression(options.hanger, state.size);\n\n    // Set viewport scrollable area\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const hangerPos = state.hangerPosition;\n\n    // TODO: Consider circular case\n    if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - hangerPos,\n        next: lastPanel.getAnchorPosition() - hangerPos,\n      };\n    }\n  }\n\n  // Find nearest anchor from current hanger position\n  // FIXME: exclude \"undefined\"\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n    const currentHangerPosition = state.position + state.hangerPosition;\n\n    if (this.isOutOfBound()) {\n      return state.position < scrollArea.prev\n        ? this.panels[0]\n        : this.panels[this.panels.length - 1];\n    }\n\n    for (const panel of [...this.panels, ...this.clonedPanels]) {\n      const panelPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n\n      // TODO: apply \"gap\" option\n      if (isBetween(currentHangerPosition, panelPosition, panelPosition + panelSize)) {\n        return panel;\n      }\n    }\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    for (const panel of [...this.panels, ...this.clonedPanels]) {\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    const state = this.state;\n\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = state.position + state.hangerPosition;\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = state.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const distance = Math.abs(state.position + state.hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.hangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.hangerPosition\n        : anchorPosition > state.position + state.hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.hangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.hangerPosition + scrollAreaSize;\n    }\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public adjustSize(): void {\n    const options = this.state.options;\n    const horizontal = options.horizontal;\n    let sizeToApply: number;\n\n    if (options.adaptive) {\n      const currentPanel = this.getCurrentPanel();\n      const bbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? bbox.height : bbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panels.reduce((maximum, panel) => {\n        const bbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? bbox.height : bbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const viewportElement = this.viewportElement;\n    const wrapper = viewportElement.parentElement;\n\n    wrapper!.removeChild(viewportElement);\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    this.panels.forEach(panel => {\n      wrapper!.appendChild(panel.getElement());\n      panel.destroy();\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getPanelCount(): number {\n    return this.panels.length;\n  }\n\n  public getPanel(index: number): Panel | null {\n    if (!isBetween(index, 0, this.panels.length)) {\n      return null;\n    }\n\n    return this.panels[index];\n  }\n\n  public getCurrentPanel(): Panel {\n    return this.panels[this.state.index];\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPrevIndex(): number {\n    const state = this.state;\n    let index = state.index - 1;\n\n    if (index < 0) {\n      index = state.options.circular\n        ? this.panels.length - 1\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getNextIndex(): number {\n    const state = this.state;\n    let index = state.index + 1;\n\n    if (index >= this.panels.length) {\n      index = state.options.circular\n        ? 0\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.hangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public connectAxesHandler(handler: {[key: string]: (event: { [key: string]: any; }) => any}): Axes {\n    const horizontal = this.state.options.horizontal;\n\n    return this.axes.on(handler)\n      .connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  public appendPanelElement(element: HTMLElement) {\n    this.cameraElement.appendChild(element);\n  }\n\n  private build(): void {\n    this.applyCSSValue();\n    this.placePanels();\n    this.resize();\n\n    // Clone panels in circular mode\n    if (this.state.options.circular) {\n      this.clonePanels();\n      this.replacePanels();\n    }\n\n    this.chainPanels();\n    this.setAxesInstance();\n    this.moveToDefaultPanel();\n  }\n\n  private applyCSSValue(): void {\n    const state = this.state;\n    const options = state.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const classPrefix = options.classPrefix;\n\n    // Set default css values for each element\n    viewportElement.className = `${classPrefix}-viewport`;\n    cameraElement.className = `${classPrefix}-camera`;\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private placePanels(): void {\n    const options = this.state.options;\n\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n    if (!panelElements || !panelElements.length) {\n      throw new Error(\"There're no panel elements.\");\n    }\n\n    // Initialize panels\n    this.panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this, {\n        horizontal: options.horizontal,\n        classPrefix: options.classPrefix,\n        anchorExpression: options.anchor,\n      }),\n    );\n    this.clonedPanels = [];\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = 0;\n    this.panels.forEach(panel => {\n      const panelPos = nextPanelPos;\n      const panelSize = panel.getSize();\n\n      panel.setPosition(panelPos);\n      nextPanelPos += panelSize;\n    });\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n\n    const viewportSize = state.size;\n    const lastPanel = panels[panels.length - 1];\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    // Update viewport scrollable area\n    // Maximum scroll extends to first clone sequence's first panel\n    state.scrollArea = {\n      prev: state.scrollArea.prev,\n      next: sumOriginalPanelSize + panels[0].getRelativeAnchorPosition() - state.hangerPosition,\n    };\n\n    const scrollArea = state.scrollArea;\n    const visibleAreaSize = (scrollArea.next + viewportSize) - scrollArea.prev;\n\n    // For each panels, clone itself while panel's last position is below viewport size\n    let totalPanelSize = sumOriginalPanelSize;\n    do {\n      const cloneBasePos = totalPanelSize;\n\n      // Iterate original panels, clone or set toggle position\n      panels.forEach(origPanel => {\n        const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n        // Clone panels\n        const clonedPanel = origPanel.clone();\n        clonedPanel.setPosition(clonedPanelPos);\n\n        clonedPanels.push(clonedPanel);\n      });\n\n      // Update base position to clone\n      totalPanelSize += sumOriginalPanelSize;\n    } while (totalPanelSize <= visibleAreaSize);\n  }\n\n  private replacePanels(): void {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n    const scrollArea = state.scrollArea;\n    const maximumVisiblePosition = scrollArea.next + state.size;\n\n    let lastReplacePosition = panels[0].getPosition();\n    // reverse() pollutes original array\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelPosition = panel.getPosition();\n      const replacePosition = lastReplacePosition - panel.getSize();\n\n      if (panelPosition <= maximumVisiblePosition) {\n        // It's visible in current scrollArea\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private chainPanels(): void {\n    const allPanels = [...this.panels, ...this.clonedPanels];\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanels.length - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.setPrevPanel(prevPanel);\n      panel.setNextPanel(nextPanel);\n    });\n\n    if (this.state.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanels.length - 1];\n\n      firstPanel.setPrevPanel(lastPanel);\n      lastPanel.setNextPanel(firstPanel);\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = state.options;\n\n    const scrollArea = state.scrollArea;\n    const viewportSize = state.size;\n    const horizontal = options.horizontal;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: parsedBounce,\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: horizontal ? [-1, 0] : [0, -1],\n    });\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n\n    const defaultIndex = clamp(state.options.defaultIndex, 0, this.panels.length -  1);\n    const defaultPanel = this.panels[defaultIndex];\n    const defaultPosition = this.findShortestPositionToPanel(defaultPanel);\n\n    state.index = defaultIndex;\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private isOutOfBound(): boolean {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n\n    return !state.options.circular\n      && (state.position < scrollArea.prev || state.position > scrollArea.next);\n  }\n\n  private canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = state.options;\n    const panels = this.panels;\n\n    const lastPanel = panels[panels.length - 1];\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n}\n","import Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\n\nimport { merge, clamp } from \"./utils\";\nimport { DEFAULT_STATE, DEFAULT_OPTIONS, EVENTS, DIRECTION, MOVING_STATE } from \"./consts\";\nimport { FlickingOptions, FlickingState, FlickingEvent, Direction, EventType, SelectEvent, ChangeEvent, FlickingPanel } from \"./types\";\nimport Panel from \"./components/Panel\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"9+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n * @throws {Error} An Error occur when given base element doesn't exist or it hasn't proper DOM structure to be initialized. <ko>주어진 기본 요소가 존재하지 않거나 초기화 할 적절한 DOM 구조가없는 경우 오류가 발생한다.</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event types\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  private state: FlickingState;\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix for class names of the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0006] Deceleration value for panel movement animation where acceleration is manually enabled by user. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for infinite scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되여 무한 스크롤이 가능하다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to destination panel(unit: pixel). A panel element must be dragged beyond the threshold to move to the destination panel.<ko>목적 패널로의 이동 임계값 (단위: 픽셀). 패널 요소를 임계값 이상으로 끌어다 놓아야만이 목적 패널로 이동한다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] The easing function to apply to a panel moving animation. The default function is easeOutCubic.<ko>패널 이동 애니메이션에 적용할 `easing`함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing the module. A zero-based integer.<ko>모듈 초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput Reference})<br>- \"touch\": A touch input device.<br>- \"mouse\": A mouse.<ko>입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput 참고})<br>- \"touch\": 터치 입력 장치.<br>- \"mouse\": 마우스.</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold value that determines whether user input is horizontal or vertical. (0 ~ 90)<ko>사용자의 입력이 가로 방향인지 세로 방향인지 판단하는 기준 각도 (0 ~ 90)</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {Boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element<ko>뷰포트 요소의 z-index 값</ko>\n   * @param {boolean} [options.bound=false] Prevents view going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Position of hanger in viewport, which hangs panel anchors.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   */\n  constructor(\n    element: HTMLElement | string,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (typeof element === \"string\") {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n\n    this.build(options);\n  }\n  /**\n   * Move to the previous panel. If `horizontal=true`is left panel. If `horizontal=false`is upper panel.\n   * @ko 이전 패널로 이동한다. `horizontal=true`이면 좌측 패널. `horizontal=false`이면 상측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public prev(duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel().getPrevPanel();\n\n    if (panel) {\n      this.moveToPanelProgramatic(panel, duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the next panel. If `horizontal=true`is right panel. If `horizontal=false`is lower panel.\n   * @ko 다음 패널로 이동한다. `horizontal=true`이면 우측 패널. `horizontal=false`이면 하측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public next(duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel().getNextPanel();\n\n    if (panel) {\n      this.moveToPanelProgramatic(panel, duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Moves to the panel in the order specified in `index`. If `index` is equal to selected panel's index, no action is taken.\n   * @ko `index`에 지정한 순서의 패널로 이동한다. `index`값이 현재 선택된 패널의 인덱스와 동일하다면, 아무 동작도 하지 않는다.\n   * @param index The index number of the panel to be moved.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getPanel(index);\n\n    if (panel) {\n      this.moveToPanelProgramatic(panel, duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the index number of the selected panel.\n   * @ko 현재 선택된 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the current panel element.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getIndex();\n  }\n\n  /**\n   * Returns the index number of the previous panel.\n   * @ko 현재 선택된 패널의 이전 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the previous panel.<br>When `circular` option is `false`, return -1 if selected panel is first panel.<ko>이전 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 첫번째 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getPrevIndex(): number {\n    return this.viewport.getPrevIndex();\n  }\n\n  /**\n   * Returns the index number of the next panel.\n   * @ko 현재 선택된 패널의 다음 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the next panel.<br>When `circular` option is `false`, return -1 if selected panel is last panel.<ko>다음 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 마지막 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getNextIndex(): number {\n    return this.viewport.getNextIndex();\n  }\n\n  /**\n   * Returns the selected panel instance\n   * @ko 현재 선택된 패널의 인스턴스를 반환한다.\n   * @return Selected panel instance.<ko>선택된 패널 인스턴스</ko>\n   */\n  public getCurrentPanel(): FlickingPanel {\n    return this.viewport.getCurrentPanel().toReadonlyVersion();\n  }\n\n  /**\n   * Returns the panel instance of given index\n   * @ko 주어진 인덱스에 해당하는 패널의 인스턴스를 반환한다.\n   * @return Panel instance of given index, `null` if it doesn't exists.<ko>주어진 인덱스에 해당하는 패널의 인스턴스, 해당 패널이 존재하지 않을 시 `null`.\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const panel = this.viewport.getPanel(index);\n    return panel\n      ? panel.toReadonlyVersion()\n      : null;\n  }\n\n  /**\n   * Returns the total length of original panels\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.getPanelCount();\n  }\n\n  /**\n   * Checks whether the animated panel is playing.\n   * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n   * @return Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n   */\n  public isPlaying(): boolean {\n    return this.state.movingState !== MOVING_STATE.IDLE;\n  }\n\n  /**\n   * The input from the input device is not blocked so that the panel can be moved by the input device.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return  An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * The input from the input device is blocked so that the panel is not moved by the input device.\n   * @ko 패널이 입력 장치에 의해 움직이지 않도록 입력 장치로부터의 입력을 막는다.\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    //  resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public trigger<T extends FlickingEvent>(\n    eventName: string,\n    params: Partial<T> = {},\n  ) {\n    const state = this.state;\n\n    const holding = state.movingState === MOVING_STATE.HOLDING\n      || state.movingState === MOVING_STATE.DRAGGING;\n\n    const currentPanel = this.viewport.getCurrentPanel();\n\n    if (params.direction) {\n      state.movingDirection = params.direction;\n    }\n\n    // TODO: Refactor this into command pattern\n    if (eventName === EVENTS.MOVE_END) {\n      state.moveStartTriggered = false;\n      if (state.options.adaptive) {\n        this.viewport.adjustSize();\n      }\n    }\n\n    // Return whether it's canceled, as it's more clear\n    return !super.trigger(eventName, merge({\n      type: eventName,\n      index: currentPanel.getIndex(),\n      panel: currentPanel.toReadonlyVersion(),\n      holding,\n    }, params));\n  }\n\n  private build(options: Partial<FlickingOptions>): void {\n    this.setInitialState(options);\n    this.initViewport();\n    this.listenInput();\n  }\n\n  private setInitialState(options: Partial<FlickingOptions>): void {\n    // Set default state values and override it\n    const state = merge({}, DEFAULT_STATE) as FlickingState;\n    // Override default options\n    state.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n\n    this.state = state;\n  }\n\n  private initViewport(): void {\n    const wrapper = this.wrapper;\n    const options = this.state.options;\n    const children = wrapper.children;\n    if (!children || !children.length) {\n      throw new Error(\"Given base element doesn't have proper DOM structure to be initialized.\");\n    }\n\n    const cameraElement = document.createElement(\"div\");\n\n    // Make all panels to be a child of camera element\n    // wrapper <- viewport <- camera <- panels[1...n]\n    let firstChild = wrapper.firstChild;\n    while (firstChild) {\n      cameraElement.appendChild(firstChild);\n      firstChild = wrapper.firstChild;\n    }\n\n    // Clipping area for camera element\n    const viewportElement = document.createElement(\"div\");\n    viewportElement.appendChild(cameraElement);\n\n    // Add viewport element to wrapper\n    wrapper.appendChild(viewportElement);\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(viewportElement, cameraElement, options);\n\n    const viewport = this.viewport;\n    viewport.flicking = this;\n\n    options.defaultIndex = clamp(options.defaultIndex, 0, viewport.getPanelCount() - 1);\n  }\n\n  private listenInput(): void {\n    // Connect Axes instance with PanInput\n    this.viewport.connectAxesHandler({\n      hold: this.onAxesHold.bind(this),\n      change: this.onAxesChange.bind(this),\n      release: this.onAxesRelease.bind(this),\n      animationEnd: this.onAxesAnimationEnd.bind(this),\n      finish: this.onAxesFinish.bind(this),\n    });\n  }\n\n  private stopMoving(): void {\n    const state = this.state;\n\n    state.panelMovingTo = undefined;\n    state.movingState = MOVING_STATE.IDLE;\n    state.movingDirection = undefined;\n    state.lastHoldingDelta = 0;\n  }\n\n  private onAxesHold(e): void {\n    const state = this.state;\n\n    if (state.movingState === MOVING_STATE.DISABLED) {\n      return;\n    }\n\n    const holdStartCanceled = this.trigger(EVENTS.HOLD_START, {\n      axesEvent: e,\n      holding: true,\n      isTrusted: true,\n    });\n\n    if (holdStartCanceled) {\n      state.movingState = MOVING_STATE.DISABLED;\n      return;\n    }\n\n    state.movingState = state.movingState !== MOVING_STATE.MOVING\n      ? MOVING_STATE.HOLDING\n      : MOVING_STATE.DRAGGING;\n    state.movingDirection = undefined;\n    state.lastHoldingDelta = 0;\n  }\n\n  private onAxesChange(e): void {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const pos = e.pos.flick;\n    const delta = !e.inputEvent\n      ? 0\n      : state.options.horizontal\n        ? e.inputEvent.deltaX\n        : e.inputEvent.deltaY;\n\n    if (state.movingState === MOVING_STATE.DISABLED || !e.delta.flick) {\n      return;\n    }\n\n    const currentDirection = delta < state.lastHoldingDelta\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    // On first move event\n    if (!state.moveStartTriggered) {\n      state.moveStartTriggered = true;\n      const moveStartCanceled = this.trigger(EVENTS.MOVE_START, {\n        axesEvent: e,\n        direction: state.movingState === MOVING_STATE.HOLDING\n          ? currentDirection\n          : state.movingDirection,\n        isTrusted: e.isTrusted,\n      });\n\n      if (moveStartCanceled) {\n        this.stopMoving();\n        state.movingState = MOVING_STATE.DISABLED;\n        return;\n      }\n\n      state.movingState = state.movingState === MOVING_STATE.HOLDING\n        ? MOVING_STATE.DRAGGING\n        : state.movingState;\n    }\n\n    if (state.movingState === MOVING_STATE.DRAGGING) {\n      state.movingDirection = currentDirection;\n      state.lastHoldingDelta = delta;\n    }\n\n    const previousPosition = this.viewport.getCameraPosition();\n\n    viewport.moveCamera(pos);\n    const moveCanceled = this.trigger(EVENTS.MOVE, {\n      axesEvent: e,\n      direction: state.movingDirection,\n      isTrusted: e.isTrusted,\n    });\n\n    if (moveCanceled) {\n      viewport.moveCamera(previousPosition);\n      this.stopMoving();\n      state.movingState = MOVING_STATE.DISABLED;\n      return;\n    }\n  }\n\n  private onAxesRelease(e): void {\n    const state = this.state;\n    const options = state.options;\n    const viewport = this.viewport;\n\n    if (state.movingState === MOVING_STATE.DISABLED) {\n      return;\n    }\n\n    const delta = options.horizontal\n      ? e.inputEvent.deltaX\n      : e.inputEvent.deltaY;\n    const isNext = delta < 0;\n    const swipeDistance = Math.abs(delta);\n    const swipeAngle = e.inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(e.inputEvent.deltaY / e.inputEvent.deltaX) / Math.PI)\n      : 90;\n\n    const currentPanel = viewport.getCurrentPanel();\n    const wasDragging = state.movingState === MOVING_STATE.DRAGGING;\n    const overThreshold = (swipeDistance >= options.threshold)\n      && (options.horizontal\n        ? swipeAngle <= options.thresholdAngle\n        : swipeAngle > options.thresholdAngle);\n\n    // Trigger hold end event\n    state.movingState = MOVING_STATE.MOVING;\n    this.trigger(EVENTS.HOLD_END, {\n      axesEvent: e,\n      holding: false,\n      direction: state.movingDirection,\n      isTrusted: true,\n    });\n\n    if (!overThreshold) {\n      if (!wasDragging) {\n        const cameraPosition = viewport.getCameraPosition();\n\n        // Static click\n        const clickedElement = e.inputEvent.srcEvent.target;\n        const clickedPanel = viewport.findPanelOf(clickedElement);\n\n        if (clickedPanel) {\n          const panelPosition = clickedPanel.getPosition();\n          const direction = panelPosition > cameraPosition\n            ? DIRECTION.NEXT\n            : panelPosition < cameraPosition\n              ? DIRECTION.PREV\n              : undefined;\n\n          state.movingState = MOVING_STATE.IDLE;\n          this.trigger(EVENTS.SELECT, {\n            axesEvent: e,\n            direction,\n            isTrusted: true,\n            selectedIndex: clickedPanel.getIndex(),\n            selectedPanel: clickedPanel.toReadonlyVersion(),\n          } as SelectEvent);\n        } else {\n          e.setTo({ flick: cameraPosition }, 0);\n          this.stopMoving();\n        }\n        return;\n      } else if (state.panelMovingTo) {\n        // Update position to move & anchor index\n        this.viewport.moveTo(state.panelMovingTo.toReadonlyVersion(), e);\n        return;\n      }\n    }\n\n    let minimumDistanceToChange = isNext\n      ? currentPanel.getSize() - currentPanel.getRelativeAnchorPosition()\n      : currentPanel.getRelativeAnchorPosition();\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    const hangerPosition = (viewport.getCameraPosition() + viewport.getHangerPosition());\n\n    let panelToMove = currentPanel;\n    if (overThreshold) {\n      // Minimum distance needed to change panel\n      // If over this threshold,\n      /*\n       * | Prev |    Next    |\n       * |------|------------|\n       * [      |<-Anchor    ] <- Panel\n       */\n      if (swipeDistance <= minimumDistanceToChange) {\n        let adjacentPanel = isNext\n          ? currentPanel.getNextPanel()\n          : currentPanel.getPrevPanel();\n\n        if (options.circular) {\n          const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n          const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n            > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n          if (lapped) {\n            adjacentPanel = isNext\n              ? firstClonedPanel.getNextPanel()\n              : firstClonedPanel.getPrevPanel();\n          }\n        }\n\n        panelToMove = (adjacentPanel != null)\n          ? adjacentPanel\n          : currentPanel;\n      } else {\n        panelToMove = viewport.findNearestPanel()!;\n      }\n    } else {\n      // Restore case\n      if (options.circular) {\n        const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n        const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n          > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n        if (!isNext && lapped) {\n          panelToMove = firstClonedPanel;\n        }\n      }\n    }\n\n    let eventType: string = overThreshold\n      ? EVENTS.CHANGE\n      : EVENTS.RESTORE;\n\n    if (overThreshold && !options.circular && panelToMove === currentPanel) {\n      eventType = EVENTS.RESTORE;\n    }\n\n    // Trigger change or restore event\n    const changeOrRestoreCanceled = this.trigger(eventType, {\n      index: panelToMove.getIndex(),\n      panel: panelToMove.toReadonlyVersion(),\n      prevIndex: eventType === EVENTS.CHANGE ? currentPanel.getIndex() : undefined,\n      prevPanel: eventType === EVENTS.CHANGE ? currentPanel.toReadonlyVersion() : undefined,\n      axesEvent: e,\n      direction: state.movingDirection,\n      isTrusted: true,\n    } as ChangeEvent);\n\n    if (changeOrRestoreCanceled) {\n      this.stopMoving();\n      state.movingState = MOVING_STATE.DISABLED;\n      return;\n    }\n\n    // Update position to move & anchor index\n    state.panelMovingTo = panelToMove;\n    this.viewport.moveTo(panelToMove.toReadonlyVersion(), e);\n  }\n\n  private onAxesAnimationEnd(e): void {\n    const state = this.state;\n\n    if (state.movingState === MOVING_STATE.DISABLED) {\n      return;\n    }\n\n    this.trigger(EVENTS.MOVE_END, {\n      axesEvent: e,\n      direction: state.movingDirection,\n      isTrusted: e.isTrusted,\n    });\n  }\n\n  private onAxesFinish(e): void {\n    this.stopMoving();\n  }\n\n  private moveToPanelProgramatic(panel: Panel, duration: number = this.state.options.duration): void {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const currentIndex = viewport.getIndex();\n    const canMove = panel\n      && state.movingState === MOVING_STATE.IDLE\n      && panel.getIndex() !== currentIndex;\n\n    if (!canMove) {\n      return;\n    }\n\n    const estimatedPosition = viewport.findShortestPositionToPanel(panel);\n    const currentPosition = viewport.getCameraPosition();\n\n    const direction = estimatedPosition > currentPosition\n      ? DIRECTION.NEXT\n      : estimatedPosition < currentPosition\n        ? DIRECTION.PREV\n        : undefined;\n\n    this.state.movingState = MOVING_STATE.MOVING;\n    this.state.movingDirection = direction;\n    const changeCanceled = this.trigger(EVENTS.CHANGE, {\n      index: panel.getIndex(),\n      panel: panel.toReadonlyVersion(),\n      prevIndex: viewport.getIndex(),\n      prevPanel: viewport.getCurrentPanel().toReadonlyVersion(),\n      direction,\n      isTrusted: false,\n    } as ChangeEvent);\n\n    if (changeCanceled) {\n      return;\n    }\n\n    const nearestPanel = viewport.findNearestIdenticalPanel(panel);\n    this.viewport.moveTo(nearestPanel!.toReadonlyVersion(), null, duration);\n\n    // Move end event can't be triggered automatically when duration is 0\n    // as Axes won't trigger animationEnd or finish event\n    if (duration <= 0) {\n      this.trigger(EVENTS.MOVE_END, {\n        direction,\n        isTrusted: false,\n      });\n\n      this.stopMoving();\n    }\n  }\n}\n\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","document","documentElement","style","transformName","prefixedTransform","Error","el","createElement","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","element","className","classList","add","indexOf","replace","cssObj","property","val","min","max","Math","iterable","slice","call","arr","constructor","Array","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","adaptive","zIndex","bound","overflow","hanger","anchor","MOVING_STATE","IDLE","HOLDING","DRAGGING","MOVING","DISABLED","DEFAULT_STATE","options","currentPanelIndex","movingDirection","undefined","movingState","moveStartTriggered","lastHoldingDelta","DEFAULT_VIEWPORT_CSS","position","width","height","willChange","DEFAULT_CAMERA_CSS","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","DIRECTION","PREV","NEXT","TRANSFORM","index","viewport","state","anchorExpression","relativeAnchorPosition","size","clonedPanels","isClone","originalStyle","getAttribute","cachedBbox","addClass","applyCSS","resize","updateFunction","original","update","map","panel","bbox","getBbox","setAttribute","removeAttribute","prevPanel","nextPanel","getBoundingClientRect","getIdenticalPanels","pos","elementStyle","left","top","parseArithmeticExpression","cloneElement","cloneNode","clonedPanel","Panel","appendPanelElement","push","originalPanel","anchorPosition","focus","flicking","hangerPosition","getCameraPosition","getHangerPosition","direction","changeCanceled","trigger","prevIndex","getIndex","getCurrentPanel","toReadonlyVersion","isTrusted","moveTo","bind","prev","originalPrevPanel","newPosition","scrollArea","getScrollArea","scrollAreaSize","next","merge","originalNextPanel","viewportElement","cameraElement","translate","build","axesEvent","targetPos","canSetBoundMode","setTo","flick","axes","round","moveVector","moveCoord","coord","join","panels","adjustSize","firstPanel","lastPanel","hangerPos","getPosition","getSize","getAnchorPosition","currentHangerPosition","isOutOfBound","_a","panelPosition","panelSize","isBetween","panelElement","getElement","contains","nearest","shortestDistance","Infinity","identicals","identical","distance","abs","panInput","enable","disable","sizeToApply","currentPanel","maximumPanelSize","reduce","maximum","viewportStyle","minHeight","minWidth","wrapper","destroy","appendChild","handler","on","connect","applyCSSValue","placePanels","clonePanels","replacePanels","chainPanels","setAxesInstance","moveToDefaultPanel","panelElements","children","toArray","_this","nextPanelPos","panelPos","setPosition","viewportSize","sumOriginalPanelSize","getRelativeAnchorPosition","visibleAreaSize","totalPanelSize","cloneBasePos","origPanel","clonedPanelPos","clone","maximumVisiblePosition","lastReplacePosition","concat","reverse","replacePosition","allPanels","setPrevPanel","setNextPanel","parsedBounce","isArray","parsedVal","Axes","range","easing","interruptable","PanInput","scale","defaultPanel","defaultPosition","findShortestPositionToPanel","moveCamera","summedPanelSize","tslib_1","_super","querySelector","nodeName","nodeType","getPrevPanel","moveToPanelProgramatic","getNextPanel","getPanel","getPrevIndex","getNextIndex","getPanelCount","off","eventName","params","holding","type","setInitialState","initViewport","listenInput","firstChild","Viewport","connectAxesHandler","hold","onAxesHold","change","onAxesChange","release","onAxesRelease","animationEnd","onAxesAnimationEnd","finish","onAxesFinish","panelMovingTo","e","holdStartCanceled","delta","inputEvent","deltaX","deltaY","currentDirection","moveStartCanceled","stopMoving","previousPosition","moveCanceled","isNext","swipeDistance","swipeAngle","atan","PI","wasDragging","overThreshold","cameraPosition","clickedElement","srcEvent","clickedPanel","findPanelOf","selectedIndex","selectedPanel","minimumDistanceToChange","panelToMove","adjacentPanel","firstClonedPanel","lapped","findNearestPanel","eventType","changeOrRestoreCanceled","currentIndex","canMove","estimatedPosition","currentPosition","nearestPanel","findNearestIdenticalPanel","Flicking","Component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eAAsBA;eAAgB;;OAAA,YAAAC,uBAAAA;IAAAC,YAAA,gBAAA;;;EACpCA,IAAI,CAACC,OAAL,CAAa,UAAAC,MAAA;IACXC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBD,OAApB,CAA4B,UAAAI,GAAA;UACpBC,KAAK,GAAGJ,MAAM,CAACG,GAAD,CAApB;MACAP,MAAM,CAACO,GAAD,CAAN,GAAcC,KAAd;KAFF;GADF;SAOOR,MAAP;;;;AAKF,AAAO,IAAIS,qBAAqB,GAAG;MAC3BC,UAAU,GAAG;IACjBC,eAAe,EAAE,mBADA;IAEjBC,WAAW,EAAE,eAFI;IAGjBC,YAAY,EAAE,gBAHG;IAIjBC,UAAU,EAAE,cAJK;IAKjBC,SAAS,EAAE;GALb;MAQMC,cAAc,GAAGC,QAAQ,CAACC,eAAT,CAAyBC,KAAhD;MACIC,aAAa,GAAG,EAApB;;OACK,IAAMC,iBAAX,IAAgCX,UAAhC,EAA4C;QACtCW,iBAAiB,IAAIL,cAAzB,EAAyC;MACvCI,aAAa,GAAGC,iBAAhB;;;;MAIA,CAACD,aAAL,EAAoB;UACZ,IAAIE,KAAJ,CAAU,6CAAV,CAAN;;;MAGIC,EAAE,GAAGN,QAAQ,CAACO,aAAT,CAAuB,KAAvB,CAAX;EAEAP,QAAQ,CAACC,eAAT,CAAyBO,YAAzB,CAAsCF,EAAtC,EAA0C,IAA1C;EAEAA,EAAE,CAACJ,KAAH,CAASC,aAAT,IAA0B,4BAA1B;MACMM,QAAQ,GAAGC,MAAM,CAACC,gBAAP,CAAwBL,EAAxB,EAA4BM,gBAA5B,CAA6CnB,UAAU,CAACU,aAAD,CAAvD,CAAjB;EAEAG,EAAE,CAACO,aAAH,CAAkBC,WAAlB,CAA8BR,EAA9B;MAEMS,aAAa,GAAG;IACpBC,IAAI,EAAEb,aADc;IAEpBc,KAAK,EAAER,QAAQ,CAACS,MAAT,GAAkB,CAAlB,IAAuBT,QAAQ,KAAK;GAF7C;;EAKAjB,qBAAqB,GAAG;WAAMuB,aAAA;GAA9B;;SAEOA,aAAP;CArCK;;AAgDP,kBAAyBI,SAAsBC;MACzCD,OAAO,CAACE,SAAZ,EAAuB;IACrBF,OAAO,CAACE,SAAR,CAAkBC,GAAlB,CAAsBF,SAAtB;GADF,MAEO;QACDD,OAAO,CAACC,SAAR,CAAkBG,OAAlB,CAA0BH,SAA1B,IAAuC,CAA3C,EAA8C;MAC5CD,OAAO,CAACC,SAAR,GAAoB,CAAID,OAAO,CAACC,SAAR,MAAA,GAAqBA,SAAzB,EAAsCI,OAAtC,CAA8C,SAA9C,EAAyD,GAAzD,CAApB;;;;AAKN,kBAAyBL,SAAsBM;EAC7CrC,MAAM,CAACC,IAAP,CAAYoC,MAAZ,EAAoBvC,OAApB,CAA4B,UAAAwC,QAAA;IAC1BP,OAAO,CAACjB,KAAR,CAAcwB,QAAd,IAA0BD,MAAM,CAACC,QAAD,CAAhC;GADF;;AAKF,eAAsBC,KAAaC,KAAaC;SACvCC,IAAI,CAACD,GAAL,CAASC,IAAI,CAACF,GAAL,CAASD,GAAT,EAAcE,GAAd,CAAT,EAA6BD,GAA7B,CAAP;;;AAIF,mBAA0BD,KAAaC,KAAaC;SAC3CF,GAAG,IAAIC,GAAP,IAAcD,GAAG,GAAGE,GAA3B;;AAQF,iBAA2BE;SAClB,GAAGC,KAAH,CAASC,IAAT,CAAcF,QAAd,CAAP;;AAGF,iBAAwBG;SACfA,GAAG,IAAIA,GAAG,CAACC,WAAJ,KAAoBC,KAAlC;;AAGF,mCAA0CC,UAA2BC,MAAcC;;MAE3EC,YAAY,GAAGD,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkCD,IAAI,GAAG,CAA9D;MACMG,QAAQ,GAAG,wCAAjB;;MAEI,OAAOJ,QAAP,KAAoB,QAAxB,EAAkC;WACzBK,KAAK,CAACL,QAAD,EAAW,CAAX,EAAcC,IAAd,CAAZ;;;MAGEK,GAAG,GAAG,CAAV;MACIC,eAAe,GAAG,CAAtB;MACIC,WAAW,GAAGJ,QAAQ,CAACK,IAAT,CAAcT,QAAd,CAAlB;;SACOQ,WAAW,IAAI,IAAtB,EAA4B;QACtBE,IAAI,GAAGF,WAAW,CAAC,CAAD,CAAtB;QACMtD,KAAK,GAAGsD,WAAW,CAAC,CAAD,CAAzB;QACMG,IAAI,GAAGH,WAAW,CAAC,CAAD,CAAxB;QAEII,WAAW,GAAGC,UAAU,CAAC3D,KAAD,CAA5B;;QAEIoD,GAAG,IAAI,CAAX,EAAc;MACZI,IAAI,GAAGA,IAAI,IAAI,GAAf;KARwB;;;QAYtB,CAACA,IAAL,EAAW;aACFP,YAAP;;;QAGEQ,IAAI,KAAK,GAAb,EAAkB;MAChBC,WAAW,GAAIA,WAAW,GAAG,GAAf,GAAsBX,IAApC;;;IAGFM,eAAe,IAAIG,IAAI,KAAK,GAAT,GACfE,WADe,GAEf,CAACA,WAFL,CApB0B;;MAyBxBN,GAAF;IACAE,WAAW,GAAGJ,QAAQ,CAACK,IAAT,CAAcT,QAAd,CAAd;;;;MAIEM,GAAG,KAAK,CAAZ,EAAe;WACNH,YAAP;;;;SAIKE,KAAK,CAACE,eAAD,EAAkB,CAAlB,EAAqBN,IAArB,CAAZ;;;AC/IK,IAAMa,eAAe,GAA8B;EACxDC,WAAW,EAAE,UAD2C;EAExDC,YAAY,EAAE,MAF0C;EAGxDC,UAAU,EAAE,IAH4C;EAIxDC,QAAQ,EAAE,KAJ8C;EAKxDC,SAAS,EAAE,EAL6C;EAMxDC,QAAQ,EAAE,GAN8C;EAOxDC,WAAW,EAAE,UAAAC,CAAA;WAAK,IAAI7B,IAAI,CAAC8B,GAAL,CAAS,IAAID,CAAb,EAAgB,CAAhB,CAAJ;GAPsC;EAQxDE,YAAY,EAAE,CAR0C;EASxDC,SAAS,EAAE,CAAC,OAAD,EAAU,OAAV,CAT6C;EAUxDC,cAAc,EAAE,EAVwC;EAWxDC,MAAM,EAAE,EAXgD;EAYxDC,QAAQ,EAAE,KAZ8C;EAaxDC,MAAM,EAAE,IAbgD;EAcxDC,KAAK,EAAE,KAdiD;EAexDC,QAAQ,EAAE,KAf8C;EAgBxDC,MAAM,EAAE,KAhBgD;EAiBxDC,MAAM,EAAE;CAjBH;AAoBP,AAAO,IAAMC,YAAY,GAAgB;EACvCC,IAAI,EAAE,MADiC;EAEvCC,OAAO,EAAE,SAF8B;EAGvCC,QAAQ,EAAE,UAH6B;EAIvCC,MAAM,EAAE,QAJ+B;EAKvCC,QAAQ,EAAE;CALL;AAQP,AAAO,IAAMC,aAAa,GAA4B;EACpDC,OAAO,EAAE3B,eAD2C;EAEpD4B,iBAAiB,EAAE5B,eAAe,CAACU,YAFiB;EAGpDmB,eAAe,EAAEC,SAHmC;EAIpDC,WAAW,EAAEX,YAAY,CAACC,IAJ0B;EAKpDW,kBAAkB,EAAE,KALgC;EAMpDC,gBAAgB,EAAE;CANb;AASP,AAAO,IAAMC,oBAAoB,GAAG;EAClCC,QAAQ,EAAE,UADwB;EAElCpB,MAAM,EAAEf,eAAe,CAACe,MAFU;EAGlCqB,KAAK,EAAE,MAH2B;EAIlCC,MAAM,EAAE,MAJ0B;EAKlCC,UAAU,EAAE,WALsB;EAMlCrB,QAAQ,EAAE;CANL;AASP,AAAO,IAAMsB,kBAAkB,GAAG;EAChCH,KAAK,EAAE,MADyB;EAEhCC,MAAM,EAAE;CAFH;AAKP,AAAO,IAAMG,iBAAiB,GAAG;EAC/BL,QAAQ,EAAE;CADL;AAIP,AAAO,IAAMM,MAAM,GAAc;EAC/BC,UAAU,EAAE,WADmB;EAE/BC,QAAQ,EAAE,SAFqB;EAG/BC,UAAU,EAAE,WAHmB;EAI/BC,IAAI,EAAE,MAJyB;EAK/BC,QAAQ,EAAE,SALqB;EAM/BC,MAAM,EAAE,QANuB;EAO/BC,OAAO,EAAE,SAPsB;EAQ/BC,MAAM,EAAE;CARH;AAWP,AAAO,IAAMC,SAAS,GAAc;EAClCC,IAAI,EAAE,MAD4B;EAElCC,IAAI,EAAE;CAFD;AAKP,AAAO,IAAMC,SAAS,GAAGhH,qBAAqB,EAAvC;;ACrEP;;;gBAoBE,CACE2B,OADF,EAEEsF,KAFF,EAGEC,QAHF,EAIE5B,OAJF;SAUO3D,OAAL,GAAeA,OAAf;SACKuF,QAAL,GAAgBA,QAAhB;SAEKC,KAAL,GAAa;MACXF,KAAK,OADM;MAEXnD,UAAU,EAAEwB,OAAO,CAACxB,UAFT;MAGXgC,QAAQ,EAAE,CAHC;MAIXsB,gBAAgB,EAAE9B,OAAO,CAAC8B,gBAJf;MAKXC,sBAAsB,EAAE,CALb;MAMXC,IAAI,EAAE,CANK;MAOXC,YAAY,EAAE,EAPH;MAQXC,OAAO,EAAE,KARE;MASXC,aAAa,EAAE;QACb7F,SAAS,EAAED,OAAO,CAAC+F,YAAR,CAAqB,OAArB,KAAiC,IAD/B;QAEbhH,KAAK,EAAEiB,OAAO,CAAC+F,YAAR,CAAqB,OAArB,KAAiC;OAX/B;MAaXC,UAAU,EAAE;KAbd;;QAgBIrC,OAAO,CAAC1B,WAAZ,EAAyB;MACvBgE,QAAQ,CAACjG,OAAD,EAAa2D,OAAO,CAAC1B,WAAR,WAAb,CAAR;;;;IAIFiE,QAAQ,CAAC,KAAKlG,OAAN,EAAewE,iBAAf,CAAR;SACK2B,MAAL;;;;;gBAGK,GAAP,UAAcC,cAAd;QACQZ,KAAK,GAAG,KAAKA,KAAnB;;QAEIA,KAAK,CAACK,OAAV,EAAmB;WACZQ,QAAL,CAAeC,MAAf,CAAsBF,cAAtB;;;;;KAKD,KAAKpG,OAAN,QAAA,CAAkBwF,KAAK,CAACI,YAAN,CAAmBW,GAAnB,CAAuB,UAAAC,KAAA;aAASA,KAAK,CAACxG,OAAN;KAAhC,CAAlB,EAAkEjC,OAAlE,CAA0EqI,cAA1E;GATK;;gBAYA,GAAP;QACQZ,KAAK,GAAG,KAAKA,KAAnB;;IAGAA,KAAK,CAACQ,UAAN,GAAmB,IAAnB;QAEMS,IAAI,GAAG,KAAKC,OAAL,EAAb;IAEAlB,KAAK,CAACG,IAAN,GAAaH,KAAK,CAACrD,UAAN,GACTsE,IAAI,CAACrC,KADI,GAETqC,IAAI,CAACpC,MAFT;GARK;;iBAaA,GAAP;QACQlF,EAAE,GAAG,KAAKa,OAAhB;QACM8F,aAAa,GAAG,KAAKN,KAAL,CAAWM,aAAjC;IAEAA,aAAa,CAAC7F,SAAd,GACId,EAAE,CAACwH,YAAH,CAAgB,OAAhB,EAAyBb,aAAa,CAAC7F,SAAvC,CADJ,GAEId,EAAE,CAACyH,eAAH,CAAmB,OAAnB,CAFJ;IAGAd,aAAa,CAAC/G,KAAd,GACII,EAAE,CAACwH,YAAH,CAAgB,OAAhB,EAAyBb,aAAa,CAAC/G,KAAvC,CADJ,GAEII,EAAE,CAACyH,eAAH,CAAmB,OAAnB,CAFJ;;SAKK,IAAMpE,CAAX,IAAgB,IAAhB,EAAsB;WACNA,CAAb,IAAkB,IAAlB;;GAbE;;oBAiBA,GAAP;WACS,KAAKxC,OAAZ;GADK;;2BAIA,GAAP;WACS,KAAKwF,KAAL,CAAWrB,QAAX,GAAsB,KAAKqB,KAAL,CAAWE,sBAAxC;GADK;;mCAIA,GAAP;WACS,KAAKF,KAAL,CAAWE,sBAAlB;GADK;;kBAIA,GAAP;WACS,KAAKF,KAAL,CAAWF,KAAlB;GADK;;qBAIA,GAAP;WACS,KAAKE,KAAL,CAAWrB,QAAlB;GADK;;iBAIA,GAAP;WACS,KAAKqB,KAAL,CAAWG,IAAlB;GADK;;sBAIA,GAAP;WACS,KAAKkB,SAAZ;GADK;;sBAIA,GAAP;WACS,KAAKC,SAAZ;GADK;;iBAIA,GAAP;QACQtB,KAAK,GAAG,KAAKA,KAAnB;;QACI,CAACA,KAAK,CAACQ,UAAX,EAAuB;MACrBR,KAAK,CAACQ,UAAN,GAAmB,KAAKhG,OAAL,CAAa+G,qBAAb,EAAnB;;;WAEKvB,KAAK,CAACQ,UAAb;GALK;;iBAQA,GAAP;WACS,KAAKR,KAAL,CAAWK,OAAlB;GADK;;4BAIA,GAAP;QACQL,KAAK,GAAG,KAAKA,KAAnB;WAEOA,KAAK,CAACK,OAAN,GACH,KAAKQ,QAAL,CAAeW,kBAAf,EADG,IAEF,aAASxB,KAAK,CAACI,aAFpB;GAHK;;qBAQA,GAAP,UAAmBqB,GAAnB;QACQzB,KAAK,GAAG,KAAKA,KAAnB;QACM0B,YAAY,GAAG,KAAKlH,OAAL,CAAajB,KAAlC;IAEAyG,KAAK,CAACrB,QAAN,GAAiB8C,GAAjB;IACAzB,KAAK,CAACrD,UAAN,GACI+E,YAAY,CAACC,IAAb,GAAuBF,GAAG,OAD9B,GAEIC,YAAY,CAACE,GAAb,GAAsBH,GAAG,OAF7B;IAGAzB,KAAK,CAACE,sBAAN,GAA+B2B,yBAAyB,CAAC7B,KAAK,CAACC,gBAAP,EAAyBD,KAAK,CAACG,IAA/B,CAAxD;GARK;;sBAWA,GAAP,UAAoBa,KAApB;SACOK,SAAL,GAAiBL,KAAjB;GADK;;sBAIA,GAAP,UAAoBA,KAApB;SACOM,SAAL,GAAiBN,KAAjB;GADK;;eAIA,GAAP;QACQhB,KAAK,GAAG,KAAKA,KAAnB;QACMD,QAAQ,GAAG,KAAKA,QAAtB;QAEM+B,YAAY,GAAG,KAAKtH,OAAL,CAAauH,SAAb,CAAuB,IAAvB,CAArB;QACMC,WAAW,GAAG,IAAIC,KAAJ,CAAUH,YAAV,EAAwB9B,KAAK,CAACF,KAA9B,EAAqCC,QAArC,EAA+C;MACjEE,gBAAgB,EAAED,KAAK,CAACC,gBADyC;MAEjEtD,UAAU,EAAEqD,KAAK,CAACrD;KAFA,CAApB;IAKAqF,WAAW,CAACnB,QAAZ,GAAuB,IAAvB;IACAmB,WAAW,CAAChC,KAAZ,CAAkBK,OAAlB,GAA4B,IAA5B;;;IAGA2B,WAAW,CAAChC,KAAZ,CAAkBG,IAAlB,GAAyBH,KAAK,CAACG,IAA/B;IAEAJ,QAAQ,CAACmC,kBAAT,CAA4BJ,YAA5B;IACA9B,KAAK,CAACI,YAAN,CAAmB+B,IAAnB,CAAwBH,WAAxB;WAEOA,WAAP;GAnBK;;2BAsBA,GAAP;QACQhC,KAAK,GAAG,KAAKA,KAAnB;QACMoC,aAAa,GAAG,IAAtB;WAEO;MACL5H,OAAO,EAAE,KAAKA,OADT;MAELsF,KAAK,EAAEE,KAAK,CAACF,KAFR;MAGLnB,QAAQ,EAAEqB,KAAK,CAACrB,QAHX;MAIL0D,cAAc,EAAErC,KAAK,CAACrB,QAAN,GAAiBqB,KAAK,CAACE,sBAJlC;MAKLC,IAAI,EAAEH,KAAK,CAACG,IALP;MAMLmC,KAAK,EAAL,UAA2BxF,QAA3B;YACQiD,QAAQ,GAAGqC,aAAa,CAACrC,QAA/B;YACMwC,QAAQ,GAAGxC,QAAQ,CAACwC,QAA1B;YAEMC,cAAc,GAAGzC,QAAQ,CAAC0C,iBAAT,KAA+B1C,QAAQ,CAAC2C,iBAAT,EAAtD;YACML,cAAc,GAAGrC,KAAK,CAACrB,QAAN,GAAiBqB,KAAK,CAACE,sBAA9C;;YACIsC,cAAc,KAAKH,cAAvB,EAAuC;;;;YAIjCM,SAAS,GAAGH,cAAc,GAAGH,cAAjB,GACd3C,SAAS,CAACC,IADI,GAEdD,SAAS,CAACE,IAFd;YAIMgD,cAAc,GAAGL,QAAQ,CAACM,OAAT,CAAiB5D,MAAM,CAACM,MAAxB,EAAgC;UACrDO,KAAK,EAAE,KAAKA,KADyC;UAErDkB,KAAK,EAAE,IAF8C;UAGrD2B,SAAS,WAH4C;UAIrDG,SAAS,EAAE/C,QAAQ,CAACgD,QAAT,EAJ0C;UAKrD1B,SAAS,EAAEtB,QAAQ,CAACiD,eAAT,GAA2BC,iBAA3B,EAL0C;UAMrDC,SAAS,EAAE;SANU,CAAvB;;YASIN,cAAJ,EAAoB;;;;QAIpBR,aAAa,CAACrC,QAAd,CAAuBoD,MAAvB,CAA8B,IAA9B,EAAoC,IAApC,EAA0CrG,QAA1C;;YAEIA,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,IAAI,CAApC,EAAuC;UACrCyF,QAAQ,CAACM,OAAT,CAAiB5D,MAAM,CAACK,QAAxB,EAAkC;YAChCqD,SAAS,WADuB;YAEhCO,SAAS,EAAE;WAFb;;OApCC;MA0CLpC,MAAM,EAAE,KAAKA,MAAL,CAAYsC,IAAZ,CAAiB,IAAjB,CA1CH;MA2CLC,IAAI,EAAJ;YACQC,iBAAiB,GAAGlB,aAAa,CAACf,SAAxC;;YACIiC,iBAAiB,IAAI,IAAzB,EAA+B;iBACtB,IAAP;;;YAGIjC,SAAS,GAAGiC,iBAAiB,CAACL,iBAAlB,EAAlB;;YAEI,KAAKtE,QAAL,GAAgB0C,SAAS,CAAC1C,QAA9B,EAAwC;cAClC4E,WAAW,GAAGlC,SAAS,CAAC1C,QAA5B;cACM6E,UAAU,GAAGpB,aAAa,CAACrC,QAAd,CAAuB0D,aAAvB,EAAnB;cACMC,cAAc,GAAGF,UAAU,CAACG,IAAX,GAAkBH,UAAU,CAACH,IAApD;;aAEG;YACDE,WAAW,IAAIG,cAAf;WADF,QAES,KAAK/E,QAAL,GAAgB4E,WAFzB;;iBAIOK,KAAK,CAAC,EAAD,EAAKvC,SAAL,EAAgB;YAC1B1C,QAAQ,EAAE4E,WADgB;YAE1BlB,cAAc,EAAEkB,WAAW,GAAGD,iBAAiB,CAACtD,KAAlB,CAAwBE;WAF5C,CAAZ;;;eAMKmB,SAAP;OAlEG;MAoELsC,IAAI,EAAJ;YACQE,iBAAiB,GAAGzB,aAAa,CAACd,SAAxC;;YACIuC,iBAAiB,IAAI,IAAzB,EAA+B;iBACtB,IAAP;;;YAGIvC,SAAS,GAAGuC,iBAAiB,CAACZ,iBAAlB,EAAlB;;YAEI,KAAKtE,QAAL,GAAgB2C,SAAS,CAAC3C,QAA9B,EAAwC;cAClC4E,WAAW,GAAGjC,SAAS,CAAC3C,QAA5B;cACM6E,UAAU,GAAGpB,aAAa,CAACrC,QAAd,CAAuB0D,aAAvB,EAAnB;cACMC,cAAc,GAAGF,UAAU,CAACG,IAAX,GAAkBH,UAAU,CAACH,IAApD;;aAEG;YACDE,WAAW,IAAIG,cAAf;WADF,QAES,KAAK/E,QAAL,GAAgB4E,WAFzB;;iBAIOK,KAAK,CAAC,EAAD,EAAKtC,SAAL,EAAgB;YAC1B3C,QAAQ,EAAE4E,WADgB;YAE1BlB,cAAc,EAAEkB,WAAW,GAAGM,iBAAiB,CAAC7D,KAAlB,CAAwBE;WAF5C,CAAZ;;;eAMKoB,SAAP;;KA3FJ;GAJK;;cAmGT;GApSA;;ACEA;;;mBA4BE,CACEwC,eADF,EAEEC,aAFF,EAGE5F,OAHF;SAKO2F,eAAL,GAAuBA,eAAvB;SACKC,aAAL,GAAqBA,aAArB;SAEK/D,KAAL,GAAa;MACXF,KAAK,EAAE3B,OAAO,CAACjB,YADJ;MAEXiD,IAAI,EAAE,CAAC,CAFI;MAGXxB,QAAQ,EAAE,CAHC;MAIX6D,cAAc,EAAE,CAJL;MAKXgB,UAAU,EAAE;QACVH,IAAI,EAAE,CAAC,CADG;QAEVM,IAAI,EAAE,CAAC;OAPE;MASXK,SAAS,EAAEnE,SATA;MAUX1B,OAAO;KAVT;SAaK8F,KAAL;;;;;gBAGK,GAAP,UAAcjD,KAAd,EAAoCkD,SAApC,EAAoDpH,QAApD;2BAAoD,EAAA;MAAAA,WAAmB,KAAKkD,KAAL,CAAW7B,OAAX,CAAmBrB,QAAtC;;;QAC5CkD,KAAK,GAAG,KAAKA,KAAnB;QACImE,SAAS,GAAGnD,KAAK,CAACqB,cAAN,GAAuBrC,KAAK,CAACwC,cAA7C;IAEA2B,SAAS,GAAG,KAAKC,eAAL,KACRrI,KAAK,CAACoI,SAAD,EAAYnE,KAAK,CAACwD,UAAN,CAAiBH,IAA7B,EAAmCrD,KAAK,CAACwD,UAAN,CAAiBG,IAApD,CADG,GAERQ,SAFJ;IAIAnE,KAAK,CAACF,KAAN,GAAckB,KAAK,CAAClB,KAApB;IACAoE,SAAS,GACLA,SAAS,CAACG,KAAV,CAAgB;MAAEC,KAAK,EAAEH;KAAzB,EAAsCrH,QAAtC,CADK,GAEL,KAAKyH,IAAL,CAAUF,KAAV,CAAgB;MAAEC,KAAK,EAAEH;KAAzB,EAAsCrH,QAAtC,CAFJ;GATK;;oBAcA,GAAP,UAAkB2E,GAAlB;QACQzB,KAAK,GAAG,KAAKA,KAAnB;IACAyB,GAAG,GAAGtG,IAAI,CAACqJ,KAAL,CAAW/C,GAAX,CAAN;QAEMtI,SAAS,GAAG6G,KAAK,CAACgE,SAAN,CAAgB3J,IAAlC;QACMoK,UAAU,GAAGzE,KAAK,CAAC7B,OAAN,CAAcxB,UAAd,GACf,CAAC,CAAC8E,GAAF,EAAO,CAAP,CADe,GACH,CAAC,CAAD,EAAI,CAACA,GAAL,CADhB;QAEMiD,SAAS,GAAGD,UAAU,CAAC1D,GAAX,CAAe,UAAA4D,KAAA;aAAYA,KAAK,OAAR;KAAxB,EAAsCC,IAAtC,CAA2C,IAA3C,CAAlB;SAEKb,aAAL,CAAmBxK,KAAnB,CAAyBJ,SAAzB,IAAsC6G,KAAK,CAACgE,SAAN,CAAgB1J,KAAhB,GAClC,iBAAeoK,SAAf,WADkC,GAElC,eAAaA,SAAb,MAFJ;;IAKA1E,KAAK,CAACrB,QAAN,GAAiB8C,GAAjB;GAdK;;gBAiBA,GAAP;QACQR,IAAI,GAAG,KAAK6C,eAAL,CAAqBvC,qBAArB,EAAb;QACMvB,KAAK,GAAG,KAAKA,KAAnB;QACM7B,OAAO,GAAG6B,KAAK,CAAC7B,OAAtB;QACM0G,MAAM,GAAG,KAAKA,MAApB;IAEAA,MAAM,CAACtM,OAAP,CAAe,UAAAyI,KAAA;aAASA,KAAK,CAACL,MAAN,EAAA;KAAxB;SAEKmE,UAAL;IAEA9E,KAAK,CAACG,IAAN,GAAaH,KAAK,CAAC7B,OAAN,CAAcxB,UAAd,GACTsE,IAAI,CAACrC,KADI,GAETqC,IAAI,CAACpC,MAFT;IAIAmB,KAAK,CAACwC,cAAN,GAAuBX,yBAAyB,CAAC1D,OAAO,CAACT,MAAT,EAAiBsC,KAAK,CAACG,IAAvB,CAAhD;;QAGM4E,UAAU,GAAGF,MAAM,CAAC,CAAD,CAAzB;QACMG,SAAS,GAAGH,MAAM,CAACA,MAAM,CAACtK,MAAP,GAAgB,CAAjB,CAAxB;QACM0K,SAAS,GAAGjF,KAAK,CAACwC,cAAxB;;QAGI,KAAK4B,eAAL,EAAJ,EAA4B;MAC1BpE,KAAK,CAACwD,UAAN,GAAmB;QACjBH,IAAI,EAAE0B,UAAU,CAACG,WAAX,EADW;QAEjBvB,IAAI,EAAEqB,SAAS,CAACE,WAAV,KAA0BF,SAAS,CAACG,OAAV,EAA1B,GAAgDnF,KAAK,CAACG;OAF9D;KADF,MAKO;MACLH,KAAK,CAACwD,UAAN,GAAmB;QACjBH,IAAI,EAAE0B,UAAU,CAACK,iBAAX,KAAiCH,SADtB;QAEjBtB,IAAI,EAAEqB,SAAS,CAACI,iBAAV,KAAgCH;OAFxC;;GA5BG;;;;0BAqCA,GAAP;QACQjF,KAAK,GAAG,KAAKA,KAAnB;QACMwD,UAAU,GAAGxD,KAAK,CAACwD,UAAzB;QACM6B,qBAAqB,GAAGrF,KAAK,CAACrB,QAAN,GAAiBqB,KAAK,CAACwC,cAArD;;QAEI,KAAK8C,YAAL,EAAJ,EAAyB;aAChBtF,KAAK,CAACrB,QAAN,GAAiB6E,UAAU,CAACH,IAA5B,GACH,KAAKwB,MAAL,CAAY,CAAZ,CADG,GAEH,KAAKA,MAAL,CAAY,KAAKA,MAAL,CAAYtK,MAAZ,GAAqB,CAAjC,CAFJ;;;SAKkB,UAAA,EAAAgL,KAAI,KAAKV,MAAL,OAAA,CAAgB,KAAKzE,YAArB,CAAxB,EAAoB/H,cAApB,EAAoBA,IAApB;UAAW2I,KAAK,SAAX;UACGwE,aAAa,GAAGxE,KAAK,CAACkE,WAAN,EAAtB;UACMO,SAAS,GAAGzE,KAAK,CAACmE,OAAN,EAAlB;;UAGIO,SAAS,CAACL,qBAAD,EAAwBG,aAAxB,EAAuCA,aAAa,GAAGC,SAAvD,CAAb,EAAgF;eACvEzE,KAAP;;;GAjBC;;qBAsBA,GAAP,UAAmBxG,OAAnB;SACsB,UAAA,EAAA+K,KAAI,KAAKV,MAAL,OAAA,CAAgB,KAAKzE,YAArB,CAAxB,EAAoB/H,cAApB,EAAoBA,IAApB;UAAW2I,KAAK,SAAX;UACG2E,YAAY,GAAG3E,KAAK,CAAC4E,UAAN,EAArB;;UACID,YAAY,CAACE,QAAb,CAAsBrL,OAAtB,CAAJ,EAAoC;eAC3BwG,KAAP;;;GAJC;;mCASA,GAAP,UAAiCA,KAAjC;QACQhB,KAAK,GAAG,KAAKA,KAAnB;QAEI8F,OAAO,GAAG9E,KAAd;QACI+E,gBAAgB,GAAGC,QAAvB;QACMxD,cAAc,GAAGxC,KAAK,CAACrB,QAAN,GAAiBqB,KAAK,CAACwC,cAA9C;QAEMyD,UAAU,GAAGjF,KAAK,CAACQ,kBAAN,EAAnB;IACAyE,UAAU,CAAC1N,OAAX,CAAmB,UAAA2N,SAAA;UACX7D,cAAc,GAAG6D,SAAS,CAACd,iBAAV,EAAvB;UACMe,QAAQ,GAAGhL,IAAI,CAACiL,GAAL,CAAS/D,cAAc,GAAGG,cAA1B,CAAjB;;UACI2D,QAAQ,GAAGJ,gBAAf,EAAiC;QAC/BD,OAAO,GAAGI,SAAV;QACAH,gBAAgB,GAAGI,QAAnB;;KALJ;WASOL,OAAP;GAjBK;;;qCAqBA,GAAP,UAAmC9E,KAAnC;QACQhB,KAAK,GAAG,KAAKA,KAAnB;QACM7B,OAAO,GAAG6B,KAAK,CAAC7B,OAAtB;QACMkE,cAAc,GAAGrB,KAAK,CAACoE,iBAAN,EAAvB;QACMe,QAAQ,GAAGhL,IAAI,CAACiL,GAAL,CAASpG,KAAK,CAACrB,QAAN,GAAiBqB,KAAK,CAACwC,cAAvB,GAAwCH,cAAjD,CAAjB;QACMqB,cAAc,GAAG1D,KAAK,CAACwD,UAAN,CAAiBG,IAAjB,GAAwB3D,KAAK,CAACwD,UAAN,CAAiBH,IAAhE;;QAEI,CAAClF,OAAO,CAACvB,QAAb,EAAuB;UACf+B,QAAQ,GAAG0D,cAAc,GAAGrC,KAAK,CAACwC,cAAxC;aACO,KAAK4B,eAAL,KACHrI,KAAK,CAAC4C,QAAD,EAAWqB,KAAK,CAACwD,UAAN,CAAiBH,IAA5B,EAAkCrD,KAAK,CAACwD,UAAN,CAAiBG,IAAnD,CADF,GAEHhF,QAFJ;KAFF,MAKO;;aAEEwH,QAAQ,IAAIzC,cAAc,GAAGyC,QAA7B,GACH9D,cAAc,GAAGrC,KAAK,CAACwC,cADpB,GAEHH,cAAc,GAAGrC,KAAK,CAACrB,QAAN,GAAiBqB,KAAK,CAACwC,cAAxC;QAEEH,cAAc,GAAGrC,KAAK,CAACwC,cAAvB,GAAwCkB,cAF1C;QAIErB,cAAc,GAAGrC,KAAK,CAACwC,cAAvB,GAAwCkB,cAN9C;;GAdG;;gBAwBA,GAAP;SACO2C,QAAL,CAAcC,MAAd;GADK;;iBAIA,GAAP;SACOD,QAAL,CAAcE,OAAd;GADK;;oBAIA,GAAP;QACQpI,OAAO,GAAG,KAAK6B,KAAL,CAAW7B,OAA3B;QACMxB,UAAU,GAAGwB,OAAO,CAACxB,UAA3B;QACI6J,WAAJ;;QAEIrI,OAAO,CAACb,QAAZ,EAAsB;UACdmJ,YAAY,GAAG,KAAKzD,eAAL,EAArB;UACM/B,IAAI,GAAGwF,YAAY,CAACvF,OAAb,EAAb;MAEAsF,WAAW,GAAG7J,UAAU,GAAGsE,IAAI,CAACpC,MAAR,GAAiBoC,IAAI,CAACrC,KAA9C;KAJF,MAKO;;UAEC8H,gBAAgB,GAAG,KAAK7B,MAAL,CAAY8B,MAAZ,CAAmB,UAACC,OAAD,EAAU5F,KAAV;YACpCC,IAAI,GAAGD,KAAK,CAACE,OAAN,EAAb;eACO/F,IAAI,CAACD,GAAL,CAAS0L,OAAT,EAAkBjK,UAAU,GAAGsE,IAAI,CAACpC,MAAR,GAAiBoC,IAAI,CAACrC,KAAlD,CAAP;OAFuB,EAGtB,CAHsB,CAAzB;MAKA4H,WAAW,GAAGE,gBAAd;;;QAGIG,aAAa,GAAG,KAAK/C,eAAL,CAAqBvK,KAA3C;;QACIoD,UAAJ,EAAgB;MACdkK,aAAa,CAAChI,MAAd,GAA0B2H,WAAW,OAArC;MACAK,aAAa,CAACC,SAAd,GAA0B,MAA1B;KAFF,MAGO;MACLD,aAAa,CAACjI,KAAd,GAAyB4H,WAAW,OAApC;MACAK,aAAa,CAACE,QAAd,GAAyB,MAAzB;;GA1BG;;iBA8BA,GAAP;QACQjD,eAAe,GAAG,KAAKA,eAA7B;QACMkD,OAAO,GAAGlD,eAAe,CAAC5J,aAAhC;IAEA8M,OAAQ,CAAC7M,WAAT,CAAqB2J,eAArB;SAEKS,IAAL,CAAU0C,OAAV;SACKZ,QAAL,CAAcY,OAAd;SAEKpC,MAAL,CAAYtM,OAAZ,CAAoB,UAAAyI,KAAA;MAClBgG,OAAQ,CAACE,WAAT,CAAqBlG,KAAK,CAAC4E,UAAN,EAArB;MACA5E,KAAK,CAACiG,OAAN;KAFF;;SAMK,IAAMjK,CAAX,IAAgB,IAAhB,EAAsB;WACNA,CAAb,IAAkB,IAAlB;;GAhBE;;uBAoBA,GAAP;WACS,KAAK6H,MAAL,CAAYtK,MAAnB;GADK;;kBAIA,GAAP,UAAgBuF,KAAhB;QACM,CAAC4F,SAAS,CAAC5F,KAAD,EAAQ,CAAR,EAAW,KAAK+E,MAAL,CAAYtK,MAAvB,CAAd,EAA8C;aACrC,IAAP;;;WAGK,KAAKsK,MAAL,CAAY/E,KAAZ,CAAP;GALK;;yBAQA,GAAP;WACS,KAAK+E,MAAL,CAAY,KAAK7E,KAAL,CAAWF,KAAvB,CAAP;GADK;;kBAIA,GAAP;WACS,KAAKE,KAAL,CAAWF,KAAlB;GADK;;sBAIA,GAAP;QACQE,KAAK,GAAG,KAAKA,KAAnB;QACIF,KAAK,GAAGE,KAAK,CAACF,KAAN,GAAc,CAA1B;;QAEIA,KAAK,GAAG,CAAZ,EAAe;MACbA,KAAK,GAAGE,KAAK,CAAC7B,OAAN,CAAcvB,QAAd,GACJ,KAAKiI,MAAL,CAAYtK,MAAZ,GAAqB,CADjB,GAEJ,CAAC,CAFL;;;WAKKuF,KAAP;GAVK;;sBAaA,GAAP;QACQE,KAAK,GAAG,KAAKA,KAAnB;QACIF,KAAK,GAAGE,KAAK,CAACF,KAAN,GAAc,CAA1B;;QAEIA,KAAK,IAAI,KAAK+E,MAAL,CAAYtK,MAAzB,EAAiC;MAC/BuF,KAAK,GAAGE,KAAK,CAAC7B,OAAN,CAAcvB,QAAd,GACJ,CADI,GAEJ,CAAC,CAFL;;;WAKKkD,KAAP;GAVK;;iBAaA,GAAP;WACS,KAAKE,KAAL,CAAWG,IAAlB;GADK;;uBAIA,GAAP;WACS,KAAKH,KAAL,CAAWwD,UAAlB;GADK;;2BAIA,GAAP;WACS,KAAKxD,KAAL,CAAWwC,cAAlB;GADK;;2BAIA,GAAP;WACS,KAAKxC,KAAL,CAAWrB,QAAlB;GADK;;4BAIA,GAAP,UAA0BwI,OAA1B;QACQxK,UAAU,GAAG,KAAKqD,KAAL,CAAW7B,OAAX,CAAmBxB,UAAtC;WAEO,KAAK4H,IAAL,CAAU6C,EAAV,CAAaD,OAAb,EACJE,OADI,CACI1K,UAAU,GAAG,CAAC,OAAD,EAAU,EAAV,CAAH,GAAmB,CAAC,EAAD,EAAK,OAAL,CADjC,EACgD,KAAK0J,QADrD,CAAP;GAHK;;4BAOA,GAAP,UAA0B7L,OAA1B;SACOuJ,aAAL,CAAmBmD,WAAnB,CAA+B1M,OAA/B;GADK;;eAIC,GAAR;SACO8M,aAAL;SACKC,WAAL;SACK5G,MAAL;;QAGI,KAAKX,KAAL,CAAW7B,OAAX,CAAmBvB,QAAvB,EAAiC;WAC1B4K,WAAL;WACKC,aAAL;;;SAGGC,WAAL;SACKC,eAAL;SACKC,kBAAL;GAbM;;uBAgBA,GAAR;QACQ5H,KAAK,GAAG,KAAKA,KAAnB;QACM7B,OAAO,GAAG6B,KAAK,CAAC7B,OAAtB;QACM2F,eAAe,GAAG,KAAKA,eAA7B;QACMC,aAAa,GAAG,KAAKA,aAA3B;QACMtH,WAAW,GAAG0B,OAAO,CAAC1B,WAA5B;;IAGAqH,eAAe,CAACrJ,SAAhB,GAA+BgC,WAAW,cAA1C;IACAsH,aAAa,CAACtJ,SAAd,GAA6BgC,WAAW,YAAxC;IAEAiE,QAAQ,CAACoD,eAAD,EAAkBpF,oBAAlB,CAAR;IACAgC,QAAQ,CAACqD,aAAD,EAAgBhF,kBAAhB,CAAR;;QAEIZ,OAAO,CAACZ,MAAZ,EAAoB;MAClBuG,eAAe,CAACvK,KAAhB,CAAsBgE,MAAtB,GAA+B,KAAGY,OAAO,CAACZ,MAA1C;;;QAEEY,OAAO,CAACV,QAAZ,EAAsB;MACpBqG,eAAe,CAACvK,KAAhB,CAAsBkE,QAAtB,GAAiC,SAAjC;;GAlBI;;qBAsBA,GAAR;oBAAA;;QACQU,OAAO,GAAG,KAAK6B,KAAL,CAAW7B,OAA3B;;QAGM0J,aAAa,GAAG,KAAK9D,aAAL,CAAmB+D,QAAzC;;QACI,CAACD,aAAD,IAAkB,CAACA,aAAa,CAACtN,MAArC,EAA6C;YACrC,IAAIb,KAAJ,CAAU,6BAAV,CAAN;;;;SAIGmL,MAAL,GAAckD,OAAO,CAACF,aAAD,CAAP,CAAuB9G,GAAvB,CACZ,UAACpH,EAAD,EAAkBqC,GAAlB;aAAkC,IAAIiG,KAAJ,CAAUtI,EAAV,EAAcqC,GAAd,EAAmBgM,KAAnB,EAAyB;QACzDrL,UAAU,EAAEwB,OAAO,CAACxB,UADqC;QAEzDF,WAAW,EAAE0B,OAAO,CAAC1B,WAFoC;QAGzDwD,gBAAgB,EAAE9B,OAAO,CAACR;OAHM,CAAA;KADtB,CAAd;SAOKyC,YAAL,GAAoB,EAApB;;QAGI6H,YAAY,GAAG,CAAnB;SACKpD,MAAL,CAAYtM,OAAZ,CAAoB,UAAAyI,KAAA;UACZkH,QAAQ,GAAGD,YAAjB;UACMxC,SAAS,GAAGzE,KAAK,CAACmE,OAAN,EAAlB;MAEAnE,KAAK,CAACmH,WAAN,CAAkBD,QAAlB;MACAD,YAAY,IAAIxC,SAAhB;KALF;GArBM;;qBA8BA,GAAR;QACQzF,KAAK,GAAG,KAAKA,KAAnB;QACM6E,MAAM,GAAG,KAAKA,MAApB;QACMzE,YAAY,GAAG,KAAKA,YAA1B;QAEMgI,YAAY,GAAGpI,KAAK,CAACG,IAA3B;QACM6E,SAAS,GAAGH,MAAM,CAACA,MAAM,CAACtK,MAAP,GAAgB,CAAjB,CAAxB;QAEM8N,oBAAoB,GAAGrD,SAAS,CAACE,WAAV,KAA0BF,SAAS,CAACG,OAAV,EAAvD;;;IAIAnF,KAAK,CAACwD,UAAN,GAAmB;MACjBH,IAAI,EAAErD,KAAK,CAACwD,UAAN,CAAiBH,IADN;MAEjBM,IAAI,EAAE0E,oBAAoB,GAAGxD,MAAM,CAAC,CAAD,CAAN,CAAUyD,yBAAV,EAAvB,GAA+DtI,KAAK,CAACwC;KAF7E;QAKMgB,UAAU,GAAGxD,KAAK,CAACwD,UAAzB;QACM+E,eAAe,GAAI/E,UAAU,CAACG,IAAX,GAAkByE,YAAnB,GAAmC5E,UAAU,CAACH,IAAtE;;QAGImF,cAAc,GAAGH,oBAArB;;;UAEQI,YAAY,GAAGD,cAArB;;MAGA3D,MAAM,CAACtM,OAAP,CAAe,UAAAmQ,SAAA;YACPC,cAAc,GAAGF,YAAY,GAAGC,SAAS,CAACxD,WAAV,EAAtC;;YAGMlD,WAAW,GAAG0G,SAAS,CAACE,KAAV,EAApB;QACA5G,WAAW,CAACmG,WAAZ,CAAwBQ,cAAxB;QAEAvI,YAAY,CAAC+B,IAAb,CAAkBH,WAAlB;OAPF;;MAWAwG,cAAc,IAAIH,oBAAlB;;;;;KAfF,QAgBSG,cAAc,IAAID,eAhB3B;GAtBM;;uBAyCA,GAAR;QACQvI,KAAK,GAAG,KAAKA,KAAnB;QACM6E,MAAM,GAAG,KAAKA,MAApB;QACMzE,YAAY,GAAG,KAAKA,YAA1B;QACMoD,UAAU,GAAGxD,KAAK,CAACwD,UAAzB;QACMqF,sBAAsB,GAAGrF,UAAU,CAACG,IAAX,GAAkB3D,KAAK,CAACG,IAAvD;QAEI2I,mBAAmB,GAAGjE,MAAM,CAAC,CAAD,CAAN,CAAUK,WAAV,EAA1B;;SAEoB,UAAA,EAAAK,KAAAnF,YAAY,CAAC2I,MAAb,GAAsBC,OAAtB,EAApB,EAAoB3Q,cAApB,EAAoBA,IAApB;UAAW2I,KAAK,SAAX;UACGwE,aAAa,GAAGxE,KAAK,CAACkE,WAAN,EAAtB;UACM+D,eAAe,GAAGH,mBAAmB,GAAG9H,KAAK,CAACmE,OAAN,EAA9C;;UAEIK,aAAa,IAAIqD,sBAArB,EAA6C;;;;;MAK7C7H,KAAK,CAACmH,WAAN,CAAkBc,eAAlB;MACAH,mBAAmB,GAAGG,eAAtB;;GAnBI;;qBAuBA,GAAR;QACQC,SAAS,GAAO,KAAKrE,MAAL,OAAA,CAAgB,KAAKzE,YAArB,CAAtB;IAEA8I,SAAS,CAAC3Q,OAAV,CAAkB,UAACyI,KAAD,EAAQhF,GAAR;UACVqF,SAAS,GAAIrF,GAAG,GAAG,CAAP,GACdkN,SAAS,CAAClN,GAAG,GAAG,CAAP,CADK,GAEd,IAFJ;UAIMsF,SAAS,GAAItF,GAAG,GAAGkN,SAAS,CAAC3O,MAAV,GAAmB,CAA1B,GACd2O,SAAS,CAAClN,GAAG,GAAG,CAAP,CADK,GAEd,IAFJ;MAIAgF,KAAK,CAACmI,YAAN,CAAmB9H,SAAnB;MACAL,KAAK,CAACoI,YAAN,CAAmB9H,SAAnB;KAVF;;QAaI,KAAKtB,KAAL,CAAW7B,OAAX,CAAmBvB,QAAvB,EAAiC;UACzBmI,UAAU,GAAGmE,SAAS,CAAC,CAAD,CAA5B;UACMlE,SAAS,GAAGkE,SAAS,CAACA,SAAS,CAAC3O,MAAV,GAAmB,CAApB,CAA3B;MAEAwK,UAAU,CAACoE,YAAX,CAAwBnE,SAAxB;MACAA,SAAS,CAACoE,YAAV,CAAuBrE,UAAvB;;GArBI;;yBAyBA,GAAR;QACQ/E,KAAK,GAAG,KAAKA,KAAnB;QACM7B,OAAO,GAAG6B,KAAK,CAAC7B,OAAtB;QAEMqF,UAAU,GAAGxD,KAAK,CAACwD,UAAzB;QACM4E,YAAY,GAAGpI,KAAK,CAACG,IAA3B;QACMxD,UAAU,GAAGwB,OAAO,CAACxB,UAA3B;QACMU,MAAM,GAAGc,OAAO,CAACd,MAAvB;QAEIgM,YAAY,GAAahM,MAA7B;;QACIiM,OAAO,CAACjM,MAAD,CAAX,EAAqB;MACnBgM,YAAY,GAAIhM,MAAmB,CAAC0D,GAApB,CAAwB,UAAA/F,GAAA;eAAO6G,yBAAyB,CAAC7G,GAAD,EAAMoN,YAAN,EAAoB5L,eAAe,CAACa,MAApC,CAAzB;OAA/B,CAAhB;KADF,MAEO;UACCkM,SAAS,GAAG1H,yBAAyB,CAACxE,MAAD,EAA4B+K,YAA5B,EAA0C5L,eAAe,CAACa,MAA1D,CAA3C;MACAgM,YAAY,GAAG,CAACE,SAAD,EAAYA,SAAZ,CAAf;;;SAGGhF,IAAL,GAAY,IAAIiF,IAAJ,CAAS;MACnBlF,KAAK,EAAE;QACLmF,KAAK,EAAE,CAACjG,UAAU,CAACH,IAAZ,EAAkBG,UAAU,CAACG,IAA7B,CADF;QAEL/G,QAAQ,EAAEuB,OAAO,CAACvB,QAFb;QAGLS,MAAM,EAAEgM;;KAJA,EAMT;MACDK,MAAM,EAAEvL,OAAO,CAACpB,WADf;MAEDL,YAAY,EAAEyB,OAAO,CAACzB,YAFrB;MAGDiN,aAAa,EAAE;KATL,CAAZ;SAYKtD,QAAL,GAAgB,IAAIuD,QAAJ,CAAa,KAAK9F,eAAlB,EAAmC;MACjD3G,SAAS,EAAEgB,OAAO,CAAChB,SAD8B;MAEjDC,cAAc,EAAEe,OAAO,CAACf,cAFyB;MAGjDyM,KAAK,EAAElN,UAAU,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,CAAH,GAAa,CAAC,CAAD,EAAI,CAAC,CAAL;KAHhB,CAAhB;GA7BM;;4BAoCA,GAAR;QACQqD,KAAK,GAAG,KAAKA,KAAnB;QAEM9C,YAAY,GAAGnB,KAAK,CAACiE,KAAK,CAAC7B,OAAN,CAAcjB,YAAf,EAA6B,CAA7B,EAAgC,KAAK2H,MAAL,CAAYtK,MAAZ,GAAsB,CAAtD,CAA1B;QACMuP,YAAY,GAAG,KAAKjF,MAAL,CAAY3H,YAAZ,CAArB;QACM6M,eAAe,GAAG,KAAKC,2BAAL,CAAiCF,YAAjC,CAAxB;IAEA9J,KAAK,CAACF,KAAN,GAAc5C,YAAd;SAEK+M,UAAL,CAAgBF,eAAhB;SACKxF,IAAL,CAAUF,KAAV,CAAgB;MAAEC,KAAK,EAAEyF;KAAzB,EAA4C,CAA5C;GAVM;;sBAaA,GAAR;QACQ/J,KAAK,GAAG,KAAKA,KAAnB;QACMwD,UAAU,GAAGxD,KAAK,CAACwD,UAAzB;WAEO,CAACxD,KAAK,CAAC7B,OAAN,CAAcvB,QAAf,KACDoD,KAAK,CAACrB,QAAN,GAAiB6E,UAAU,CAACH,IAA5B,IAAoCrD,KAAK,CAACrB,QAAN,GAAiB6E,UAAU,CAACG,IAD/D,CAAP;GAJM;;yBAQA,GAAR;QACQ3D,KAAK,GAAG,KAAKA,KAAnB;QACM7B,OAAO,GAAG6B,KAAK,CAAC7B,OAAtB;QACM0G,MAAM,GAAG,KAAKA,MAApB;QAEMG,SAAS,GAAGH,MAAM,CAACA,MAAM,CAACtK,MAAP,GAAgB,CAAjB,CAAxB;QACM2P,eAAe,GAAGlF,SAAS,CAACE,WAAV,KAA0BF,SAAS,CAACG,OAAV,EAAlD;WAEOhH,OAAO,CAACX,KAAR,IACF,CAACW,OAAO,CAACvB,QADP,IAEFsN,eAAe,IAAIlK,KAAK,CAACG,IAF9B;GARM;;iBAYV;GAziBA;;ACCA;;;;;;;;;;AASA;;;EAAuBgK,SAAA,SAAA,QAAA;;;;;;;;;;;;;;;;;;;;;;;;mBAiDrB,CACE3P,OADF,EAEE2D,OAFF;0BAEE,EAAA;MAAAA,YAAA;;;gBAEAiM,WAAA,KAAA,SAJF;;;QAOMpD,OAAJ;;QACI,OAAOxM,OAAP,KAAmB,QAAvB,EAAiC;MAC/BwM,OAAO,GAAG3N,QAAQ,CAACgR,aAAT,CAAuB7P,OAAvB,CAAV;;UACI,CAACwM,OAAL,EAAc;cACN,IAAItN,KAAJ,CAAU,6BAAV,CAAN;;KAHJ,MAKO,IAAIc,OAAO,CAAC8P,QAAR,IAAoB9P,OAAO,CAAC+P,QAAR,KAAqB,CAA7C,EAAgD;MACrDvD,OAAO,GAAGxM,OAAV;KADK,MAEA;YACC,IAAId,KAAJ,CAAU,sDAAV,CAAN;;;IAGFsO,KAAI,CAAChB,OAAL,GAAeA,OAAf;;IAEAgB,KAAI,CAAC/D,KAAL,CAAW9F,OAAX;;;;;;;;;;;;;;cAQK,GAAP,UAAYrB,QAAZ;QACQiD,QAAQ,GAAG,KAAKA,QAAtB;QACMiB,KAAK,GAAGjB,QAAQ,CAACiD,eAAT,GAA2BwH,YAA3B,EAAd;;QAEIxJ,KAAJ,EAAW;WACJyJ,sBAAL,CAA4BzJ,KAA5B,EAAmClE,QAAnC;;;WAGK,IAAP;GARK;;;;;;;;;cAiBA,GAAP,UAAYA,QAAZ;QACQiD,QAAQ,GAAG,KAAKA,QAAtB;QACMiB,KAAK,GAAGjB,QAAQ,CAACiD,eAAT,GAA2B0H,YAA3B,EAAd;;QAEI1J,KAAJ,EAAW;WACJyJ,sBAAL,CAA4BzJ,KAA5B,EAAmClE,QAAnC;;;WAGK,IAAP;GARK;;;;;;;;;;gBAkBA,GAAP,UAAcgD,KAAd,EAA6BhD,QAA7B;QACQiD,QAAQ,GAAG,KAAKA,QAAtB;QACMiB,KAAK,GAAGjB,QAAQ,CAAC4K,QAAT,CAAkB7K,KAAlB,CAAd;;QAEIkB,KAAJ,EAAW;WACJyJ,sBAAL,CAA4BzJ,KAA5B,EAAmClE,QAAnC;;;WAGK,IAAP;GARK;;;;;;;;kBAgBA,GAAP;WACS,KAAKiD,QAAL,CAAcgD,QAAd,EAAP;GADK;;;;;;;;sBASA,GAAP;WACS,KAAKhD,QAAL,CAAc6K,YAAd,EAAP;GADK;;;;;;;;sBASA,GAAP;WACS,KAAK7K,QAAL,CAAc8K,YAAd,EAAP;GADK;;;;;;;;yBASA,GAAP;WACS,KAAK9K,QAAL,CAAciD,eAAd,GAAgCC,iBAAhC,EAAP;GADK;;;;;;;;kBASA,GAAP,UAAgBnD,KAAhB;QACQkB,KAAK,GAAG,KAAKjB,QAAL,CAAc4K,QAAd,CAAuB7K,KAAvB,CAAd;WACOkB,KAAK,GACRA,KAAK,CAACiC,iBAAN,EADQ,GAER,IAFJ;GAFK;;;;;;;;uBAYA,GAAP;WACS,KAAKlD,QAAL,CAAc+K,aAAd,EAAP;GADK;;;;;;;;mBASA,GAAP;WACS,KAAK9K,KAAL,CAAWzB,WAAX,KAA2BX,YAAY,CAACC,IAA/C;GADK;;;;;;;;qBASA,GAAP;SACOkC,QAAL,CAAcuG,MAAd;WAEO,IAAP;GAHK;;;;;;;;sBAWA,GAAP;SACOvG,QAAL,CAAcwG,OAAd;WAEO,IAAP;GAHK;;;;;;;;;;;iBAcA,GAAP;SACOwE,GAAL;SAEKhL,QAAL,CAAckH,OAAd;;SAGK,IAAMjK,CAAX,IAAgB,IAAhB,EAAsB;WACNA,CAAb,IAAkB,IAAlB;;GAPE;;iBAWA,GAAP,UACEgO,SADF,EAEEC,MAFF;yBAEE,EAAA;MAAAA,WAAA;;;QAEMjL,KAAK,GAAG,KAAKA,KAAnB;QAEMkL,OAAO,GAAGlL,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACE,OAAnC,IACXkC,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACG,QADxC;QAGM0I,YAAY,GAAG,KAAK1G,QAAL,CAAciD,eAAd,EAArB;;QAEIiI,MAAM,CAACtI,SAAX,EAAsB;MACpB3C,KAAK,CAAC3B,eAAN,GAAwB4M,MAAM,CAACtI,SAA/B;;;;QAIEqI,SAAS,KAAK/L,MAAM,CAACK,QAAzB,EAAmC;MACjCU,KAAK,CAACxB,kBAAN,GAA2B,KAA3B;;UACIwB,KAAK,CAAC7B,OAAN,CAAcb,QAAlB,EAA4B;aACrByC,QAAL,CAAc+E,UAAd;;;;;WAKG,CAACsF,gBAAA,CAAMvH,OAAN,KAAA,KAAA,EAAcmI,SAAd,EAAyBpH,KAAK,CAAC;MACrCuH,IAAI,EAAEH,SAD+B;MAErClL,KAAK,EAAE2G,YAAY,CAAC1D,QAAb,EAF8B;MAGrC/B,KAAK,EAAEyF,YAAY,CAACxD,iBAAb,EAH8B;MAIrCiI,OAAO;KAJ6B,EAKnCD,MALmC,CAA9B,CAAR;GAxBK;;eAgCC,GAAR,UAAc9M,OAAd;SACOiN,eAAL,CAAqBjN,OAArB;SACKkN,YAAL;SACKC,WAAL;GAHM;;yBAMA,GAAR,UAAwBnN,OAAxB;;QAEQ6B,KAAK,GAAG4D,KAAK,CAAC,EAAD,EAAK1F,aAAL,CAAnB;;IAEA8B,KAAK,CAAC7B,OAAN,GAAgByF,KAAK,CAAC,EAAD,EAAKpH,eAAL,EAAsB2B,OAAtB,CAArB;SAEK6B,KAAL,GAAaA,KAAb;GANM;;sBASA,GAAR;QACQgH,OAAO,GAAG,KAAKA,OAArB;QACM7I,OAAO,GAAG,KAAK6B,KAAL,CAAW7B,OAA3B;QACM2J,QAAQ,GAAGd,OAAO,CAACc,QAAzB;;QACI,CAACA,QAAD,IAAa,CAACA,QAAQ,CAACvN,MAA3B,EAAmC;YAC3B,IAAIb,KAAJ,CAAU,yEAAV,CAAN;;;QAGIqK,aAAa,GAAG1K,QAAQ,CAACO,aAAT,CAAuB,KAAvB,CAAtB;;;QAII2R,UAAU,GAAGvE,OAAO,CAACuE,UAAzB;;WACOA,UAAP,EAAmB;MACjBxH,aAAa,CAACmD,WAAd,CAA0BqE,UAA1B;MACAA,UAAU,GAAGvE,OAAO,CAACuE,UAArB;;;;QAIIzH,eAAe,GAAGzK,QAAQ,CAACO,aAAT,CAAuB,KAAvB,CAAxB;IACAkK,eAAe,CAACoD,WAAhB,CAA4BnD,aAA5B;;IAGAiD,OAAO,CAACE,WAAR,CAAoBpD,eAApB;;SAGK/D,QAAL,GAAgB,IAAIyL,QAAJ,CAAa1H,eAAb,EAA8BC,aAA9B,EAA6C5F,OAA7C,CAAhB;QAEM4B,QAAQ,GAAG,KAAKA,QAAtB;IACAA,QAAQ,CAACwC,QAAT,GAAoB,IAApB;IAEApE,OAAO,CAACjB,YAAR,GAAuBnB,KAAK,CAACoC,OAAO,CAACjB,YAAT,EAAuB,CAAvB,EAA0B6C,QAAQ,CAAC+K,aAAT,KAA2B,CAArD,CAA5B;GA/BM;;qBAkCA,GAAR;;SAEO/K,QAAL,CAAc0L,kBAAd,CAAiC;MAC/BC,IAAI,EAAE,KAAKC,UAAL,CAAgBvI,IAAhB,CAAqB,IAArB,CADyB;MAE/BwI,MAAM,EAAE,KAAKC,YAAL,CAAkBzI,IAAlB,CAAuB,IAAvB,CAFuB;MAG/B0I,OAAO,EAAE,KAAKC,aAAL,CAAmB3I,IAAnB,CAAwB,IAAxB,CAHsB;MAI/B4I,YAAY,EAAE,KAAKC,kBAAL,CAAwB7I,IAAxB,CAA6B,IAA7B,CAJiB;MAK/B8I,MAAM,EAAE,KAAKC,YAAL,CAAkB/I,IAAlB,CAAuB,IAAvB;KALV;GAFM;;oBAWA,GAAR;QACQpD,KAAK,GAAG,KAAKA,KAAnB;IAEAA,KAAK,CAACoM,aAAN,GAAsB9N,SAAtB;IACA0B,KAAK,CAACzB,WAAN,GAAoBX,YAAY,CAACC,IAAjC;IACAmC,KAAK,CAAC3B,eAAN,GAAwBC,SAAxB;IACA0B,KAAK,CAACvB,gBAAN,GAAyB,CAAzB;GANM;;oBASA,GAAR,UAAmB4N,CAAnB;QACQrM,KAAK,GAAG,KAAKA,KAAnB;;QAEIA,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACK,QAAvC,EAAiD;;;;QAI3CqO,iBAAiB,GAAG,KAAKzJ,OAAL,CAAa5D,MAAM,CAACC,UAApB,EAAgC;MACxDgF,SAAS,EAAEmI,CAD6C;MAExDnB,OAAO,EAAE,IAF+C;MAGxDhI,SAAS,EAAE;KAHa,CAA1B;;QAMIoJ,iBAAJ,EAAuB;MACrBtM,KAAK,CAACzB,WAAN,GAAoBX,YAAY,CAACK,QAAjC;;;;IAIF+B,KAAK,CAACzB,WAAN,GAAoByB,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACI,MAAnC,GAChBJ,YAAY,CAACE,OADG,GAEhBF,YAAY,CAACG,QAFjB;IAGAiC,KAAK,CAAC3B,eAAN,GAAwBC,SAAxB;IACA0B,KAAK,CAACvB,gBAAN,GAAyB,CAAzB;GAtBM;;sBAyBA,GAAR,UAAqB4N,CAArB;QACQrM,KAAK,GAAG,KAAKA,KAAnB;QACMD,QAAQ,GAAG,KAAKA,QAAtB;QAEM0B,GAAG,GAAG4K,CAAC,CAAC5K,GAAF,CAAM6C,KAAlB;QACMiI,KAAK,GAAG,CAACF,CAAC,CAACG,UAAH,GACV,CADU,GAEVxM,KAAK,CAAC7B,OAAN,CAAcxB,UAAd,GACE0P,CAAC,CAACG,UAAF,CAAaC,MADf,GAEEJ,CAAC,CAACG,UAAF,CAAaE,MAJnB;;QAMI1M,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACK,QAAnC,IAA+C,CAACoO,CAAC,CAACE,KAAF,CAAQjI,KAA5D,EAAmE;;;;QAI7DqI,gBAAgB,GAAGJ,KAAK,GAAGvM,KAAK,CAACvB,gBAAd,GACrBiB,SAAS,CAACE,IADW,GAErBF,SAAS,CAACC,IAFd;;QAKI,CAACK,KAAK,CAACxB,kBAAX,EAA+B;MAC7BwB,KAAK,CAACxB,kBAAN,GAA2B,IAA3B;UACMoO,iBAAiB,GAAG,KAAK/J,OAAL,CAAa5D,MAAM,CAACG,UAApB,EAAgC;QACxD8E,SAAS,EAAEmI,CAD6C;QAExD1J,SAAS,EAAE3C,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACE,OAAnC,GACP6O,gBADO,GAEP3M,KAAK,CAAC3B,eAJ8C;QAKxD6E,SAAS,EAAEmJ,CAAC,CAACnJ;OALW,CAA1B;;UAQI0J,iBAAJ,EAAuB;aAChBC,UAAL;QACA7M,KAAK,CAACzB,WAAN,GAAoBX,YAAY,CAACK,QAAjC;;;;MAIF+B,KAAK,CAACzB,WAAN,GAAoByB,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACE,OAAnC,GAChBF,YAAY,CAACG,QADG,GAEhBiC,KAAK,CAACzB,WAFV;;;QAKEyB,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACG,QAAvC,EAAiD;MAC/CiC,KAAK,CAAC3B,eAAN,GAAwBsO,gBAAxB;MACA3M,KAAK,CAACvB,gBAAN,GAAyB8N,KAAzB;;;QAGIO,gBAAgB,GAAG,KAAK/M,QAAL,CAAc0C,iBAAd,EAAzB;IAEA1C,QAAQ,CAACkK,UAAT,CAAoBxI,GAApB;QACMsL,YAAY,GAAG,KAAKlK,OAAL,CAAa5D,MAAM,CAACI,IAApB,EAA0B;MAC7C6E,SAAS,EAAEmI,CADkC;MAE7C1J,SAAS,EAAE3C,KAAK,CAAC3B,eAF4B;MAG7C6E,SAAS,EAAEmJ,CAAC,CAACnJ;KAHM,CAArB;;QAMI6J,YAAJ,EAAkB;MAChBhN,QAAQ,CAACkK,UAAT,CAAoB6C,gBAApB;WACKD,UAAL;MACA7M,KAAK,CAACzB,WAAN,GAAoBX,YAAY,CAACK,QAAjC;;;GA1DI;;uBA+DA,GAAR,UAAsBoO,CAAtB;QACQrM,KAAK,GAAG,KAAKA,KAAnB;QACM7B,OAAO,GAAG6B,KAAK,CAAC7B,OAAtB;QACM4B,QAAQ,GAAG,KAAKA,QAAtB;;QAEIC,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACK,QAAvC,EAAiD;;;;QAI3CsO,KAAK,GAAGpO,OAAO,CAACxB,UAAR,GACV0P,CAAC,CAACG,UAAF,CAAaC,MADH,GAEVJ,CAAC,CAACG,UAAF,CAAaE,MAFjB;QAGMM,MAAM,GAAGT,KAAK,GAAG,CAAvB;QACMU,aAAa,GAAG9R,IAAI,CAACiL,GAAL,CAASmG,KAAT,CAAtB;QACMW,UAAU,GAAGb,CAAC,CAACG,UAAF,CAAaC,MAAb,GACftR,IAAI,CAACiL,GAAL,CAAS,MAAMjL,IAAI,CAACgS,IAAL,CAAUd,CAAC,CAACG,UAAF,CAAaE,MAAb,GAAsBL,CAAC,CAACG,UAAF,CAAaC,MAA7C,CAAN,GAA6DtR,IAAI,CAACiS,EAA3E,CADe,GAEf,EAFJ;QAIM3G,YAAY,GAAG1G,QAAQ,CAACiD,eAAT,EAArB;QACMqK,WAAW,GAAGrN,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACG,QAAvD;QACMuP,aAAa,GAAIL,aAAa,IAAI9O,OAAO,CAACtB,SAA1B,KAChBsB,OAAO,CAACxB,UAAR,GACAuQ,UAAU,IAAI/O,OAAO,CAACf,cADtB,GAEA8P,UAAU,GAAG/O,OAAO,CAACf,cAHL,CAAtB;;IAMA4C,KAAK,CAACzB,WAAN,GAAoBX,YAAY,CAACI,MAAjC;SACK6E,OAAL,CAAa5D,MAAM,CAACE,QAApB,EAA8B;MAC5B+E,SAAS,EAAEmI,CADiB;MAE5BnB,OAAO,EAAE,KAFmB;MAG5BvI,SAAS,EAAE3C,KAAK,CAAC3B,eAHW;MAI5B6E,SAAS,EAAE;KAJb;;QAOI,CAACoK,aAAL,EAAoB;UACd,CAACD,WAAL,EAAkB;YACVE,cAAc,GAAGxN,QAAQ,CAAC0C,iBAAT,EAAvB,CADgB;;YAIV+K,cAAc,GAAGnB,CAAC,CAACG,UAAF,CAAaiB,QAAb,CAAsBrV,MAA7C;YACMsV,YAAY,GAAG3N,QAAQ,CAAC4N,WAAT,CAAqBH,cAArB,CAArB;;YAEIE,YAAJ,EAAkB;cACVlI,aAAa,GAAGkI,YAAY,CAACxI,WAAb,EAAtB;cACMvC,SAAS,GAAG6C,aAAa,GAAG+H,cAAhB,GACd7N,SAAS,CAACE,IADI,GAEd4F,aAAa,GAAG+H,cAAhB,GACE7N,SAAS,CAACC,IADZ,GAEErB,SAJN;UAMA0B,KAAK,CAACzB,WAAN,GAAoBX,YAAY,CAACC,IAAjC;eACKgF,OAAL,CAAa5D,MAAM,CAACQ,MAApB,EAA4B;YAC1ByE,SAAS,EAAEmI,CADe;YAE1B1J,SAAS,WAFiB;YAG1BO,SAAS,EAAE,IAHe;YAI1B0K,aAAa,EAAEF,YAAY,CAAC3K,QAAb,EAJW;YAK1B8K,aAAa,EAAEH,YAAY,CAACzK,iBAAb;WALjB;SATF,MAgBO;UACLoJ,CAAC,CAAChI,KAAF,CAAQ;YAAEC,KAAK,EAAEiJ;WAAjB,EAAmC,CAAnC;eACKV,UAAL;;;;OAzBJ,MA4BO,IAAI7M,KAAK,CAACoM,aAAV,EAAyB;;aAEzBrM,QAAL,CAAcoD,MAAd,CAAqBnD,KAAK,CAACoM,aAAN,CAAoBnJ,iBAApB,EAArB,EAA8DoJ,CAA9D;;;;;QAKAyB,uBAAuB,GAAGd,MAAM,GAChCvG,YAAY,CAACtB,OAAb,KAAyBsB,YAAY,CAAC6B,yBAAb,EADO,GAEhC7B,YAAY,CAAC6B,yBAAb,EAFJ;IAGAwF,uBAAuB,GAAG3S,IAAI,CAACD,GAAL,CAAS4S,uBAAT,EAAkC3P,OAAO,CAACtB,SAA1C,CAA1B;QAEM2F,cAAc,GAAIzC,QAAQ,CAAC0C,iBAAT,KAA+B1C,QAAQ,CAAC2C,iBAAT,EAAvD;QAEIqL,WAAW,GAAGtH,YAAlB;;QACI6G,aAAJ,EAAmB;;;;;;;;;UAQbL,aAAa,IAAIa,uBAArB,EAA8C;YACxCE,aAAa,GAAGhB,MAAM,GACtBvG,YAAY,CAACiE,YAAb,EADsB,GAEtBjE,YAAY,CAAC+D,YAAb,EAFJ;;YAIIrM,OAAO,CAACvB,QAAZ,EAAsB;cACdqR,gBAAgB,GAAGxH,YAAY,CAACjF,kBAAb,GAAkC,CAAlC,CAAzB;cACM0M,MAAM,GAAG/S,IAAI,CAACiL,GAAL,CAASK,YAAY,CAACrB,iBAAb,KAAmC5C,cAA5C,IACXrH,IAAI,CAACiL,GAAL,CAAS6H,gBAAgB,CAAC7I,iBAAjB,KAAuC5C,cAAhD,CADJ;;cAGI0L,MAAJ,EAAY;YACVF,aAAa,GAAGhB,MAAM,GAClBiB,gBAAgB,CAACvD,YAAjB,EADkB,GAElBuD,gBAAgB,CAACzD,YAAjB,EAFJ;;;;QAMJuD,WAAW,GAAIC,aAAa,IAAI,IAAlB,GACVA,aADU,GAEVvH,YAFJ;OAjBF,MAoBO;QACLsH,WAAW,GAAGhO,QAAQ,CAACoO,gBAAT,EAAd;;KA7BJ,MA+BO;;UAEDhQ,OAAO,CAACvB,QAAZ,EAAsB;YACdqR,gBAAgB,GAAGxH,YAAY,CAACjF,kBAAb,GAAkC,CAAlC,CAAzB;YACM0M,MAAM,GAAG/S,IAAI,CAACiL,GAAL,CAASK,YAAY,CAACrB,iBAAb,KAAmC5C,cAA5C,IACXrH,IAAI,CAACiL,GAAL,CAAS6H,gBAAgB,CAAC7I,iBAAjB,KAAuC5C,cAAhD,CADJ;;YAGI,CAACwK,MAAD,IAAWkB,MAAf,EAAuB;UACrBH,WAAW,GAAGE,gBAAd;;;;;QAKFG,SAAS,GAAWd,aAAa,GACjCrO,MAAM,CAACM,MAD0B,GAEjCN,MAAM,CAACO,OAFX;;QAII8N,aAAa,IAAI,CAACnP,OAAO,CAACvB,QAA1B,IAAsCmR,WAAW,KAAKtH,YAA1D,EAAwE;MACtE2H,SAAS,GAAGnP,MAAM,CAACO,OAAnB;;;;QAII6O,uBAAuB,GAAG,KAAKxL,OAAL,CAAauL,SAAb,EAAwB;MACtDtO,KAAK,EAAEiO,WAAW,CAAChL,QAAZ,EAD+C;MAEtD/B,KAAK,EAAE+M,WAAW,CAAC9K,iBAAZ,EAF+C;MAGtDH,SAAS,EAAEsL,SAAS,KAAKnP,MAAM,CAACM,MAArB,GAA8BkH,YAAY,CAAC1D,QAAb,EAA9B,GAAwDzE,SAHb;MAItD+C,SAAS,EAAE+M,SAAS,KAAKnP,MAAM,CAACM,MAArB,GAA8BkH,YAAY,CAACxD,iBAAb,EAA9B,GAAiE3E,SAJtB;MAKtD4F,SAAS,EAAEmI,CAL2C;MAMtD1J,SAAS,EAAE3C,KAAK,CAAC3B,eANqC;MAOtD6E,SAAS,EAAE;KAPmB,CAAhC;;QAUImL,uBAAJ,EAA6B;WACtBxB,UAAL;MACA7M,KAAK,CAACzB,WAAN,GAAoBX,YAAY,CAACK,QAAjC;;;;;IAKF+B,KAAK,CAACoM,aAAN,GAAsB2B,WAAtB;SACKhO,QAAL,CAAcoD,MAAd,CAAqB4K,WAAW,CAAC9K,iBAAZ,EAArB,EAAsDoJ,CAAtD;GArJM;;4BAwJA,GAAR,UAA2BA,CAA3B;QACQrM,KAAK,GAAG,KAAKA,KAAnB;;QAEIA,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACK,QAAvC,EAAiD;;;;SAI5C4E,OAAL,CAAa5D,MAAM,CAACK,QAApB,EAA8B;MAC5B4E,SAAS,EAAEmI,CADiB;MAE5B1J,SAAS,EAAE3C,KAAK,CAAC3B,eAFW;MAG5B6E,SAAS,EAAEmJ,CAAC,CAACnJ;KAHf;GAPM;;sBAcA,GAAR,UAAqBmJ,CAArB;SACOQ,UAAL;GADM;;gCAIA,GAAR,UAA+B7L,KAA/B,EAA6ClE,QAA7C;2BAA6C,EAAA;MAAAA,WAAmB,KAAKkD,KAAL,CAAW7B,OAAX,CAAmBrB,QAAtC;;;QACrCkD,KAAK,GAAG,KAAKA,KAAnB;QACMD,QAAQ,GAAG,KAAKA,QAAtB;QAEMuO,YAAY,GAAGvO,QAAQ,CAACgD,QAAT,EAArB;QACMwL,OAAO,GAAGvN,KAAK,IAChBhB,KAAK,CAACzB,WAAN,KAAsBX,YAAY,CAACC,IADxB,IAEXmD,KAAK,CAAC+B,QAAN,OAAqBuL,YAF1B;;QAII,CAACC,OAAL,EAAc;;;;QAIRC,iBAAiB,GAAGzO,QAAQ,CAACiK,2BAAT,CAAqChJ,KAArC,CAA1B;QACMyN,eAAe,GAAG1O,QAAQ,CAAC0C,iBAAT,EAAxB;QAEME,SAAS,GAAG6L,iBAAiB,GAAGC,eAApB,GACd/O,SAAS,CAACE,IADI,GAEd4O,iBAAiB,GAAGC,eAApB,GACE/O,SAAS,CAACC,IADZ,GAEErB,SAJN;SAMK0B,KAAL,CAAWzB,WAAX,GAAyBX,YAAY,CAACI,MAAtC;SACKgC,KAAL,CAAW3B,eAAX,GAA6BsE,SAA7B;QACMC,cAAc,GAAG,KAAKC,OAAL,CAAa5D,MAAM,CAACM,MAApB,EAA4B;MACjDO,KAAK,EAAEkB,KAAK,CAAC+B,QAAN,EAD0C;MAEjD/B,KAAK,EAAEA,KAAK,CAACiC,iBAAN,EAF0C;MAGjDH,SAAS,EAAE/C,QAAQ,CAACgD,QAAT,EAHsC;MAIjD1B,SAAS,EAAEtB,QAAQ,CAACiD,eAAT,GAA2BC,iBAA3B,EAJsC;MAKjDN,SAAS,WALwC;MAMjDO,SAAS,EAAE;KANU,CAAvB;;QASIN,cAAJ,EAAoB;;;;QAId8L,YAAY,GAAG3O,QAAQ,CAAC4O,yBAAT,CAAmC3N,KAAnC,CAArB;SACKjB,QAAL,CAAcoD,MAAd,CAAqBuL,YAAa,CAACzL,iBAAd,EAArB,EAAwD,IAAxD,EAA8DnG,QAA9D;;;QAIIA,QAAQ,IAAI,CAAhB,EAAmB;WACZ+F,OAAL,CAAa5D,MAAM,CAACK,QAApB,EAA8B;QAC5BqD,SAAS,WADmB;QAE5BO,SAAS,EAAE;OAFb;WAKK2J,UAAL;;GAhDI;;;;;;;;;;EAtkBM+B,gBAAA,GAAkB,WAAlB;;;;;;;;;EAQAA,kBAAA,GAAuBlP,SAAvB;;;;;;EAMAkP,eAAA,GAAoB3P,MAApB;iBA2mBhB;EAjoBuB4P,UAAvB;;;;"}