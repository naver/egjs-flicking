{"version":3,"file":"flicking.min.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/Viewport.ts","../src/Flicking.ts"],"sourcesContent":["export function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\n\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val < max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n","import { FlickingState, FlickingOptions, EventType, Direction, MovingState } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0006,\n  horizontal: true,\n  circular: false,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n};\n\nexport const MOVING_STATE: MovingState = {\n  IDLE: \"IDLE\",\n  HOLDING: \"HOLDING\",\n  DRAGGING: \"DRAGGING\",\n  MOVING: \"MOVING\",\n  DISABLED: \"DISABLED\",\n};\n\nexport const DEFAULT_STATE: Readonly<FlickingState> = {\n  options: DEFAULT_OPTIONS,\n  currentPanelIndex: DEFAULT_OPTIONS.defaultIndex,\n  movingDirection: undefined,\n  movingState: MOVING_STATE.IDLE,\n  moveStartTriggered: false,\n  lastHoldingDelta: 0,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","import { OriginalStyle, FlickingPanel, ChangeEvent } from \"../types\";\nimport { DEFAULT_PANEL_CSS, EVENTS, DIRECTION } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression, merge } from \"../utils\";\nimport Viewport from \"./Viewport\";\n\nclass Panel {\n  private prevPanel: Panel | null;\n  private nextPanel: Panel | null;\n\n  private viewport: Viewport;\n  private element: HTMLElement;\n  private state: {\n    index: number;\n    horizontal: boolean,\n    position: number;\n    anchorExpression: string;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    originalStyle: OriginalStyle;\n    clonedPanels: Panel[];\n    cachedBbox: ClientRect | null;\n  };\n  private original?: Panel;\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    viewport: Viewport,\n    options: {\n      horizontal: boolean,\n      anchorExpression: string,\n      classPrefix?: string,\n    },\n  ) {\n    this.element = element;\n    this.viewport = viewport;\n\n    this.state = {\n      index,\n      horizontal: options.horizontal,\n      position: 0,\n      anchorExpression: options.anchorExpression,\n      relativeAnchorPosition: 0,\n      size: 0,\n      clonedPanels: [],\n      isClone: false,\n      originalStyle: {\n        className: element.getAttribute(\"class\") || null,\n        style: element.getAttribute(\"style\") || null,\n      },\n      cachedBbox: null,\n    };\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n    this.resize();\n  }\n\n  public update(updateFunction: (element: HTMLElement) => any): void {\n    const state = this.state;\n    // Call original's update function if current panel is cloned one\n    if (state.isClone) {\n      this.original!.update(updateFunction);\n      return;\n    }\n\n    // Call update function for all elements including cloned ones\n    [this.element, ...state.clonedPanels.map(panel => panel.element)].forEach(updateFunction);\n  }\n\n  public resize(): void {\n    const state = this.state;\n\n    // Removed cached bbox, as we're resizing\n    state.cachedBbox = null;\n\n    const bbox = this.getBbox();\n\n    state.size = state.horizontal\n      ? bbox.width\n      : bbox.height;\n  }\n\n  public destroy(): void {\n    const el = this.element;\n    const originalStyle = this.state.originalStyle;\n\n    originalStyle.className\n      ? el.setAttribute(\"class\", originalStyle.className)\n      : el.removeAttribute(\"class\");\n    originalStyle.style\n      ? el.setAttribute(\"style\", originalStyle.style)\n      : el.removeAttribute(\"style\");\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getPrevPanel(): Panel | null {\n    return this.prevPanel;\n  }\n\n  public getNextPanel(): Panel | null {\n    return this.nextPanel;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...state.clonedPanels];\n  }\n\n  public setPosition(pos: number) {\n    const state = this.state;\n    const elementStyle = this.element.style;\n\n    state.position = pos;\n    state.horizontal\n      ? elementStyle.left = `${pos}px`\n      : elementStyle.top = `${pos}px`;\n    state.relativeAnchorPosition = parseArithmeticExpression(state.anchorExpression, state.size);\n  }\n\n  public setPrevPanel(panel: Panel | null): void {\n    this.prevPanel = panel;\n  }\n\n  public setNextPanel(panel: Panel | null): void {\n    this.nextPanel = panel;\n  }\n\n  public clone(): Panel {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const cloneElement = this.element.cloneNode(true) as HTMLElement;\n    const clonedPanel = new Panel(cloneElement, state.index, viewport, {\n      anchorExpression: state.anchorExpression,\n      horizontal: state.horizontal,\n    });\n\n    clonedPanel.original = this;\n    clonedPanel.state.isClone = true;\n    // Can't calc size as it didn't appended to other element yet\n    // So manually set size for it\n    clonedPanel.state.size = state.size;\n\n    viewport.appendPanelElement(cloneElement);\n    state.clonedPanels.push(clonedPanel);\n\n    return clonedPanel;\n  }\n\n  public toReadonlyVersion(): FlickingPanel {\n    const state = this.state;\n    const originalPanel = this;\n\n    return {\n      element: this.element,\n      index: state.index,\n      position: state.position,\n      anchorPosition: state.position + state.relativeAnchorPosition,\n      size: state.size,\n      focus(this: FlickingPanel, duration?: number): void {\n        const viewport = originalPanel.viewport;\n        const flicking = viewport.flicking;\n\n        const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n        const anchorPosition = state.position + state.relativeAnchorPosition;\n        if (hangerPosition === anchorPosition) {\n          return;\n        }\n\n        const direction = hangerPosition > anchorPosition\n          ? DIRECTION.PREV\n          : DIRECTION.NEXT;\n\n        const changeCanceled = flicking.trigger(EVENTS.CHANGE, {\n          index: this.index,\n          panel: this,\n          direction,\n          prevIndex: viewport.getIndex(),\n          prevPanel: viewport.getCurrentPanel().toReadonlyVersion(),\n          isTrusted: false,\n        } as ChangeEvent);\n\n        if (changeCanceled) {\n          return;\n        }\n\n        originalPanel.viewport.moveTo(this, null, duration);\n\n        if (duration != null && duration <= 0) {\n          flicking.trigger(EVENTS.MOVE_END, {\n            direction,\n            isTrusted: false,\n          });\n        }\n      },\n      update: this.update.bind(this),\n      prev(this: FlickingPanel): FlickingPanel | null {\n        const originalPrevPanel = originalPanel.prevPanel;\n        if (originalPrevPanel == null) {\n          return null;\n        }\n\n        const prevPanel = originalPrevPanel.toReadonlyVersion();\n\n        if (this.position < prevPanel.position) {\n          let newPosition = prevPanel.position;\n          const scrollArea = originalPanel.viewport.getScrollArea();\n          const scrollAreaSize = scrollArea.next - scrollArea.prev;\n\n          do {\n            newPosition -= scrollAreaSize;\n          } while (this.position < newPosition);\n\n          return merge({}, prevPanel, {\n            position: newPosition,\n            anchorPosition: newPosition + originalPrevPanel.state.relativeAnchorPosition,\n          }) as FlickingPanel;\n        }\n\n        return prevPanel;\n      },\n      next(this: FlickingPanel): FlickingPanel | null {\n        const originalNextPanel = originalPanel.nextPanel;\n        if (originalNextPanel == null) {\n          return null;\n        }\n\n        const nextPanel = originalNextPanel.toReadonlyVersion();\n\n        if (this.position > nextPanel.position) {\n          let newPosition = nextPanel.position;\n          const scrollArea = originalPanel.viewport.getScrollArea();\n          const scrollAreaSize = scrollArea.next - scrollArea.prev;\n\n          do {\n            newPosition += scrollAreaSize;\n          } while (this.position > newPosition);\n\n          return merge({}, nextPanel, {\n            position: newPosition,\n            anchorPosition: newPosition + originalNextPanel.state.relativeAnchorPosition,\n          }) as FlickingPanel;\n        }\n\n        return nextPanel;\n      },\n    };\n  }\n}\n\nexport default Panel;\n","import Panel from \"./Panel\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray } from \"../utils\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS } from \"../consts\";\nimport Axes, { PanInput } from \"@egjs/axes\";\nimport { FlickingOptions, FlickingPanel } from \"../types\";\nimport Flicking from \"../Flicking\";\n\nexport default class Viewport {\n  public flicking: Flicking;\n\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private panels: Panel[];\n  private clonedPanels: Panel[];\n\n  private state: {\n    index: number;\n    size: number;\n    position: number;\n    hangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    options: FlickingOptions;\n  };\n\n  constructor(\n    viewportElement: HTMLElement,\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n\n    this.state = {\n      index: options.defaultIndex,\n      size: -1,\n      position: 0,\n      hangerPosition: 0,\n      scrollArea: {\n        prev: -1,\n        next: -1,\n      },\n      translate: TRANSFORM,\n      options,\n    };\n\n    this.build();\n  }\n\n  public moveTo(panel: FlickingPanel, axesEvent: any, duration: number = this.state.options.duration): void {\n    const state = this.state;\n    let targetPos = panel.anchorPosition - state.hangerPosition;\n\n    targetPos = this.canSetBoundMode()\n      ? clamp(targetPos, state.scrollArea.prev, state.scrollArea.next)\n      : targetPos;\n\n    state.index = panel.index;\n    axesEvent\n      ? axesEvent.setTo({ flick: targetPos }, duration)\n      : this.axes.setTo({ flick: targetPos }, duration);\n  }\n\n  public moveCamera(pos: number): void {\n    const state = this.state;\n    pos = Math.round(pos);\n\n    const transform = state.translate.name;\n    const moveVector = state.options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${coord}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n\n    // Update position\n    state.position = pos;\n  }\n\n  public resize(): void {\n    const bbox = this.viewportElement.getBoundingClientRect();\n    const state = this.state;\n    const options = state.options;\n    const panels = this.panels;\n\n    panels.forEach(panel => panel.resize());\n\n    this.adjustSize();\n\n    state.size = state.options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.hangerPosition = parseArithmeticExpression(options.hanger, state.size);\n\n    // Set viewport scrollable area\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const hangerPos = state.hangerPosition;\n\n    // TODO: Consider circular case\n    if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - hangerPos,\n        next: lastPanel.getAnchorPosition() - hangerPos,\n      };\n    }\n  }\n\n  // Find nearest anchor from current hanger position\n  // FIXME: exclude \"undefined\"\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n    const currentHangerPosition = state.position + state.hangerPosition;\n\n    if (this.isOutOfBound()) {\n      return state.position < scrollArea.prev\n        ? this.panels[0]\n        : this.panels[this.panels.length - 1];\n    }\n\n    for (const panel of [...this.panels, ...this.clonedPanels]) {\n      const panelPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n\n      // TODO: apply \"gap\" option\n      if (isBetween(currentHangerPosition, panelPosition, panelPosition + panelSize)) {\n        return panel;\n      }\n    }\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    for (const panel of [...this.panels, ...this.clonedPanels]) {\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    const state = this.state;\n\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = state.position + state.hangerPosition;\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = state.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const distance = Math.abs(state.position + state.hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.hangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.hangerPosition\n        : anchorPosition > state.position + state.hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.hangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.hangerPosition + scrollAreaSize;\n    }\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public adjustSize(): void {\n    const options = this.state.options;\n    const horizontal = options.horizontal;\n    let sizeToApply: number;\n\n    if (options.adaptive) {\n      const currentPanel = this.getCurrentPanel();\n      const bbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? bbox.height : bbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panels.reduce((maximum, panel) => {\n        const bbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? bbox.height : bbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const viewportElement = this.viewportElement;\n    const wrapper = viewportElement.parentElement;\n\n    wrapper!.removeChild(viewportElement);\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    this.panels.forEach(panel => {\n      wrapper!.appendChild(panel.getElement());\n      panel.destroy();\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getPanelCount(): number {\n    return this.panels.length;\n  }\n\n  public getPanel(index: number): Panel | null {\n    if (!isBetween(index, 0, this.panels.length)) {\n      return null;\n    }\n\n    return this.panels[index];\n  }\n\n  public getCurrentPanel(): Panel {\n    return this.panels[this.state.index];\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPrevIndex(): number {\n    const state = this.state;\n    let index = state.index - 1;\n\n    if (index < 0) {\n      index = state.options.circular\n        ? this.panels.length - 1\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getNextIndex(): number {\n    const state = this.state;\n    let index = state.index + 1;\n\n    if (index >= this.panels.length) {\n      index = state.options.circular\n        ? 0\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.hangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public connectAxesHandler(handler: {[key: string]: (event: { [key: string]: any; }) => any}): Axes {\n    const horizontal = this.state.options.horizontal;\n\n    return this.axes.on(handler)\n      .connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  public appendPanelElement(element: HTMLElement) {\n    this.cameraElement.appendChild(element);\n  }\n\n  private build(): void {\n    this.applyCSSValue();\n    this.placePanels();\n    this.resize();\n\n    // Clone panels in circular mode\n    if (this.state.options.circular) {\n      this.clonePanels();\n      this.replacePanels();\n    }\n\n    this.chainPanels();\n    this.setAxesInstance();\n    this.moveToDefaultPanel();\n  }\n\n  private applyCSSValue(): void {\n    const state = this.state;\n    const options = state.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const classPrefix = options.classPrefix;\n\n    // Set default css values for each element\n    viewportElement.className = `${classPrefix}-viewport`;\n    cameraElement.className = `${classPrefix}-camera`;\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private placePanels(): void {\n    const options = this.state.options;\n\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n    if (!panelElements || !panelElements.length) {\n      throw new Error(\"There're no panel elements.\");\n    }\n\n    // Initialize panels\n    this.panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this, {\n        horizontal: options.horizontal,\n        classPrefix: options.classPrefix,\n        anchorExpression: options.anchor,\n      }),\n    );\n    this.clonedPanels = [];\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = 0;\n    this.panels.forEach(panel => {\n      const panelPos = nextPanelPos;\n      const panelSize = panel.getSize();\n\n      panel.setPosition(panelPos);\n      nextPanelPos += panelSize;\n    });\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n\n    const viewportSize = state.size;\n    const lastPanel = panels[panels.length - 1];\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    // Update viewport scrollable area\n    // Maximum scroll extends to first clone sequence's first panel\n    state.scrollArea = {\n      prev: state.scrollArea.prev,\n      next: sumOriginalPanelSize + panels[0].getRelativeAnchorPosition() - state.hangerPosition,\n    };\n\n    const scrollArea = state.scrollArea;\n    const visibleAreaSize = (scrollArea.next + viewportSize) - scrollArea.prev;\n\n    // For each panels, clone itself while panel's last position is below viewport size\n    let totalPanelSize = sumOriginalPanelSize;\n    do {\n      const cloneBasePos = totalPanelSize;\n\n      // Iterate original panels, clone or set toggle position\n      panels.forEach(origPanel => {\n        const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n        // Clone panels\n        const clonedPanel = origPanel.clone();\n        clonedPanel.setPosition(clonedPanelPos);\n\n        clonedPanels.push(clonedPanel);\n      });\n\n      // Update base position to clone\n      totalPanelSize += sumOriginalPanelSize;\n    } while (totalPanelSize <= visibleAreaSize);\n  }\n\n  private replacePanels(): void {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n    const scrollArea = state.scrollArea;\n    const maximumVisiblePosition = scrollArea.next + state.size;\n\n    let lastReplacePosition = panels[0].getPosition();\n    // reverse() pollutes original array\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelPosition = panel.getPosition();\n      const replacePosition = lastReplacePosition - panel.getSize();\n\n      if (panelPosition <= maximumVisiblePosition) {\n        // It's visible in current scrollArea\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private chainPanels(): void {\n    const allPanels = [...this.panels, ...this.clonedPanels];\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanels.length - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.setPrevPanel(prevPanel);\n      panel.setNextPanel(nextPanel);\n    });\n\n    if (this.state.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanels.length - 1];\n\n      firstPanel.setPrevPanel(lastPanel);\n      lastPanel.setNextPanel(firstPanel);\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = state.options;\n\n    const scrollArea = state.scrollArea;\n    const viewportSize = state.size;\n    const horizontal = options.horizontal;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: parsedBounce,\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: horizontal ? [-1, 0] : [0, -1],\n    });\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n\n    const defaultIndex = clamp(state.options.defaultIndex, 0, this.panels.length -  1);\n    const defaultPanel = this.panels[defaultIndex];\n    const defaultPosition = this.findShortestPositionToPanel(defaultPanel);\n\n    state.index = defaultIndex;\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private isOutOfBound(): boolean {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n\n    return !state.options.circular\n      && (state.position < scrollArea.prev || state.position > scrollArea.next);\n  }\n\n  private canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = state.options;\n    const panels = this.panels;\n\n    const lastPanel = panels[panels.length - 1];\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n}\n","import Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\n\nimport { merge, clamp } from \"./utils\";\nimport { DEFAULT_STATE, DEFAULT_OPTIONS, EVENTS, DIRECTION, MOVING_STATE } from \"./consts\";\nimport { FlickingOptions, FlickingState, FlickingEvent, Direction, EventType, SelectEvent, ChangeEvent, FlickingPanel } from \"./types\";\nimport Panel from \"./components/Panel\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"9+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n * @throws {Error} An Error occur when given base element doesn't exist or it hasn't proper DOM structure to be initialized. <ko>주어진 기본 요소가 존재하지 않거나 초기화 할 적절한 DOM 구조가없는 경우 오류가 발생한다.</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event types\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  private state: FlickingState;\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix for class names of the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0006] Deceleration value for panel movement animation where acceleration is manually enabled by user. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for infinite scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되여 무한 스크롤이 가능하다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to destination panel(unit: pixel). A panel element must be dragged beyond the threshold to move to the destination panel.<ko>목적 패널로의 이동 임계값 (단위: 픽셀). 패널 요소를 임계값 이상으로 끌어다 놓아야만이 목적 패널로 이동한다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] The easing function to apply to a panel moving animation. The default function is easeOutCubic.<ko>패널 이동 애니메이션에 적용할 `easing`함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing the module. A zero-based integer.<ko>모듈 초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput Reference})<br>- \"touch\": A touch input device.<br>- \"mouse\": A mouse.<ko>입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput 참고})<br>- \"touch\": 터치 입력 장치.<br>- \"mouse\": 마우스.</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold value that determines whether user input is horizontal or vertical. (0 ~ 90)<ko>사용자의 입력이 가로 방향인지 세로 방향인지 판단하는 기준 각도 (0 ~ 90)</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {Boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element<ko>뷰포트 요소의 z-index 값</ko>\n   * @param {boolean} [options.bound=false] Prevents view going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Position of hanger in viewport, which hangs panel anchors.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   */\n  constructor(\n    element: HTMLElement | string,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (typeof element === \"string\") {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n\n    this.build(options);\n  }\n  /**\n   * Move to the previous panel. If `horizontal=true`is left panel. If `horizontal=false`is upper panel.\n   * @ko 이전 패널로 이동한다. `horizontal=true`이면 좌측 패널. `horizontal=false`이면 상측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public prev(duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel().getPrevPanel();\n\n    if (panel) {\n      this.moveToPanelProgramatic(panel, duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the next panel. If `horizontal=true`is right panel. If `horizontal=false`is lower panel.\n   * @ko 다음 패널로 이동한다. `horizontal=true`이면 우측 패널. `horizontal=false`이면 하측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public next(duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel().getNextPanel();\n\n    if (panel) {\n      this.moveToPanelProgramatic(panel, duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Moves to the panel in the order specified in `index`. If `index` is equal to selected panel's index, no action is taken.\n   * @ko `index`에 지정한 순서의 패널로 이동한다. `index`값이 현재 선택된 패널의 인덱스와 동일하다면, 아무 동작도 하지 않는다.\n   * @param index The index number of the panel to be moved.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getPanel(index);\n\n    if (panel) {\n      this.moveToPanelProgramatic(panel, duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the index number of the selected panel.\n   * @ko 현재 선택된 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the current panel element.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getIndex();\n  }\n\n  /**\n   * Returns the index number of the previous panel.\n   * @ko 현재 선택된 패널의 이전 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the previous panel.<br>When `circular` option is `false`, return -1 if selected panel is first panel.<ko>이전 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 첫번째 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getPrevIndex(): number {\n    return this.viewport.getPrevIndex();\n  }\n\n  /**\n   * Returns the index number of the next panel.\n   * @ko 현재 선택된 패널의 다음 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the next panel.<br>When `circular` option is `false`, return -1 if selected panel is last panel.<ko>다음 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 마지막 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getNextIndex(): number {\n    return this.viewport.getNextIndex();\n  }\n\n  /**\n   * Returns the selected panel instance\n   * @ko 현재 선택된 패널의 인스턴스를 반환한다.\n   * @return Selected panel instance.<ko>선택된 패널 인스턴스</ko>\n   */\n  public getCurrentPanel(): FlickingPanel {\n    return this.viewport.getCurrentPanel().toReadonlyVersion();\n  }\n\n  /**\n   * Returns the panel instance of given index\n   * @ko 주어진 인덱스에 해당하는 패널의 인스턴스를 반환한다.\n   * @return Panel instance of given index, `null` if it doesn't exists.<ko>주어진 인덱스에 해당하는 패널의 인스턴스, 해당 패널이 존재하지 않을 시 `null`.\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const panel = this.viewport.getPanel(index);\n    return panel\n      ? panel.toReadonlyVersion()\n      : null;\n  }\n\n  /**\n   * Returns the total length of original panels\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.getPanelCount();\n  }\n\n  /**\n   * Checks whether the animated panel is playing.\n   * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n   * @return Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n   */\n  public isPlaying(): boolean {\n    return this.state.movingState !== MOVING_STATE.IDLE;\n  }\n\n  /**\n   * The input from the input device is not blocked so that the panel can be moved by the input device.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return  An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * The input from the input device is blocked so that the panel is not moved by the input device.\n   * @ko 패널이 입력 장치에 의해 움직이지 않도록 입력 장치로부터의 입력을 막는다.\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    //  resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public trigger<T extends FlickingEvent>(\n    eventName: string,\n    params: Partial<T> = {},\n  ) {\n    const state = this.state;\n\n    const holding = state.movingState === MOVING_STATE.HOLDING\n      || state.movingState === MOVING_STATE.DRAGGING;\n\n    const currentPanel = this.viewport.getCurrentPanel();\n\n    if (params.direction) {\n      state.movingDirection = params.direction;\n    }\n\n    // TODO: Refactor this into command pattern\n    if (eventName === EVENTS.MOVE_END) {\n      state.moveStartTriggered = false;\n      if (state.options.adaptive) {\n        this.viewport.adjustSize();\n      }\n    }\n\n    // Return whether it's canceled, as it's more clear\n    return !super.trigger(eventName, merge({\n      type: eventName,\n      index: currentPanel.getIndex(),\n      panel: currentPanel.toReadonlyVersion(),\n      holding,\n    }, params));\n  }\n\n  private build(options: Partial<FlickingOptions>): void {\n    this.setInitialState(options);\n    this.initViewport();\n    this.listenInput();\n  }\n\n  private setInitialState(options: Partial<FlickingOptions>): void {\n    // Set default state values and override it\n    const state = merge({}, DEFAULT_STATE) as FlickingState;\n    // Override default options\n    state.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n\n    this.state = state;\n  }\n\n  private initViewport(): void {\n    const wrapper = this.wrapper;\n    const options = this.state.options;\n    const children = wrapper.children;\n    if (!children || !children.length) {\n      throw new Error(\"Given base element doesn't have proper DOM structure to be initialized.\");\n    }\n\n    const cameraElement = document.createElement(\"div\");\n\n    // Make all panels to be a child of camera element\n    // wrapper <- viewport <- camera <- panels[1...n]\n    let firstChild = wrapper.firstChild;\n    while (firstChild) {\n      cameraElement.appendChild(firstChild);\n      firstChild = wrapper.firstChild;\n    }\n\n    // Clipping area for camera element\n    const viewportElement = document.createElement(\"div\");\n    viewportElement.appendChild(cameraElement);\n\n    // Add viewport element to wrapper\n    wrapper.appendChild(viewportElement);\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(viewportElement, cameraElement, options);\n\n    const viewport = this.viewport;\n    viewport.flicking = this;\n\n    options.defaultIndex = clamp(options.defaultIndex, 0, viewport.getPanelCount() - 1);\n  }\n\n  private listenInput(): void {\n    // Connect Axes instance with PanInput\n    this.viewport.connectAxesHandler({\n      hold: this.onAxesHold.bind(this),\n      change: this.onAxesChange.bind(this),\n      release: this.onAxesRelease.bind(this),\n      animationEnd: this.onAxesAnimationEnd.bind(this),\n      finish: this.onAxesFinish.bind(this),\n    });\n  }\n\n  private stopMoving(): void {\n    const state = this.state;\n\n    state.panelMovingTo = undefined;\n    state.movingState = MOVING_STATE.IDLE;\n    state.movingDirection = undefined;\n    state.lastHoldingDelta = 0;\n  }\n\n  private onAxesHold(e): void {\n    const state = this.state;\n\n    if (state.movingState === MOVING_STATE.DISABLED) {\n      return;\n    }\n\n    const holdStartCanceled = this.trigger(EVENTS.HOLD_START, {\n      axesEvent: e,\n      holding: true,\n      isTrusted: true,\n    });\n\n    if (holdStartCanceled) {\n      state.movingState = MOVING_STATE.DISABLED;\n      return;\n    }\n\n    state.movingState = state.movingState !== MOVING_STATE.MOVING\n      ? MOVING_STATE.HOLDING\n      : MOVING_STATE.DRAGGING;\n    state.movingDirection = undefined;\n    state.lastHoldingDelta = 0;\n  }\n\n  private onAxesChange(e): void {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const pos = e.pos.flick;\n    const delta = !e.inputEvent\n      ? 0\n      : state.options.horizontal\n        ? e.inputEvent.deltaX\n        : e.inputEvent.deltaY;\n\n    if (state.movingState === MOVING_STATE.DISABLED || !e.delta.flick) {\n      return;\n    }\n\n    const currentDirection = delta < state.lastHoldingDelta\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    // On first move event\n    if (!state.moveStartTriggered) {\n      state.moveStartTriggered = true;\n      const moveStartCanceled = this.trigger(EVENTS.MOVE_START, {\n        axesEvent: e,\n        direction: state.movingState === MOVING_STATE.HOLDING\n          ? currentDirection\n          : state.movingDirection,\n        isTrusted: e.isTrusted,\n      });\n\n      if (moveStartCanceled) {\n        this.stopMoving();\n        state.movingState = MOVING_STATE.DISABLED;\n        return;\n      }\n\n      state.movingState = state.movingState === MOVING_STATE.HOLDING\n        ? MOVING_STATE.DRAGGING\n        : state.movingState;\n    }\n\n    if (state.movingState === MOVING_STATE.DRAGGING) {\n      state.movingDirection = currentDirection;\n      state.lastHoldingDelta = delta;\n    }\n\n    const previousPosition = this.viewport.getCameraPosition();\n\n    viewport.moveCamera(pos);\n    const moveCanceled = this.trigger(EVENTS.MOVE, {\n      axesEvent: e,\n      direction: state.movingDirection,\n      isTrusted: e.isTrusted,\n    });\n\n    if (moveCanceled) {\n      viewport.moveCamera(previousPosition);\n      this.stopMoving();\n      state.movingState = MOVING_STATE.DISABLED;\n      return;\n    }\n  }\n\n  private onAxesRelease(e): void {\n    const state = this.state;\n    const options = state.options;\n    const viewport = this.viewport;\n\n    if (state.movingState === MOVING_STATE.DISABLED) {\n      return;\n    }\n\n    const delta = options.horizontal\n      ? e.inputEvent.deltaX\n      : e.inputEvent.deltaY;\n    const isNext = delta < 0;\n    const swipeDistance = Math.abs(delta);\n    const swipeAngle = e.inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(e.inputEvent.deltaY / e.inputEvent.deltaX) / Math.PI)\n      : 90;\n\n    const currentPanel = viewport.getCurrentPanel();\n    const wasDragging = state.movingState === MOVING_STATE.DRAGGING;\n    const overThreshold = (swipeDistance >= options.threshold)\n      && (options.horizontal\n        ? swipeAngle <= options.thresholdAngle\n        : swipeAngle > options.thresholdAngle);\n\n    // Trigger hold end event\n    state.movingState = MOVING_STATE.MOVING;\n    this.trigger(EVENTS.HOLD_END, {\n      axesEvent: e,\n      holding: false,\n      direction: state.movingDirection,\n      isTrusted: true,\n    });\n\n    if (!overThreshold) {\n      if (!wasDragging) {\n        const cameraPosition = viewport.getCameraPosition();\n\n        // Static click\n        const clickedElement = e.inputEvent.srcEvent.target;\n        const clickedPanel = viewport.findPanelOf(clickedElement);\n\n        if (clickedPanel) {\n          const panelPosition = clickedPanel.getPosition();\n          const direction = panelPosition > cameraPosition\n            ? DIRECTION.NEXT\n            : panelPosition < cameraPosition\n              ? DIRECTION.PREV\n              : undefined;\n\n          state.movingState = MOVING_STATE.IDLE;\n          this.trigger(EVENTS.SELECT, {\n            axesEvent: e,\n            direction,\n            isTrusted: true,\n            selectedIndex: clickedPanel.getIndex(),\n            selectedPanel: clickedPanel.toReadonlyVersion(),\n          } as SelectEvent);\n        } else {\n          e.setTo({ flick: cameraPosition }, 0);\n          this.stopMoving();\n        }\n        return;\n      } else if (state.panelMovingTo) {\n        // Update position to move & anchor index\n        this.viewport.moveTo(state.panelMovingTo.toReadonlyVersion(), e);\n        return;\n      }\n    }\n\n    let minimumDistanceToChange = isNext\n      ? currentPanel.getSize() - currentPanel.getRelativeAnchorPosition()\n      : currentPanel.getRelativeAnchorPosition();\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    const hangerPosition = (viewport.getCameraPosition() + viewport.getHangerPosition());\n\n    let panelToMove = currentPanel;\n    if (overThreshold) {\n      // Minimum distance needed to change panel\n      // If over this threshold,\n      /*\n       * | Prev |    Next    |\n       * |------|------------|\n       * [      |<-Anchor    ] <- Panel\n       */\n      if (swipeDistance <= minimumDistanceToChange) {\n        let adjacentPanel = isNext\n          ? currentPanel.getNextPanel()\n          : currentPanel.getPrevPanel();\n\n        if (options.circular) {\n          const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n          const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n            > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n          if (lapped) {\n            adjacentPanel = isNext\n              ? firstClonedPanel.getNextPanel()\n              : firstClonedPanel.getPrevPanel();\n          }\n        }\n\n        panelToMove = (adjacentPanel != null)\n          ? adjacentPanel\n          : currentPanel;\n      } else {\n        panelToMove = viewport.findNearestPanel()!;\n      }\n    } else {\n      // Restore case\n      if (options.circular) {\n        const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n        const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n          > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n        if (!isNext && lapped) {\n          panelToMove = firstClonedPanel;\n        }\n      }\n    }\n\n    let eventType: string = overThreshold\n      ? EVENTS.CHANGE\n      : EVENTS.RESTORE;\n\n    if (overThreshold && !options.circular && panelToMove === currentPanel) {\n      eventType = EVENTS.RESTORE;\n    }\n\n    // Trigger change or restore event\n    const changeOrRestoreCanceled = this.trigger(eventType, {\n      index: panelToMove.getIndex(),\n      panel: panelToMove.toReadonlyVersion(),\n      prevIndex: eventType === EVENTS.CHANGE ? currentPanel.getIndex() : undefined,\n      prevPanel: eventType === EVENTS.CHANGE ? currentPanel.toReadonlyVersion() : undefined,\n      axesEvent: e,\n      direction: state.movingDirection,\n      isTrusted: true,\n    } as ChangeEvent);\n\n    if (changeOrRestoreCanceled) {\n      this.stopMoving();\n      state.movingState = MOVING_STATE.DISABLED;\n      return;\n    }\n\n    // Update position to move & anchor index\n    state.panelMovingTo = panelToMove;\n    this.viewport.moveTo(panelToMove.toReadonlyVersion(), e);\n  }\n\n  private onAxesAnimationEnd(e): void {\n    const state = this.state;\n\n    if (state.movingState === MOVING_STATE.DISABLED) {\n      return;\n    }\n\n    this.trigger(EVENTS.MOVE_END, {\n      axesEvent: e,\n      direction: state.movingDirection,\n      isTrusted: e.isTrusted,\n    });\n  }\n\n  private onAxesFinish(e): void {\n    this.stopMoving();\n  }\n\n  private moveToPanelProgramatic(panel: Panel, duration: number = this.state.options.duration): void {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const currentIndex = viewport.getIndex();\n    const canMove = panel\n      && state.movingState === MOVING_STATE.IDLE\n      && panel.getIndex() !== currentIndex;\n\n    if (!canMove) {\n      return;\n    }\n\n    const estimatedPosition = viewport.findShortestPositionToPanel(panel);\n    const currentPosition = viewport.getCameraPosition();\n\n    const direction = estimatedPosition > currentPosition\n      ? DIRECTION.NEXT\n      : estimatedPosition < currentPosition\n        ? DIRECTION.PREV\n        : undefined;\n\n    this.state.movingState = MOVING_STATE.MOVING;\n    this.state.movingDirection = direction;\n    const changeCanceled = this.trigger(EVENTS.CHANGE, {\n      index: panel.getIndex(),\n      panel: panel.toReadonlyVersion(),\n      prevIndex: viewport.getIndex(),\n      prevPanel: viewport.getCurrentPanel().toReadonlyVersion(),\n      direction,\n      isTrusted: false,\n    } as ChangeEvent);\n\n    if (changeCanceled) {\n      return;\n    }\n\n    const nearestPanel = viewport.findNearestIdenticalPanel(panel);\n    this.viewport.moveTo(nearestPanel!.toReadonlyVersion(), null, duration);\n\n    // Move end event can't be triggered automatically when duration is 0\n    // as Axes won't trigger animationEnd or finish event\n    if (duration <= 0) {\n      this.trigger(EVENTS.MOVE_END, {\n        direction,\n        isTrusted: false,\n      });\n\n      this.stopMoving();\n    }\n  }\n}\n\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","document","documentElement","style","transformName","prefixedTransform","Error","el","createElement","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","element","cssObj","property","val","min","max","Math","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","adaptive","zIndex","bound","overflow","hanger","anchor","MOVING_STATE","DEFAULT_STATE","options","currentPanelIndex","movingDirection","undefined","movingState","moveStartTriggered","lastHoldingDelta","DEFAULT_VIEWPORT_CSS","position","width","height","willChange","DEFAULT_CAMERA_CSS","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","DIRECTION","PREV","NEXT","TRANSFORM","index","viewport","className","state","anchorExpression","relativeAnchorPosition","size","clonedPanels","isClone","originalStyle","getAttribute","cachedBbox","classList","add","indexOf","replace","applyCSS","this","resize","updateFunction","original","update","map","panel","bbox","getBbox","setAttribute","removeAttribute","prevPanel","nextPanel","getBoundingClientRect","getIdenticalPanels","pos","elementStyle","left","top","parseArithmeticExpression","cloneElement","cloneNode","clonedPanel","Panel","appendPanelElement","push","originalPanel","anchorPosition","focus","flicking","hangerPosition","getCameraPosition","getHangerPosition","direction","trigger","prevIndex","getIndex","getCurrentPanel","toReadonlyVersion","isTrusted","moveTo","bind","prev","originalPrevPanel","newPosition","scrollArea","getScrollArea","scrollAreaSize","next","merge","originalNextPanel","viewportElement","cameraElement","translate","build","axesEvent","targetPos","canSetBoundMode","setTo","flick","axes","round","moveCoord","coord","join","panels","adjustSize","firstPanel","lastPanel","hangerPos","getPosition","getSize","getAnchorPosition","currentHangerPosition","isOutOfBound","_a","panelPosition","isBetween","getElement","contains","nearest","shortestDistance","Infinity","identical","distance","abs","panInput","enable","disable","sizeToApply","reduce","maximum","viewportStyle","minHeight","minWidth","wrapper","destroy","appendChild","handler","on","connect","applyCSSValue","placePanels","clonePanels","replacePanels","chainPanels","setAxesInstance","moveToDefaultPanel","iterable","panelElements","children","slice","call","_this","nextPanelPos","panelPos","panelSize","setPosition","viewportSize","sumOriginalPanelSize","getRelativeAnchorPosition","visibleAreaSize","totalPanelSize","cloneBasePos","origPanel","clonedPanelPos","clone","maximumVisiblePosition","lastReplacePosition","concat","reverse","replacePosition","allPanels","setPrevPanel","setNextPanel","arr","parsedBounce","constructor","Array","parsedVal","Axes","range","easing","interruptable","PanInput","scale","defaultPanel","defaultPosition","findShortestPositionToPanel","moveCamera","summedPanelSize","_super","querySelector","nodeName","nodeType","tslib_1","getPrevPanel","moveToPanelProgramatic","getNextPanel","getPanel","getPrevIndex","getNextIndex","getPanelCount","off","eventName","params","holding","currentPanel","type","setInitialState","initViewport","listenInput","firstChild","Viewport","connectAxesHandler","hold","onAxesHold","change","onAxesChange","release","onAxesRelease","animationEnd","onAxesAnimationEnd","finish","onAxesFinish","panelMovingTo","e","delta","inputEvent","deltaX","deltaY","currentDirection","stopMoving","previousPosition","isNext","swipeDistance","swipeAngle","atan","PI","wasDragging","overThreshold","cameraPosition","clickedElement","srcEvent","clickedPanel","findPanelOf","selectedIndex","selectedPanel","minimumDistanceToChange","panelToMove","adjacentPanel","firstClonedPanel","lapped","findNearestPanel","eventType","currentIndex","estimatedPosition","currentPosition","nearestPanel","findNearestIdenticalPanel","Flicking","Component"],"mappings":"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"}