{"version":3,"file":"flicking.min.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/PanelManager.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/components/Viewport.ts","../src/Flicking.ts"],"sourcesContent":["import { ElementLike } from \"./types\";\n\nexport function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\nexport function parseElement(element: ElementLike | ElementLike[]): HTMLElement[] {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n    } else {\n      elements.push(el as HTMLElement);\n    }\n  });\n\n  return elements;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function counter(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n","import { FlickingOptions, EventType, Direction, AxesEventType, StateType, MoveTypeSnapOption, MoveTypeFreeScrollOption } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const DEFAULT_MOVE_TYPE_OPTIONS: {\n  snap: MoveTypeSnapOption,\n  freeScroll: MoveTypeFreeScrollOption,\n} = {\n  snap: {\n    type: \"snap\",\n    count: 1,\n  },\n  freeScroll: {\n    type: \"freeScroll\",\n  },\n};\n\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  // willChange: \"transform\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  NONE: \"\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","import { OriginalStyle, FlickingOptions } from \"../types\";\nimport { DEFAULT_PANEL_CSS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression } from \"../utils\";\n\nclass Panel {\n  public prevSibling: Panel | null;\n  public nextSibling: Panel | null;\n\n  private element: HTMLElement;\n  private state: {\n    index: number;\n    position: number;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    clonedPanels: Panel[];\n    cachedBbox: ClientRect | null;\n  };\n  private options: FlickingOptions;\n  private original?: Panel;\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    options: FlickingOptions,\n  ) {\n    this.element = element;\n    this.prevSibling = null;\n    this.nextSibling = null;\n\n    this.state = {\n      index,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      clonedPanels: [],\n      isClone: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: element.getAttribute(\"class\") || null,\n        style: element.getAttribute(\"style\") || null,\n      },\n      cachedBbox: null,\n    };\n    this.options = options;\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n  }\n\n  public resize(): void {\n    const state = this.state;\n    const bbox = this.getBbox();\n\n    state.size = this.options.horizontal\n      ? bbox.width\n      : bbox.height;\n    state.relativeAnchorPosition = parseArithmeticExpression(this.options.anchor, state.size);\n\n    if (!state.isClone) {\n      state.clonedPanels.forEach(panel => panel.resize());\n    }\n  }\n\n  public reset(): void {\n    this.state.cachedBbox = null;\n  }\n\n  public destroy(): void {\n    const el = this.element;\n    const originalStyle = this.state.originalStyle;\n\n    originalStyle.className\n      ? el.setAttribute(\"class\", originalStyle.className)\n      : el.removeAttribute(\"class\");\n    originalStyle.style\n      ? el.setAttribute(\"style\", originalStyle.style)\n      : el.removeAttribute(\"style\");\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getClonedPanels()\n      : state.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...state.clonedPanels];\n  }\n\n  public getOriginalPanel(): Panel {\n    return this.state.isClone\n      ? this.original!\n      : this;\n  }\n\n  public setIndex(index: number) {\n    const state = this.state;\n\n    state.index = index;\n    state.clonedPanels.forEach(panel => panel.state.index = index);\n  }\n\n  public setPosition(pos: number) {\n    const state = this.state;\n    const options = this.options;\n    const elementStyle = this.element.style;\n\n    state.position = pos;\n    options.horizontal\n      ? elementStyle.left = `${pos}px`\n      : elementStyle.top = `${pos}px`;\n  }\n\n  public clone(cloneIndex: number): Panel {\n    const state = this.state;\n\n    const cloneElement = this.element.cloneNode(true) as HTMLElement;\n    const clonedPanel = new Panel(cloneElement, state.index, this.options);\n    const clonedState = clonedPanel.state;\n\n    clonedPanel.original = this;\n    clonedState.isClone = true;\n    clonedState.cloneIndex = cloneIndex;\n    // Inherit some state values\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n    state.clonedPanels.push(clonedPanel);\n\n    return clonedPanel;\n  }\n\n  public remove(): void {\n    const element = this.element;\n    element.parentNode!.removeChild(element);\n\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const state = this.state;\n    const removingPanels = state.clonedPanels.splice(start);\n\n    removingPanels.forEach(panel => {\n      panel.remove();\n    });\n  }\n}\n\nexport default Panel;\n","import Panel from \"./Panel\";\nimport { FlickingOptions } from \"../types\";\nimport { findIndex, counter } from \"../utils\";\n\nclass PanelManager {\n  private cameraElement: HTMLElement;\n  private panels: Panel[];\n  private clones: Panel[][];\n  // index range of existing panels\n  private range: {\n    min: number;\n    max: number;\n  };\n  private length: number;\n  private lastIndex: number;\n  private options: FlickingOptions;\n\n  constructor(\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n    this.length = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  public firstPanel(): Panel | undefined {\n    return this.panels[this.range.min];\n  }\n\n  public lastPanel(): Panel | undefined {\n    return this.panels[this.range.max];\n  }\n\n  public allPanels(): ReadonlyArray<Panel> {\n    return [\n      ...this.panels,\n      ...this.clonedPanels(),\n    ];\n  }\n\n  public originalPanels(): ReadonlyArray<Panel> {\n    return this.panels;\n  }\n\n  public clonedPanels(): ReadonlyArray<Panel> {\n    return this.clones.reduce((allClones, clones) => [...allClones, ...clones], []);\n  }\n\n  public has(index: number): boolean {\n    return !!this.panels[index];\n  }\n\n  public get(index: number): Panel | undefined {\n    return this.panels[index];\n  }\n\n  public getPanelCount(): number {\n    return this.length;\n  }\n\n  public getLastIndex(): number {\n    return this.lastIndex;\n  }\n\n  public getRange(): Readonly<{ min: number, max: number }> {\n    return this.range;\n  }\n\n  public getCloneCount(): number {\n    return this.clones.length;\n  }\n\n  public setLastIndex(lastIndex: number): void {\n    this.lastIndex = lastIndex;\n\n    const firstPanel = this.firstPanel();\n    const lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    }\n\n    // Remove panels above new last index\n    const range = this.range;\n    if (lastPanel.getIndex() > lastIndex) {\n      const removingPanels = this.panels.splice(lastIndex + 1);\n      removingPanels.forEach(panel => panel.remove());\n      this.length -= removingPanels.length;\n\n      const firstRemovedPanel = removingPanels.filter(panel => !!panel)[0];\n      const possibleLastPanel = firstRemovedPanel.prevSibling;\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n    }\n  }\n\n  public append(newPanels: Panel[]): void {\n    const range = this.range;\n    this.panels.push(...newPanels);\n\n    if (newPanels.length > 0) {\n      range.min = Math.max(0, range.min);\n      range.max += newPanels.length;\n      this.length += newPanels.length;\n    }\n  }\n\n  // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n  public insert(index: number, newPanels: Panel[]): number {\n    const panels = this.panels;\n    const range = this.range;\n    const cameraElement = this.cameraElement;\n    const isCircular = this.options.circular;\n    const lastIndex = this.lastIndex;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    const fragment = document.createDocumentFragment();\n    newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n    cameraElement.insertBefore(fragment, siblingElement);\n\n    let pushedIndex = newPanels.length;\n    // Like when setting index 50 while visible panels are 0, 1, 2\n    if (index > range.max) {\n      newPanels.forEach((panel, offset) => {\n        panels[index + offset] = panel;\n      });\n    } else {\n      const panelsAfterIndex = panels.slice(index, index + newPanels.length);\n      // Find empty from beginning\n      let emptyPanelCount = findIndex(panelsAfterIndex, panel => !!panel);\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n      pushedIndex = newPanels.length - emptyPanelCount;\n\n      // Insert removing empty panels\n      panels.splice(index, emptyPanelCount, ...newPanels);\n\n      // Remove panels after last index\n      if (panels.length > lastIndex + 1) {\n        const removedPanels = panels.splice(lastIndex + 1)\n          .filter(panel => Boolean(panel));\n        removedPanels.forEach(panel => panel.remove());\n        this.length -= removedPanels.length;\n      }\n    }\n\n    // Update index of previous panels\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(panel => {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    }\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n    }\n\n    // Update state\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    return pushedIndex;\n  }\n\n  public replace(index: number, newPanels: Panel[]): void {\n    const panels = this.panels;\n    const range = this.range;\n    const cameraElement = this.cameraElement;\n    const isCircular = this.options.circular;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index + newPanels.length);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    const fragment = document.createDocumentFragment();\n    newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n    cameraElement.insertBefore(fragment, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      (panels[index] as any) = null;\n    }\n\n    const replacedPanels = panels.splice(index, newPanels.length, ...newPanels);\n    const wasNonEmptyCount = replacedPanels.filter(panel => Boolean(panel)).length;\n    replacedPanels.forEach(panel => {\n      if (panel) {\n        panel.remove();\n      }\n    });\n\n    // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n  }\n\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    const isCircular = this.options.circular;\n    const panels = this.panels;\n    const clones = this.clones;\n    // Delete count should be equal or larger than 0\n    deleteCount = Math.max(deleteCount, 0);\n\n    const deletedPanels = panels\n      .splice(index, deleteCount)\n      .filter(panel => !!panel);\n\n    deletedPanels.forEach(panel => {\n      panel.remove();\n    });\n\n    if (isCircular) {\n      clones.forEach(cloneSet => {\n        cloneSet.splice(index, deleteCount);\n      });\n    }\n\n    // Update indexes\n    panels\n      .slice(index)\n      .forEach(panel => {\n        panel.setIndex(panel.getIndex() - deleteCount);\n      });\n\n    // Check last panel is empty\n    let lastIndex = panels.length - 1;\n    if (!panels[lastIndex]) {\n      const reversedPanels = panels.concat().reverse();\n      const nonEmptyIndexFromLast = findIndex(reversedPanels, panel => !!panel);\n      lastIndex = nonEmptyIndexFromLast < 0\n        ? -1 // All empty\n        : lastIndex - nonEmptyIndexFromLast;\n\n      // Remove all empty panels from last\n      panels.splice(lastIndex + 1);\n      if (isCircular) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    }\n\n    // Update range & length\n    this.range = {\n      min: findIndex(panels, panel => !!panel),\n      max: lastIndex,\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n    }\n\n    return deletedPanels;\n  }\n\n  public chainAllPanels() {\n    const allPanels = this.allPanels().filter(panel => !!panel);\n    const allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 0) {\n      return;\n    }\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanelsCount - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n\n    if (this.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanelsCount - 1];\n\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  }\n\n  public insertClones(cloneIndex: number, index: number, clonedPanels: Panel[], deleteCount: number = 0): void {\n    const clones = this.clones;\n    const lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      const newClones: Panel[] = [];\n      clonedPanels.forEach((panel, offset) => {\n        newClones[index + offset] = panel;\n      });\n\n      clones[cloneIndex] = newClones;\n    } else {\n      const insertTarget = clones[cloneIndex];\n\n      if (index >= insertTarget.length) {\n        clonedPanels.forEach((panel, offset) => {\n          insertTarget[index + offset] = panel;\n        });\n      } else {\n        insertTarget.splice(index, deleteCount, ...clonedPanels);\n        // Remove panels after last index\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }\n\n  // clones are operating in set\n  public removeClonesAfter(cloneIndex: number): void {\n    const panels = this.panels;\n    panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  }\n\n  // Clear both original & cloned\n  public clear(): void {\n    this.panels.forEach(panel => {\n      panel.remove();\n      panel.removeClonedPanelsAfter(0);\n    });\n\n    this.panels = [];\n    this.clones = [];\n    this.length = 0;\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n  }\n\n  public clearClone(): void {\n    this.panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(0);\n    });\n    this.clones = [];\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    const allPanels = this.allPanels();\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findFirstPanelFrom(index: number): Panel | undefined {\n    for (const panel of this.panels) {\n      if (panel && panel.getIndex() >= index) {\n        return panel;\n      }\n    }\n  }\n\n  private addNewClones(index: number, originalPanels: Panel[], deleteCount: number, nextSibling: Panel | undefined) {\n    const cameraElement = this.cameraElement;\n    const cloneCount = this.getCloneCount();\n    const lastPanel = this.lastPanel();\n    const lastPanelClones: Panel[] = lastPanel\n      ? lastPanel.getClonedPanels()\n      : [];\n    const nextSiblingClones: Panel[] = nextSibling\n      ? nextSibling.getClonedPanels()\n      : [];\n\n    for (const cloneIndex of counter(cloneCount)) {\n      const cloneNextSibling = nextSiblingClones[cloneIndex];\n      const lastPanelSibling = lastPanelClones[cloneIndex];\n\n      const cloneSiblingElement = cloneNextSibling\n        ? cloneNextSibling.getElement()\n        : lastPanelSibling\n          ? lastPanelSibling.getElement().nextElementSibling\n          : null;\n\n      const newClones = originalPanels.map(panel => {\n        const clone = panel.clone(cloneIndex);\n\n        cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        return clone;\n      });\n\n      this.insertClones(cloneIndex, index, newClones, deleteCount);\n    }\n  }\n\n  private updateIndex(insertingIndex: number) {\n    const panels = this.panels;\n    const range = this.range;\n\n    const newLastIndex = panels.length - 1;\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  }\n}\n\nexport default PanelManager;\n","import Panel from \"../components/Panel\";\nimport { ValueOf, Direction, StateType, FlickingContext } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: Panel | null = null;\n  public targetOffset: number = 0;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.targetOffset = prevState.targetOffset;\n  }\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","import State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.targetOffset = 0;\n  }\n\n  public onHold(e: any, { flicking, triggerEvent, transitTo }: FlickingContext): void {\n    // Shouldn't do any action until any panels on flicking area\n    if (flicking.getPanelCount() <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't be handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const clickedElement = releaseEvent.inputEvent.srcEvent.target;\n    const clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        index: clickedPanel.getIndex(),\n        panel: viewport.castToFlickingPanel(clickedPanel),\n      });\n    }\n  }\n}\n\nexport default HoldingState;\n","import State from \"./State\";\nimport Panel from \"../components/Panel\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext, MoveTypeObjectOption, MoveTypeSnapOption } from \"../types\";\nimport { clamp } from \"../utils\";\nimport Viewport from \"../components/Viewport\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onEnter(prevState: State): void {\n    super.onEnter(prevState);\n    this.delta = 0;\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, transitTo, stopCamera } = context;\n\n    const delta = this.delta;\n    const options = flicking.options;\n    const horizontal = options.horizontal;\n    const defaultDuration = options.duration;\n    const halfGap = options.gap / 2;\n    const moveType = options.moveType as MoveTypeObjectOption;\n    const isFreeScroll = moveType.type === \"freeScroll\";\n    const snapCount = isFreeScroll ? Infinity : (moveType as MoveTypeSnapOption).count;\n    const inputEvent = e.inputEvent;\n    const eventDelta = Math.abs(e.delta.flick);\n\n    const velocity = horizontal\n      ? inputEvent.velocityX\n      : inputEvent.velocityY;\n    const inputDelta = Math.abs(horizontal ? inputEvent.deltaX : inputEvent.deltaY);\n    const isNextDirection = Math.abs(velocity) > 0\n      ? velocity < 0\n      : delta > 0;\n    const swipeDistance = Math.max(Math.abs(delta), inputDelta);\n    const swipeAngle = inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI)\n      : 90;\n    const belowAngleThreshold = horizontal\n      ? swipeAngle <= options.thresholdAngle\n      : swipeAngle > options.thresholdAngle;\n    const overThreshold = swipeDistance >= options.threshold\n      && belowAngleThreshold;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (!overThreshold && this.targetPanel) {\n      // Interrupted while animating\n      viewport.moveTo(this.targetPanel, EVENTS.NONE, e, this.targetOffset);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      e.stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |--------|--------------|\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\n     */\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanel.getSize() - currentPanel.getRelativeAnchorPosition() + halfGap\n      : currentPanel.getRelativeAnchorPosition() + halfGap;\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    let duration = defaultDuration;\n    let panelToMove: Panel;\n    let offset: number = 0;\n\n    if (overThreshold) {\n      if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n        const basePanel = isFreeScroll\n          ? nearestPanel\n          : viewport.findNearestIdenticalPanel(currentPanel);\n\n        // FreeScroll & snap\n        const { panelAtDestPos, snapOffset, indexDiff } = this.findPanelWhenSnapIsOn({\n          isNextDirection,\n          e,\n          viewport,\n          basePanel,\n        });\n\n        panelToMove = panelAtDestPos;\n        offset = snapOffset;\n        duration = clamp(e.duration, defaultDuration, defaultDuration * indexDiff);\n      } else if (\n        !isFreeScroll\n        && !viewport.isOutOfBound()\n        && (\n          swipeDistance <= minimumDistanceToChange\n          // It's the same if there's not enough distance.\n          || nearestPanel.getIndex() === currentPanel.getIndex()\n        )\n      ) {\n        panelToMove = this.findAdjacentPanel(isNextDirection, viewport);\n      } else {\n        panelToMove = nearestPanel;\n      }\n    } else {\n      panelToMove = options.circular\n        ? this.findRestorePanelInCircularMode(isNextDirection, viewport)\n        : currentPanel;\n    }\n\n    const panelPosition = panelToMove.getPosition() + offset;\n    const movingToSamePanel = panelPosition === currentPanel.getPosition();\n    const eventType = (!overThreshold || movingToSamePanel)\n      ? isFreeScroll\n        ? EVENTS.NONE\n        : EVENTS.RESTORE\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      panelToMove,\n      eventType,\n      e,\n      offset,\n      duration,\n    ).onSuccess(() => {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(() => {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  }\n\n  private findRestorePanelInCircularMode(isNextDirection: boolean, viewport: Viewport): Panel {\n    const currentPanel = viewport.getCurrentPanel()!;\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n      > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n    const panelToMove = (!isNextDirection && lapped)\n      ? firstClonedPanel\n      : currentPanel;\n\n    return panelToMove;\n  }\n\n  private findPanelWhenSnapIsOn(params: {\n    isNextDirection: boolean,\n    e: any,\n    viewport: Viewport,\n    basePanel: Panel,\n  }): {\n    panelAtDestPos: Panel,\n    snapOffset: number,\n    indexDiff: number,\n  } {\n    const { isNextDirection, e, viewport, basePanel } = params;\n\n    const options = viewport.options;\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const indexRange = viewport.panelManager.getRange();\n    const halfGap = options.gap / 2;\n    const estimatedHangerPos = e.destPos.flick + viewport.getRelativeHangerPosition();\n    const moveType = options.moveType as MoveTypeObjectOption;\n    const snapCount = moveType.type === \"freeScroll\" ? Infinity : moveType.count;\n    let panelToMove = basePanel;\n    let passedPanelCount = 0;\n    let cycleIndex = panelToMove.getIndex() === indexRange.min\n      ? basePanel.getCloneIndex() + 1\n      : 0;\n\n    while (passedPanelCount < snapCount) {\n      const siblingPanel = isNextDirection\n        ? panelToMove.nextSibling\n        : panelToMove.prevSibling;\n      if (!siblingPanel) {\n        break;\n      }\n\n      const panelIndex = panelToMove.getIndex();\n      const siblingIndex = siblingPanel.getIndex();\n      if ((isNextDirection && siblingIndex <= panelIndex)\n        || (!isNextDirection && siblingIndex >= panelIndex)\n      ) {\n        cycleIndex = isNextDirection\n          ? cycleIndex + 1\n          : cycleIndex - 1;\n      }\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n\n      // Since panlToMove holds also cloned panels, we should use original panel's position\n      const originalPanel = panelToMove.getOriginalPanel();\n      const panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      const panelSize = originalPanel.getSize();\n\n      // Current panelToMove contains destPos\n      if (\n        (isNextDirection && (panelPosition + panelSize + halfGap) > estimatedHangerPos)\n        || (!isNextDirection && (panelPosition - halfGap) < estimatedHangerPos)\n      ) {\n        break;\n      }\n    }\n\n    const originalPosition = panelToMove.getOriginalPanel().getPosition();\n    const offset = cycleIndex * scrollAreaSize - (panelToMove.getPosition() - originalPosition);\n\n    return {\n      panelAtDestPos: panelToMove,\n      snapOffset: offset,\n      indexDiff: passedPanelCount,\n    };\n  }\n\n  private findAdjacentPanel(isNextDirection: boolean, viewport: Viewport): Panel {\n    const options = viewport.options;\n    const currentIndex = viewport.getCurrentIndex();\n    const currentPanel = viewport.panelManager.get(currentIndex)!;\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = options.circular\n      && (Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition));\n\n    // If lapped in circular mode, use first cloned panel as base panel\n    const basePanel = lapped\n      ? firstClonedPanel\n      : currentPanel;\n\n    const adjacentPanel = isNextDirection\n      ? basePanel.nextSibling\n      : basePanel.prevSibling;\n\n    const panelToMove = adjacentPanel\n      ? adjacentPanel\n      : basePanel;\n\n    return panelToMove;\n  }\n}\n\nexport default DraggingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { triggerEvent, transitTo }: FlickingContext): void {\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted);\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n}\n\nexport default AnimatingState;\n","import State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","import State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","import Axes, { PanInput } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport Panel from \"./Panel\";\nimport PanelManager from \"./PanelManager\";\nimport StateMachine from \"./StateMachine\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus, ElementLike, EventType, TriggerCallback, ChangeEvent, NeedPanelEvent, FlickingEvent, MoveTypeObjectOption } from \"../types\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS, EVENTS, DIRECTION, STATE_TYPE } from \"../consts\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray, parseElement, getProgress } from \"../utils\";\n\nexport default class Viewport {\n  public options: FlickingOptions;\n  public stateMachine: StateMachine;\n  public panelManager: PanelManager;\n\n  private flicking: Flicking;\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private triggerEvent: Flicking[\"triggerEvent\"];\n  private axesHandlers: {[key: string]: any};\n\n  private currentPanel: Panel | undefined;\n  private nearestPanel: Panel | undefined;\n\n  private state: {\n    size: number;\n    position: number;\n    relativeHangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    infiniteThreshold: number;\n    checkedIndexes: Array<[number, number]>;\n  };\n\n  constructor(\n    flicking: Flicking,\n    viewportElement: HTMLElement,\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n    triggerEvent: Flicking[\"triggerEvent\"],\n  ) {\n    this.flicking = flicking;\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    this.triggerEvent = triggerEvent;\n\n    this.state = {\n      size: 0,\n      position: 0,\n      relativeHangerPosition: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n    this.panelManager = new PanelManager(cameraElement, options);\n\n    this.build();\n  }\n\n  public moveTo(\n    panel: Panel,\n    eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | EventType[\"NONE\"],\n    axesEvent: any,\n    offset: number = 0,\n    duration: number = this.options.duration,\n  ): TriggerCallback {\n    const state = this.state;\n    const currentState = this.stateMachine.getState();\n    const freeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n\n    const currentPanel = this.currentPanel;\n    const currentPosition = state.position;\n    const castedPanel = this.castToFlickingPanel(panel, offset);\n\n    let estimatedPosition = castedPanel.getAnchorPosition() - state.relativeHangerPosition;\n    estimatedPosition = this.canSetBoundMode()\n      ? clamp(estimatedPosition, state.scrollArea.prev, state.scrollArea.next)\n      : estimatedPosition;\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const direction = estimatedPosition > currentPosition\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel: castedPanel,\n        direction,\n        prevIndex: currentPanel ? currentPanel.getIndex() : -1,\n        prevPanel: currentPanel ? this.castToFlickingPanel(currentPanel) : null,\n      } as ChangeEvent);\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      this.currentPanel = panel;\n      currentState.targetPanel = panel;\n      currentState.targetOffset = offset;\n      currentState.direction = estimatedPosition > currentPosition\n        ? DIRECTION.NEXT\n        : DIRECTION.PREV;\n      // freeScroll only occurs in release events\n      if (axesEvent && axesEvent.setTo) {\n        axesEvent.setTo({ flick: freeScroll ? axesEvent.destPos.flick : estimatedPosition }, duration);\n      } else {\n        if (estimatedPosition === currentPosition) {\n          // no move\n          this.nearestPanel = this.findNearestPanel();\n        } else {\n          this.axes.setTo({ flick: estimatedPosition }, duration);\n        }\n      }\n    });\n\n    return eventResult;\n  }\n\n  public moveCamera(pos: number, axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const transform = state.translate.name;\n\n    // Update position & nearestPanel\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n\n    const nearestPanel = this.nearestPanel;\n    const originalNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    this.checkNeedPanel(axesEvent);\n\n    // Possibly modified after need panel, if it's looped\n    const modifiedNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n    pos += (modifiedNearestPosition - originalNearestPosition);\n    state.position = pos;\n\n    const moveVector = options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n  }\n\n  public stopCamera = (axesEvent: any): void => {\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: this.state.position }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  public resize(): void {\n    const panelManager = this.panelManager;\n\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n\n    // Clone panels in circular mode\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n\n    panelManager.chainAllPanels();\n    this.updateCameraPosition();\n  }\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const { prev: prevRange, next: nextRange } = state.scrollArea;\n    const hangerPosition = this.getHangerPosition();\n    const relativeHangerPosition = this.getRelativeHangerPosition();\n\n    if (this.isOutOfBound()) {\n      const position = state.position;\n      const currentPanel = this.getCurrentPanel();\n\n      if (position < prevRange) {\n        return panelManager.firstPanel();\n      } else if (position > nextRange) {\n        return panelManager.lastPanel();\n      } else if (currentPanel) {\n        const currentAnchorPosition = currentPanel.getAnchorPosition();\n        if (\n          (position === prevRange && currentAnchorPosition <= prevRange + relativeHangerPosition) ||\n          (position === nextRange && currentAnchorPosition >= nextRange + relativeHangerPosition)\n         ) {\n          return currentPanel;\n        }\n      }\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  }\n\n  public findNearestPanelAt(position: number): Panel | undefined {\n    const panelManager = this.panelManager;\n\n    const allPanels = panelManager.allPanels();\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel | undefined;\n\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(position, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - position),\n          Math.abs(nextPosition - position),\n        );\n\n      if (distance >= minimumDistance) {\n        break;\n      }\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = this.getHangerPosition();\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = this.getHangerPosition();\n    const distance = Math.abs(hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.relativeHangerPosition\n        : anchorPosition > hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.relativeHangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public insert(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const lastIndex = this.panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this.options))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const pushedIndex = this.panelManager.insert(index, panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n    }\n\n    // Update checked indexes in infinite mode\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (isBetween(index, min, max)) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx, 1);\n      } else if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n\n    this.resize();\n\n    return panels.map(panel => this.castToFlickingPanel(panel));\n  }\n\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const panelManager = this.panelManager;\n    const lastIndex = panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this.options))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    panelManager.replace(index, panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n    }\n\n    // Update checked indexes in infinite mode\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (index <= max && index + panels.length > min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx, 1);\n      }\n    });\n\n    this.resize();\n\n    return panels.map(panel => this.castToFlickingPanel(panel));\n  }\n\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    // Index should not below 0\n    index = Math.max(index, 0);\n\n    const panelManager = this.panelManager;\n    const currentIndex = this.getCurrentIndex();\n\n    const removedPanels = panelManager.remove(index, deleteCount);\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      const newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    }\n    this.resize();\n\n    return removedPanels.map(panel => this.castToFlickingPanel(panel));\n  }\n\n  public updateAdaptiveSize(): void {\n    const options = this.options;\n    const horizontal = options.horizontal;\n    const currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    let sizeToApply: number;\n    if (options.adaptive) {\n      const panelBbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panelManager.originalPanels().reduce((maximum, panel) => {\n        const panelBbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const viewportElement = this.viewportElement;\n    const wrapper = viewportElement.parentElement;\n\n    wrapper!.removeChild(viewportElement);\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    this.panelManager.originalPanels().forEach(panel => {\n      wrapper!.appendChild(panel.getElement());\n      panel.destroy();\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const cameraElement = this.cameraElement;\n    const panelManager = this.panelManager;\n\n    // Restore index\n    panelManager.clear();\n    cameraElement.innerHTML = status.panels.map(panel => panel.html).join(\"\");\n\n    this.createPanels();\n    this.currentPanel = panelManager.get(status.index);\n\n    // Reset panel index\n    panelManager.originalPanels().forEach((panel, idx) => {\n      panel.setIndex(panels[idx].index);\n    });\n\n    this.resize();\n\n    this.axes.setTo({ flick: status.position }, 0);\n    this.moveCamera(status.position);\n  }\n\n  public getCurrentPanel(): Panel | undefined {\n    return this.currentPanel;\n  }\n\n  public getCurrentIndex(): number {\n    const currentPanel = this.currentPanel;\n\n    return currentPanel\n      ? currentPanel.getIndex()\n      : -1;\n  }\n\n  public getNearestPanel(): Panel | undefined {\n    return this.nearestPanel;\n  }\n\n  // Get progress from nearest panel\n  public getCurrentProgress(): number {\n    let nearestPanel = this.nearestPanel;\n    const panelManager = this.panelManager;\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n    const {prev: prevRange, next: nextRange} = this.getScrollArea();\n    const cameraPosition = this.getCameraPosition();\n    const isOutOfBound = this.isOutOfBound();\n    let prevPanel = nearestPanel.prevSibling;\n    let nextPanel = nearestPanel.nextSibling;\n    let hangerPosition = this.getHangerPosition();\n    let nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (\n      isOutOfBound\n      && prevPanel\n      && nextPanel\n      && cameraPosition < nextRange\n      // On the basis of anchor, prevPanel is nearestPanel.\n      && (hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition)\n    ) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n    const nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    const nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      const relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n    const hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    const gap = this.options.gap;\n\n    let basePosition = nearestAnchorPos;\n    let targetPosition = nearestAnchorPos;\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel\n        ? nextPanel.getAnchorPosition()\n        : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel\n        ? prevPanel.getAnchorPosition()\n        : basePosition = nearestAnchorPos - nearestSize - gap;\n    }\n\n    const progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    const startIndex = hangerIsNextToNearestPanel\n      ? nearestIndex\n      : prevPanel\n        ? prevPanel.getIndex()\n        : nearestIndex - 1;\n\n    return startIndex + progressBetween;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n  public isOutOfBound(): boolean {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n\n    return !this.options.circular\n      && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  }\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getRelativeHangerPosition(): number {\n    return this.state.relativeHangerPosition;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.position + this.state.relativeHangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public setLastIndex(index: number): void {\n    const currentPanel = this.currentPanel;\n    const panelManager = this.panelManager;\n\n    panelManager.setLastIndex(index);\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  }\n\n  public connectAxesHandler(handlers: {[key: string]: (event: { [key: string]: any; }) => any}): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  }\n\n  public castToFlickingPanel = (panel: Panel, offset = 0): FlickingPanel => {\n    const viewport = this;\n    const options = viewport.options;\n\n    return {\n      getElement() {\n        return panel.getElement();\n      },\n      getIndex() {\n        return panel.getIndex();\n      },\n      getPosition() {\n        return panel.getPosition() + offset;\n      },\n      getAnchorPosition() {\n        return this.getPosition() + panel.getRelativeAnchorPosition();\n      },\n      getSize() {\n        return panel.getSize();\n      },\n      getProgress() {\n        let progress: number = NaN;\n\n        const nearestPanel = viewport.getNearestPanel();\n        if (nearestPanel) {\n          // single\n          const panelCount = viewport.panelManager.getPanelCount();\n          const scrollAreaSize = viewport.getScrollAreaSize();\n          const relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n\n          progress = relativeIndex - viewport.getCurrentProgress();\n        }\n        return progress;\n      },\n      getOutsetProgress(this: FlickingPanel) {\n        let outsetProgress: number = NaN;\n\n        const nearestPanel = viewport.getNearestPanel();\n        if (nearestPanel) {\n          const outsetRange = [\n            -this.getSize(),\n            viewport.getRelativeHangerPosition() - panel.getRelativeAnchorPosition(),\n            viewport.getSize(),\n          ];\n          const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n\n          outsetProgress = getProgress(relativePanelPosition, outsetRange);\n        }\n\n        return outsetProgress;\n      },\n      getVisibleRatio(this: FlickingPanel) {\n        let visibleRatio = 0;\n\n        const panelSize = panel.getSize();\n        const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n        const rightRelativePanelPosition = relativePanelPosition + panelSize;\n        const visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n\n        visibleRatio = visibleSize >= 0\n          ? visibleSize / panelSize\n          : 0;\n\n        return visibleRatio;\n      },\n      focus(this: FlickingPanel, duration?: number): void {\n        const currentPanel = viewport.getCurrentPanel();\n        const hangerPosition = viewport.getHangerPosition();\n        const anchorPosition = panel.getAnchorPosition();\n        if (hangerPosition === anchorPosition || !currentPanel) {\n          return;\n        }\n\n        const currentPosition = currentPanel.getPosition();\n        viewport.moveTo(panel, currentPosition === this.getPosition() ? EVENTS.NONE : EVENTS.CHANGE, null, offset, duration);\n      },\n      update(this: FlickingPanel, updateFunction: (element: HTMLElement) => any): void {\n        panel.getIdenticalPanels()\n          .forEach(eachPanel => updateFunction(eachPanel.getElement()));\n      },\n      prev(this: FlickingPanel): FlickingPanel | null {\n        const prevSibling = panel.prevSibling;\n\n        if (!prevSibling) {\n          return null;\n        }\n\n        const currentIndex = this.getIndex();\n        const prevIndex = prevSibling.getIndex();\n\n        const hasEmptyPanelBetween = currentIndex - prevIndex > 1;\n        const notYetMinPanel = options.infinite\n          && currentIndex > 0\n          && prevIndex > currentIndex;\n\n        if (hasEmptyPanelBetween || notYetMinPanel) {\n          // Empty panel exists between\n          return null;\n        }\n\n        const prevPanelSize = prevSibling.getSize();\n        const newPosition = this.getPosition() - prevPanelSize - options.gap;\n        const newOffset = newPosition - prevSibling.getPosition();\n\n        return viewport.castToFlickingPanel(prevSibling, newOffset);\n      },\n      next(this: FlickingPanel): FlickingPanel | null {\n        const nextSibling = panel.nextSibling;\n        const lastIndex = viewport.panelManager.getLastIndex();\n\n        if (!nextSibling) {\n          return null;\n        }\n\n        const currentIndex = this.getIndex();\n        const nextIndex = nextSibling.getIndex();\n\n        const hasEmptyPanelBetween = nextIndex - currentIndex > 1;\n        const notYetMaxPanel = options.infinite\n          && currentIndex < lastIndex\n          && nextIndex < currentIndex;\n\n        if (hasEmptyPanelBetween || notYetMaxPanel) {\n          return null;\n        }\n\n        const newPosition = this.getPosition() + panel.getSize() + options.gap;\n        const newOffset = newPosition - nextSibling.getPosition();\n\n        return viewport.castToFlickingPanel(nextSibling, newOffset);\n      },\n      insertBefore(this: FlickingPanel, element: ElementLike | ElementLike[]): FlickingPanel[] {\n        const parsedElements = parseElement(element);\n        const firstPanel = viewport.panelManager.firstPanel()!;\n        const prevSibling = panel.prevSibling;\n        // Finding correct inserting index\n        // While it should insert removing empty spaces,\n        // It also should have to be bigger than prevSibling' s index\n        const targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex()\n          ? Math.max(prevSibling.getIndex() + 1, panel.getIndex() - parsedElements.length)\n          : Math.max(panel.getIndex() - parsedElements.length, 0);\n\n        return viewport.insert(targetIndex, parsedElements);\n      },\n      insertAfter(this: FlickingPanel, element: ElementLike | ElementLike[]): FlickingPanel[] {\n        return viewport.insert(panel.getIndex() + 1, element);\n      },\n      remove(this: FlickingPanel): FlickingPanel {\n        return viewport.remove(panel.getIndex())[0];\n      },\n    };\n  }\n\n  private build(): void {\n    this.applyCSSValue();\n    this.setAxesInstance();\n    this.createPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const classPrefix = options.classPrefix;\n\n    // Set default css values for each element\n    viewportElement.className = `${classPrefix}-viewport`;\n    cameraElement.className = `${classPrefix}-camera`;\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private createPanels(): void {\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n\n    // Initialize panels\n    const panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this.options),\n    );\n\n    if (panels.length > 0) {\n      this.panelManager.append(panels);\n    }\n  }\n\n  private setDefaultPanel(): void {\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const indexRange = this.panelManager.getRange();\n    const index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n\n    this.currentPanel = panelManager.get(index);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const panelManager = this.panelManager;\n\n    const viewportSize = state.size;\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n\n    // There're no panels exist\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + this.options.gap;\n    const visibleAreaSize = viewportSize + firstPanel.getRelativeAnchorPosition();\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const panels = panelManager.originalPanels();\n\n    const cloneCount = Math.ceil(visibleAreaSize / sumOriginalPanelSize);\n    const prevCloneCount = panelManager.getCloneCount();\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        const clones = panels.map(origPanel => {\n          const clonedPanel = origPanel.clone(cloneIndex);\n\n          this.cameraElement.appendChild(clonedPanel.getElement());\n          return clonedPanel;\n        });\n        panelManager.insertClones(cloneIndex, 0, clones);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const indexRange = this.panelManager.getRange();\n\n    const defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    const defaultPanel = panelManager.get(defaultIndex);\n\n    let defaultPosition = 0;\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode()\n        ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n        : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const lastPanel = this.panelManager.lastPanel();\n    if (!lastPanel) {\n      return false;\n    }\n\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const panels = this.panelManager.originalPanels();\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n      viewportElement.style.minWidth = \"\";\n    }\n\n    const bbox = viewportElement.getBoundingClientRect();\n\n    // Update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n    state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n\n    // Resize all panels\n    panels.forEach(panel => {\n      panel.resize();\n    });\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panelManager = this.panelManager;\n\n    const firstPanel = panelManager.firstPanel();\n    const panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const currentPanel = this.currentPanel!;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = firstPanel.getPosition();\n    let maintainingPanel: Panel = firstPanel;\n    if ((currentState.holding || currentState.playing) && nearestPanel) {\n      // We should maintain nearestPanel's position\n      const currentIndex = currentPanel.getIndex()\n        + (currentPanel.getCloneIndex() + 1) * panels.length;\n      const nearestIndex = nearestPanel.getIndex()\n        + (nearestPanel.getCloneIndex() + 1) * panels.length;\n      const looped = (currentIndex >= nearestIndex && currentState.delta > 0)\n        || (currentIndex <= nearestIndex && currentState.delta < 0);\n\n      maintainingPanel = looped\n        ? currentPanel\n        : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    const panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    const accumulatedSize = panelsBeforeMaintainPanel.reduce((total, panel) => {\n      return total + panel.getSize() + gap;\n    }, 0);\n\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n\n    panels.forEach(panel => {\n      const newPosition = nextPanelPos;\n      const currentPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n\n      if (currentPosition !== newPosition) {\n        panel.setPosition(newPosition);\n      }\n      nextPanelPos += panelSize + gap;\n    });\n  }\n\n  private updateClonedPanelPositions(): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const clonedPanels = panelManager.clonedPanels()\n      .filter(panel => !!panel);\n\n    const scrollArea = state.scrollArea;\n\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      if (!panel) {\n        continue;\n      }\n\n      const origPanel = panel.getOriginalPanel();\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n    const relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0,\n      };\n    } else if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    const flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  }\n\n  // Update camera position after resizing\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const axes = this.axes;\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.stateMachine.getState();\n\n    if (!currentPanel || currentState.holding || currentState.playing) {\n      return;\n    }\n\n    let newPosition = currentPanel.getAnchorPosition() - state.relativeHangerPosition;\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n    this.axes.off();\n    axes.setTo({\n      flick: newPosition,\n    }, 0);\n    this.axes.on(this.axesHandlers);\n    this.moveCamera(newPosition);\n  }\n\n  private checkNeedPanel(axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentPanel = this.currentPanel;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    const gap = options.gap;\n    const infiniteThreshold = state.infiniteThreshold;\n    const maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent,\n        index: 0,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1,\n        },\n      });\n      return;\n    }\n\n    const originalNearestPosition = nearestPanel.getPosition();\n\n    // Check next direction\n    let checkingPanel: Panel | null = !currentState.holding && !currentState.playing\n      ? currentPanel\n      : nearestPanel;\n    while (checkingPanel) {\n      const currentIndex = checkingPanel.getIndex();\n      const nextSibling = checkingPanel.nextSibling;\n      let lastPanel = panelManager.lastPanel()!;\n      let atLastPanel = currentIndex === lastPanel.getIndex();\n      const nextIndex = !atLastPanel && nextSibling\n        ? nextSibling.getIndex()\n        : maxLastIndex + 1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      const cameraNext = state.position + state.size;\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = (nextIndex - currentIndex > 1);\n      // Expected prev panel's left position is smaller than camera position\n      const overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          index: checkingPanel.getIndex(),\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at max panel index\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        const firstPanel = panelManager.firstPanel()!;\n        const firstIndex = firstPanel.getIndex();\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent,\n            index: checkingPanel.getIndex(),\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether insertion happened\n      lastPanel = panelManager.lastPanel()!;\n      atLastPanel = currentIndex === lastPanel.getIndex();\n\n      if (atLastPanel || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    }\n\n    // Check prev direction\n    checkingPanel = nearestPanel;\n    while (checkingPanel) {\n      const cameraPrev = state.position;\n      const checkingIndex = checkingPanel.getIndex();\n      const prevSibling = checkingPanel.prevSibling;\n      let firstPanel = panelManager.firstPanel()!;\n      let atFirstPanel = checkingIndex === firstPanel.getIndex();\n      const prevIndex = !atFirstPanel && prevSibling\n        ? prevSibling.getIndex()\n        : -1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition);\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = checkingIndex - prevIndex > 1;\n      // Expected prev panel's right position is smaller than camera position\n      const overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          index: checkingPanel.getIndex(),\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at panel 0\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        const lastPanel = panelManager.lastPanel()!;\n        const lastIndex = lastPanel.getIndex();\n\n        if (lastIndex < maxLastIndex) {\n          this.triggerNeedPanel({\n            axesEvent,\n            index: checkingPanel.getIndex(),\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether insertion happened\n      firstPanel = panelManager.firstPanel()!;\n      atFirstPanel = checkingIndex === firstPanel.getIndex();\n\n      // Looped in circular mode\n      if (atFirstPanel || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  }\n\n  private triggerNeedPanel(params: {\n    axesEvent: any;\n    index: number;\n    siblingPanel?: Panel,\n    direction: FlickingEvent[\"direction\"];\n    indexRange: NeedPanelEvent[\"range\"];\n  }): void {\n    const { axesEvent, index, siblingPanel, direction, indexRange } = params;\n    const checkedIndexes = this.state.checkedIndexes;\n    const alreadyTriggered = checkedIndexes.some(([min, max]) => min === indexRange.min || max === indexRange.max);\n    const hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    }\n\n    // Should done before triggering event, as we can directly add panels by event callback\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const panel = siblingPanel\n      ? this.castToFlickingPanel(siblingPanel)\n      : null;\n\n    this.triggerEvent(\n      EVENTS.NEED_PANEL,\n      axesEvent,\n      isTrusted,\n      {\n        index,\n        panel,\n        direction,\n        range: indexRange,\n      } as NeedPanelEvent,\n    );\n  }\n}\n","import Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\n\nimport { merge, getProgress, toArray, parseElement, isString } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE, DEFAULT_MOVE_TYPE_OPTIONS } from \"./consts\";\nimport { FlickingOptions, FlickingEvent, Direction, EventType, FlickingPanel, TriggerCallback, FlickingContext, FlickingStatus, Plugin, ElementLike } from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"9+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>  Cheat Sheet {@link http://easings.net/}</ko>\n * @throws {Error} An Error occur when given base element doesn't exist or it hasn't proper DOM structure to be initialized. <ko>        DOM    .</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko  \n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko   - \"PREV\"  \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event types\n   * @ko     \n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n  private plugins: Plugin[] = [];\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking    . `string`      css    .</ko>\n   * @param options The option object of the eg.Flicking module<ko>eg.Flicking   </ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix for class names of the panels, viewport and camera.<ko> ,    .</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation where acceleration is manually enabled by user. Higher value means shorter running time.<ko>       .      .</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>  . (true: , false: )</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for infinite scrolling<ko>  .          .</ko>\n   * @param {number} [options.threshold=40] Movement threshold to destination panel(unit: pixel). A panel element must be dragged beyond the threshold to move to the destination panel.<ko>    (: ).         .</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement. (unit: ms)<ko>    .(: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] The easing function to apply to a panel moving animation. The default function is easeOutCubic.<ko>    `easing`.  `easeOutCubic`.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing the module. A zero-based integer.<ko>     , 0  .</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput Reference})<br>- \"touch\": A touch input device.<br>- \"mouse\": A mouse.<ko>  . ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput })<br>- \"touch\":   .<br>- \"mouse\": .</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold value that determines whether user input is horizontal or vertical. (0 ~ 90)<ko>         (0 ~ 90)</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`<ko>  . `circular=false`    .</ko>\n   * @param {Boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>      (horizontal)/(vertical)   /  .</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element<ko>  z-index </ko>\n   * @param {boolean} [options.bound=false] Prevents view going out of first/last panel. Only can be enabled when `circular=false`.<ko>       . `circular=false`    .</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`   `overflow: hidden`  .</ko>\n   * @param {string} [options.hanger=\"50%\"] Position of hanger in viewport, which hangs panel anchors.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>   .       .<br>px,    %   ,  +  -     .<br>) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>   .           .<br>px,    %   ,  +  -     .<br>) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space between each panels.<br>Should be given in number(px).<ko>     (px)</ko>\n   * @param {number} [options.snap=1] The number of panels you're going to roll over to when you snap<ko>            </ko>\n   * @param {boolean} [options.freeScroll=false] If true, panels can scroll freely when flicked.<ko>         .</ko>\n   */\n  constructor(\n    element: ElementLike,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Override moveType option\n    const currentOptions = this.options;\n    const moveType = currentOptions.moveType;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType as keyof typeof DEFAULT_MOVE_TYPE_OPTIONS];\n    }\n    this.build();\n  }\n  /**\n   * Move to the previous panel. If `horizontal=true`is left panel. If `horizontal=false`is upper panel.\n   * @ko   . `horizontal=true`  . `horizontal=false`  .\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>    (: ms)</ko>\n   * @return An instance of a module itself <ko>  </ko>\n   */\n  public prev(duration?: number): this {\n    const options = this.options;\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const currentIndex = viewport.getCurrentIndex();\n    const indexRange = panelManager.getRange();\n    const panelCount = panelManager.getPanelCount();\n    const lastIndex = panelManager.getLastIndex();\n    const minimumRange = options.infinite\n      ? 0\n      : indexRange.min;\n    let prevIndex = currentIndex - 1;\n\n    if (prevIndex < minimumRange) {\n      prevIndex = this.options.circular && panelCount > 0\n        ? options.infinite\n          ? lastIndex\n          : indexRange.max\n        : -1;\n    }\n\n    return this.moveTo(prevIndex, duration);\n  }\n\n  /**\n   * Move to the next panel. If `horizontal=true`is right panel. If `horizontal=false`is lower panel.\n   * @ko   . `horizontal=true`  . `horizontal=false`  .\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>    (: ms)</ko>\n   * @return An instance of a module itself <ko>  </ko>\n   */\n  public next(duration?: number): this {\n    const options = this.options;\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const currentIndex = viewport.getCurrentIndex();\n    const indexRange = panelManager.getRange();\n    const panelCount = panelManager.getPanelCount();\n    const lastIndex = panelManager.getLastIndex();\n    const maximumRange = options.infinite\n      ? lastIndex\n      : indexRange.max;\n    let nextIndex = currentIndex + 1;\n\n    if (nextIndex > maximumRange) {\n      nextIndex = options.circular && panelCount > 0\n        ? options.infinite\n          ? 0\n          : indexRange.min\n        : -1;\n    }\n\n    return this.moveTo(nextIndex, duration);\n  }\n\n  /**\n   * Moves to the panel in the order specified in `index`. If `index` is equal to selected panel's index, no action is taken.\n   * @ko `index`    . `index`     ,    .\n   * @param index The index number of the panel to be moved.<ko>   .</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement (unit: ms) <ko>    (: ms)</ko>\n   * @return An instance of a module itself <ko>  </ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    const state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = viewport.getHangerPosition();\n\n    let offset = 0;\n    if (this.options.circular) {\n      const scrollAreaSize = viewport.getScrollAreaSize();\n      // Check all three possible locations, find the nearest position among them.\n      const possiblePositions = [\n        anchorPosition - scrollAreaSize,\n        anchorPosition,\n        anchorPosition + scrollAreaSize,\n      ];\n      const nearestPosition = possiblePositions.reduce((nearest, current) => {\n        return (Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition))\n          ? current\n          : nearest;\n      }, Infinity);\n\n      offset = nearestPosition - anchorPosition;\n    }\n    const currentIndex = this.getIndex();\n\n    if (hangerPosition === anchorPosition + offset && currentIndex === index) {\n      return this;\n    }\n\n    const eventType = panel.getIndex() === viewport.getCurrentIndex()\n      ? EVENTS.NONE\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      panel,\n      eventType,\n      null,\n      offset,\n      duration,\n    );\n    return this;\n  }\n\n  /**\n   * Returns the index number of the selected panel.\n   * @ko      .\n   * @return Zero-based index number of the current panel element.<ko>   . 0  .</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getCurrentIndex();\n  }\n\n  /**\n   * Returns the wrapper element user provided in Flicking constructor.\n   * @ko      .\n   * @return Wrapper element user provided.<ko>   </ko>\n   */\n  public getElement(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Returns the selected panel object\n   * @ko     .\n   * @return Selected panel object.<ko>  </ko>\n   */\n  public getCurrentPanel(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel();\n    return panel\n      ? viewport.castToFlickingPanel(panel)\n      : null;\n  }\n\n  /**\n   * Returns the panel object of given index\n   * @ko      .\n   * @return panel object of given index, `null` if it doesn't exists.<ko>    ,      `null`.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    return panel\n      ? viewport.castToFlickingPanel(panel)\n      : null;\n  }\n  /**\n   * Returns all panel objects in flicking.\n   * @ko       .\n   * @param - Check whether to include clone or not <ko>      </ko>\n   * @return All panel objects <ko>     </ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const panels = includeClone\n      ? panelManager.allPanels()\n      : panelManager.originalPanels();\n\n    return panels\n      .filter(panel => !!panel)\n      .map(panel => viewport.castToFlickingPanel(panel));\n  }\n  /**\n   * Returns the panel objects shown in the flicking area.\n   * @ko      .\n   * @return The panel objects shown in the flicking area. <ko>    </ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.getAllPanels(true).filter(panel => {\n      const outsetProgress = panel.getOutsetProgress();\n\n      return outsetProgress > -1 && outsetProgress < 1;\n    });\n  }\n  /**\n   * Returns the total length of original panels\n   * @ko    .\n   * @return Length of original panels.<ko>  </ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.panelManager.getPanelCount();\n  }\n\n  /**\n   * Set last panel index for `infinite' mode. [needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it. Also, you can't add more panels after it.\n   * @ko `infinite`      .          [needPanel]{@link eg.Flicking#events:needPanel}   . ,        .\n   * @param - Last panel index.\n   * @see {@link eg.Flicking.FlickingOptions}\n   */\n  public setLastIndex(index: number): void {\n    this.viewport.setLastIndex(index);\n  }\n\n  /**\n   * Checks whether the animated panel is playing.\n   * @ko      .\n   * @return Indicates whether the animated panel is playing <ko>     </ko>\n   */\n  public isPlaying(): boolean {\n    return this.viewport.stateMachine.getState().playing;\n  }\n\n  /**\n   * The input from the input device is not blocked so that the panel can be moved by the input device.\n   * @ko     .\n   * @return  An instance of a module itself <ko>  </ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * The input from the input device is blocked so that the panel is not moved by the input device.\n   * @ko          .\n   * @return An instance of a module itself <ko>  </ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Get current flicking status. If the returned value is specified as a [setStatus()]{@link eg.Flicking#setStatus} method argument, it can be returned to its value status.\n   * @ko    .   [setStatus()]{@link eg.Flicking#setStatus}         .\n   * @return An object with current status value information.<ko>    .</ko>\n   */\n  public getStatus(): Readonly<FlickingStatus> {\n    const viewport = this.viewport;\n\n    const panels = viewport.panelManager.originalPanels()\n      .filter(panel => !!panel)\n      .map(panel => {\n        return {\n          html: panel.getElement().outerHTML,\n          index: panel.getIndex(),\n        };\n      });\n\n    return {\n      index: viewport.getCurrentIndex(),\n      panels,\n      position: viewport.getCameraPosition(),\n    };\n  }\n\n  /**\n   * Restore to the state of the `status`.\n   * @ko `status`  .\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>  . [getStatus()]{@link eg.Flicking#getStatus}   .</ko>\n   */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko        .\n   * @param - The plugin(s) to add <ko> ()</ko>\n   * @return An instance of a module itself <ko>  </ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n  /**\n   * Remove plugins from Flicking\n   * @ko   .\n   * @param - The plugin(s) to remove <ko> ()</ko>\n   * @return An instance of a module itself <ko>  </ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(this);\n    });\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko         .     .   ( ) `null` .\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    this.plugins.forEach(plugin => {\n      plugin.destroy(this);\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * The horizontal or vertical length of the panel is updated according to the base element. If `horizontal=true` is horizontal. If `horizontal=false` is vertical.\n   * @ko        . `horizontal=true` , `horizontal=false` .\n   * @return An instance of a module itself<ko>  </ko>\n   */\n  public resize(): this {\n    const viewport = this.viewport;\n\n    viewport.panelManager.allPanels()\n      .forEach(panel => panel.reset());\n    viewport.resize();\n\n    return this;\n  }\n\n  /**\n   * Add new panel at the start.\n   * @ko     .\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement  HTML ,    .<br>,  depth     HTML  .</ko>\n   * @return Array of appended panels.<ko>  </ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\n   */\n  public prepend(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n\n    const insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    return viewport.insert(insertingIndex, parsedElements);\n  }\n\n  /**\n   * Add new panel at the end.\n   * @ko     .\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement  HTML ,    .<br>,  depth     HTML  .</ko>\n   * @return Array of appended panels.<ko>  </ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\n   */\n  public append(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n\n    return viewport.insert(viewport.panelManager.getRange().max + 1, element);\n  }\n\n  /**\n   * Replace panels with new panels from given index. If index is empty, add new panel at target index.\n   * @ko      .    ,     .\n   * @param index - Start index to replace new panels.<ko>    </ko>\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement  HTML ,    .<br>,  depth     HTML  .</ko>\n   * @return Array of created panels by replace.<ko>    </ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   *\n   * // This will add new panel at index 3,\n   * // Index 0, 1, 2 is empty at this moment.\n   * // [empty, empty, empty, PANEL]\n   * flicking.replace(3, document.createElement(\"div\"));\n   *\n   * // As index 2 was empty, this will also add new panel at index 2.\n   * // [empty, empty, PANEL, PANEL]\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\n   *\n   * // Index 3 was not empty, so it will replace previous one.\n   * // It will also add new panels at index 4 and 5.\n   * // before - [empty, empty, PANEL, PANEL]\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\n   */\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.replace(index, element);\n  }\n\n  /**\n   * Remove panel at target index. This will decrease index of panels behind it.\n   * @ko `index`    .  `index`    .\n   * @param index - Index of panel to remove.<ko>  </ko>\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index`    .</ko>\n   * @return Array of removed panels<ko>  </ko>\n   */\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    return this.viewport.remove(index, deleteCount);\n  }\n\n  private build(): void {\n    this.initViewport();\n    this.listenInput();\n    this.listenResize();\n  }\n\n  private initViewport(): void {\n    const wrapper = this.wrapper;\n    const options = this.options;\n    const cameraElement = document.createElement(\"div\");\n\n    // Make all panels to be a child of camera element\n    // wrapper <- viewport <- camera <- panels[1...n]\n    toArray(wrapper.children).forEach(child => {\n      cameraElement.appendChild(child);\n    });\n\n    // Clipping area for camera element\n    const viewportElement = document.createElement(\"div\");\n    viewportElement.appendChild(cameraElement);\n\n    // Add viewport element to wrapper\n    wrapper.appendChild(viewportElement);\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(this, viewportElement, cameraElement, options, this.triggerEvent);\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const viewport = flicking.viewport;\n    const stateMachine = viewport.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", () => {\n        this.resize();\n      });\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n\n    let canceled: boolean = true;\n\n    // Ignore events before viewport is initialized\n    if (viewport) {\n      const state = viewport.stateMachine.getState();\n      const { prev, next } = viewport.getScrollArea();\n      const pos = viewport.getCameraPosition();\n      let progress = getProgress(pos, [prev, prev, next]);\n\n      if (this.options.circular) {\n        progress %= 1;\n      }\n      canceled = !super.trigger(eventName, merge({\n        type: eventName,\n        index: this.getIndex(),\n        panel: this.getCurrentPanel(),\n        direction: state.direction,\n        holding: state.holding,\n        progress,\n        axesEvent,\n        isTrusted,\n      }, params));\n    }\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = viewport.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n    const previousPosition = viewport.getCameraPosition();\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNextDirection = inputOffset < 0;\n\n      let cameraChange = pos - previousPosition;\n      const looped = isNextDirection === (pos < previousPosition);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = -Math.sign(cameraChange) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.delta += cameraChange;\n      state.direction = currentDirection;\n    }\n\n    viewport.moveCamera(pos, axesEvent);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted)\n      .onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n  }\n}\n\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","element","Array","isArray","elements","el","isString","tempDiv","document","createElement","innerHTML","push","toArray","children","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","cssObj","property","val","min","max","Math","iterable","slice","call","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","callback","i","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","DEFAULT_VIEWPORT_CSS","position","width","height","DEFAULT_CAMERA_CSS","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","NONE","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","DIRECTION","PREV","NEXT","TRANSFORM","index","options","className","prevSibling","nextSibling","state","relativeAnchorPosition","size","clonedPanels","isClone","cloneIndex","originalStyle","getAttribute","cachedBbox","classList","add","indexOf","replace","applyCSS","this","bbox","getBbox","parseArithmeticExpression","panel","resize","setAttribute","removeAttribute","getBoundingClientRect","original","getClonedPanels","getIdenticalPanels","elementStyle","left","top","clonedPanel","Panel","cloneNode","clonedState","parentNode","removeClonedPanelsAfter","start","splice","remove","cameraElement","panels","clones","reduce","allClones","firstPanel","lastPanel","getIndex","removingPanels","possibleLastPanel","filter","newPanels","_a","isCircular","findFirstPanelFrom","siblingElement","getElement","fragment","createDocumentFragment","appendChild","pushedIndex","offset","panelsAfterIndex","emptyPanelCount","findIndex","removedPanels","Boolean","setIndex","addNewClones","updateIndex","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","cloneSet","nonEmptyIndexFromLast","concat","reverse","allPanels","allPanelsCount","prevPanel","nextPanel","insertTarget_1","newClones_1","allPanels_1","contains","originalPanels","cloneCount","getCloneCount","lastPanelClones","nextSiblingClones","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","newClones","map","clone","this_1","insertClones","counterArray","counter","insertingIndex","newLastIndex","prevState","delta","direction","targetPanel","targetOffset","nextState","e","context","_this","tslib_1","flicking","triggerEvent","transitTo","getPanelCount","onSuccess","onStopped","onChange","State","inputEvent","offsetX","offsetY","viewport","flick","setTo","getCameraPosition","releaseEvent","clickedElement","srcEvent","clickedPanel","panelManager","findPanelOf","cameraPosition","clickedPanelPosition","getPosition","castToFlickingPanel","_super","onEnter","moveCamera","stopCamera","defaultDuration","halfGap","isFreeScroll","snapCount","eventDelta","abs","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","moveTo","currentPanel","getCurrentPanel","nearestPanel","getNearestPanel","stop","minimumDistanceToChange","getSize","getRelativeAnchorPosition","panelToMove","basePanel","findNearestIdenticalPanel","panelAtDestPos","snapOffset","indexDiff","isOutOfBound","findAdjacentPanel","findRestorePanelInCircularMode","movingToSamePanel","eventType","hangerPosition","getHangerPosition","firstClonedPanel","lapped","getAnchorPosition","params","scrollAreaSize","getScrollAreaSize","indexRange","getRange","estimatedHangerPos","destPos","getRelativeHangerPosition","passedPanelCount","cycleIndex","getCloneIndex","siblingPanel","panelIndex","siblingIndex","originalPanel","getOriginalPanel","panelPosition","panelSize","originalPosition","currentIndex","getCurrentIndex","get","adjacentPanel","isTrusted","updateAdaptiveSize","IdleState","nextStateType","currentState","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onHold","onRelease","onAnimationEnd","onFinish","viewportElement","axesEvent","stateMachine","getProgress","progress","NaN","panelCount","floor","getCurrentProgress","getOutsetProgress","outsetProgress","outsetRange","getVisibleRatio","relativePanelPosition","rightRelativePanelPosition","visibleSize","focus","currentPosition","update","updateFunction","eachPanel","prev","prevIndex","hasEmptyPanelBetween","notYetMinPanel","prevPanelSize","newOffset","next","getLastIndex","nextIndex","notYetMaxPanel","parsedElements","parseElement","targetIndex","insert","insertAfter","relativeHangerPosition","scrollArea","translate","checkedIndexes","StateMachine","PanelManager","build","getState","castedPanel","estimatedPosition","canSetBoundMode","eventResult","findNearestPanel","axes","originalNearestPosition","checkNeedPanel","moveCoord","coord","round","join","updateSize","updateOriginalPanelPositions","updateScrollArea","clonePanels","updateClonedPanelPositions","chainAllPanels","updateCameraPosition","prevRange","nextRange","currentAnchorPosition","findNearestPanelAt","minimumDistance","prevPosition","nextPosition","distance","isBetween","nearest","shortestDistance","identical","anchorPosition","panInput","enable","disable","indexes","newCurrentIndex","sizeToApply","panelBbox","maximum","viewportStyle","minHeight","minWidth","wrapper","destroy","status","clear","html","createPanels","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","basePosition","targetPosition","progressBetween","setLastIndex","handlers","axesHandlers","on","applyCSSValue","setAxesInstance","setDefaultPanel","moveToDefaultPanel","Axes","easing","interruptable","PanInput","scale","connect","append","viewportSize","sumOriginalPanelSize","visibleAreaSize","ceil","prevCloneCount","origPanel","removeClonesAfter","defaultPanel","defaultPosition","summedPanelSize","nextPanelPos","maintainingPanel","holding","playing","accumulatedSize","total","newPosition","setPosition","clonedPanels_1","clonedPanelPos","lastReplacePosition","_b","replacePosition","arr","parsedBounce","constructor","parsedVal","axis","off","maxLastIndex","checkingPanel","atLastPanel","currentNearestPosition","triggerNeedPanel","firstIndex","cameraPrev","checkingIndex","atFirstPanel","alreadyTriggered","some","hasHandler","hasOn","eventName","canceled","trigger","merge","previousPosition","inputOffset","cameraChange","looped","currentDirection","querySelector","nodeName","nodeType","currentOptions","current","includeClone","getAllPanels","outerHTML","restore","plugins","newPlugins","plugin","init","currentPlugins","reset","initViewport","listenInput","listenResize","child","Viewport","eventContext","fire","connectAxesHandler","addEventListener","Flicking","Component"],"mappings":"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"}