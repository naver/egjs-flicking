{"version":3,"file":"flicking.esm.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/PanelManager.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/components/Viewport.ts","../src/Flicking.ts"],"sourcesContent":["import { ElementLike } from \"./types\";\n\nexport function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\nexport function parseElement(element: ElementLike | ElementLike[]): HTMLElement[] {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n    } else {\n      elements.push(el as HTMLElement);\n    }\n  });\n\n  return elements;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function counter(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n","import { FlickingOptions, EventType, Direction, AxesEventType, StateType, MoveTypeSnapOption, MoveTypeFreeScrollOption } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const DEFAULT_MOVE_TYPE_OPTIONS: {\n  snap: MoveTypeSnapOption,\n  freeScroll: MoveTypeFreeScrollOption,\n} = {\n  snap: {\n    type: \"snap\",\n    count: 1,\n  },\n  freeScroll: {\n    type: \"freeScroll\",\n  },\n};\n\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  // willChange: \"transform\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  NONE: \"\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","import { OriginalStyle, FlickingOptions } from \"../types\";\nimport { DEFAULT_PANEL_CSS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression } from \"../utils\";\n\nclass Panel {\n  public prevSibling: Panel | null;\n  public nextSibling: Panel | null;\n\n  private element: HTMLElement;\n  private state: {\n    index: number;\n    position: number;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    clonedPanels: Panel[];\n    cachedBbox: ClientRect | null;\n  };\n  private options: FlickingOptions;\n  private original?: Panel;\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    options: FlickingOptions,\n  ) {\n    this.element = element;\n    this.prevSibling = null;\n    this.nextSibling = null;\n\n    this.state = {\n      index,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      clonedPanels: [],\n      isClone: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: element.getAttribute(\"class\") || null,\n        style: element.getAttribute(\"style\") || null,\n      },\n      cachedBbox: null,\n    };\n    this.options = options;\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n  }\n\n  public resize(): void {\n    const state = this.state;\n    const bbox = this.getBbox();\n\n    state.size = this.options.horizontal\n      ? bbox.width\n      : bbox.height;\n    state.relativeAnchorPosition = parseArithmeticExpression(this.options.anchor, state.size);\n\n    if (!state.isClone) {\n      state.clonedPanels.forEach(panel => panel.resize());\n    }\n  }\n\n  public reset(): void {\n    this.state.cachedBbox = null;\n  }\n\n  public destroy(): void {\n    const el = this.element;\n    const originalStyle = this.state.originalStyle;\n\n    originalStyle.className\n      ? el.setAttribute(\"class\", originalStyle.className)\n      : el.removeAttribute(\"class\");\n    originalStyle.style\n      ? el.setAttribute(\"style\", originalStyle.style)\n      : el.removeAttribute(\"style\");\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getClonedPanels()\n      : state.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...state.clonedPanels];\n  }\n\n  public getOriginalPanel(): Panel {\n    return this.state.isClone\n      ? this.original!\n      : this;\n  }\n\n  public setIndex(index: number) {\n    const state = this.state;\n\n    state.index = index;\n    state.clonedPanels.forEach(panel => panel.state.index = index);\n  }\n\n  public setPosition(pos: number) {\n    const state = this.state;\n    const options = this.options;\n    const elementStyle = this.element.style;\n\n    state.position = pos;\n    options.horizontal\n      ? elementStyle.left = `${pos}px`\n      : elementStyle.top = `${pos}px`;\n  }\n\n  public clone(cloneIndex: number): Panel {\n    const state = this.state;\n\n    const cloneElement = this.element.cloneNode(true) as HTMLElement;\n    const clonedPanel = new Panel(cloneElement, state.index, this.options);\n    const clonedState = clonedPanel.state;\n\n    clonedPanel.original = this;\n    clonedState.isClone = true;\n    clonedState.cloneIndex = cloneIndex;\n    // Inherit some state values\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n    state.clonedPanels.push(clonedPanel);\n\n    return clonedPanel;\n  }\n\n  public remove(): void {\n    const element = this.element;\n    element.parentNode!.removeChild(element);\n\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const state = this.state;\n    const removingPanels = state.clonedPanels.splice(start);\n\n    removingPanels.forEach(panel => {\n      panel.remove();\n    });\n  }\n}\n\nexport default Panel;\n","import Panel from \"./Panel\";\nimport { FlickingOptions } from \"../types\";\nimport { findIndex, counter } from \"../utils\";\n\nclass PanelManager {\n  private cameraElement: HTMLElement;\n  private panels: Panel[];\n  private clones: Panel[][];\n  // index range of existing panels\n  private range: {\n    min: number;\n    max: number;\n  };\n  private length: number;\n  private lastIndex: number;\n  private options: FlickingOptions;\n\n  constructor(\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n    this.length = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  public firstPanel(): Panel | undefined {\n    return this.panels[this.range.min];\n  }\n\n  public lastPanel(): Panel | undefined {\n    return this.panels[this.range.max];\n  }\n\n  public allPanels(): ReadonlyArray<Panel> {\n    return [\n      ...this.panels,\n      ...this.clonedPanels(),\n    ];\n  }\n\n  public originalPanels(): ReadonlyArray<Panel> {\n    return this.panels;\n  }\n\n  public clonedPanels(): ReadonlyArray<Panel> {\n    return this.clones.reduce((allClones, clones) => [...allClones, ...clones], []);\n  }\n\n  public has(index: number): boolean {\n    return !!this.panels[index];\n  }\n\n  public get(index: number): Panel | undefined {\n    return this.panels[index];\n  }\n\n  public getPanelCount(): number {\n    return this.length;\n  }\n\n  public getLastIndex(): number {\n    return this.lastIndex;\n  }\n\n  public getRange(): Readonly<{ min: number, max: number }> {\n    return this.range;\n  }\n\n  public getCloneCount(): number {\n    return this.clones.length;\n  }\n\n  public setLastIndex(lastIndex: number): void {\n    this.lastIndex = lastIndex;\n\n    const firstPanel = this.firstPanel();\n    const lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    }\n\n    // Remove panels above new last index\n    const range = this.range;\n    if (lastPanel.getIndex() > lastIndex) {\n      const removingPanels = this.panels.splice(lastIndex + 1);\n      removingPanels.forEach(panel => panel.remove());\n      this.length -= removingPanels.length;\n\n      const firstRemovedPanel = removingPanels.filter(panel => !!panel)[0];\n      const possibleLastPanel = firstRemovedPanel.prevSibling;\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n    }\n  }\n\n  public append(newPanels: Panel[]): void {\n    const range = this.range;\n    this.panels.push(...newPanels);\n\n    if (newPanels.length > 0) {\n      range.min = Math.max(0, range.min);\n      range.max += newPanels.length;\n      this.length += newPanels.length;\n    }\n  }\n\n  // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n  public insert(index: number, newPanels: Panel[]): number {\n    const panels = this.panels;\n    const range = this.range;\n    const cameraElement = this.cameraElement;\n    const isCircular = this.options.circular;\n    const lastIndex = this.lastIndex;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    const fragment = document.createDocumentFragment();\n    newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n    cameraElement.insertBefore(fragment, siblingElement);\n\n    let pushedIndex = newPanels.length;\n    // Like when setting index 50 while visible panels are 0, 1, 2\n    if (index > range.max) {\n      newPanels.forEach((panel, offset) => {\n        panels[index + offset] = panel;\n      });\n    } else {\n      const panelsAfterIndex = panels.slice(index, index + newPanels.length);\n      // Find empty from beginning\n      let emptyPanelCount = findIndex(panelsAfterIndex, panel => !!panel);\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n      pushedIndex = newPanels.length - emptyPanelCount;\n\n      // Insert removing empty panels\n      panels.splice(index, emptyPanelCount, ...newPanels);\n\n      // Remove panels after last index\n      if (panels.length > lastIndex + 1) {\n        const removedPanels = panels.splice(lastIndex + 1)\n          .filter(panel => Boolean(panel));\n        removedPanels.forEach(panel => panel.remove());\n        this.length -= removedPanels.length;\n      }\n    }\n\n    // Update index of previous panels\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(panel => {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    }\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n    }\n\n    // Update state\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    return pushedIndex;\n  }\n\n  public replace(index: number, newPanels: Panel[]): void {\n    const panels = this.panels;\n    const range = this.range;\n    const cameraElement = this.cameraElement;\n    const isCircular = this.options.circular;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index + newPanels.length);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    const fragment = document.createDocumentFragment();\n    newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n    cameraElement.insertBefore(fragment, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      (panels[index] as any) = null;\n    }\n\n    const replacedPanels = panels.splice(index, newPanels.length, ...newPanels);\n    const wasNonEmptyCount = replacedPanels.filter(panel => Boolean(panel)).length;\n    replacedPanels.forEach(panel => {\n      if (panel) {\n        panel.remove();\n      }\n    });\n\n    // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n  }\n\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    const isCircular = this.options.circular;\n    const panels = this.panels;\n    const clones = this.clones;\n    // Delete count should be equal or larger than 0\n    deleteCount = Math.max(deleteCount, 0);\n\n    const deletedPanels = panels\n      .splice(index, deleteCount)\n      .filter(panel => !!panel);\n\n    deletedPanels.forEach(panel => {\n      panel.remove();\n    });\n\n    if (isCircular) {\n      clones.forEach(cloneSet => {\n        cloneSet.splice(index, deleteCount);\n      });\n    }\n\n    // Update indexes\n    panels\n      .slice(index)\n      .forEach(panel => {\n        panel.setIndex(panel.getIndex() - deleteCount);\n      });\n\n    // Check last panel is empty\n    let lastIndex = panels.length - 1;\n    if (!panels[lastIndex]) {\n      const reversedPanels = panels.concat().reverse();\n      const nonEmptyIndexFromLast = findIndex(reversedPanels, panel => !!panel);\n      lastIndex = nonEmptyIndexFromLast < 0\n        ? -1 // All empty\n        : lastIndex - nonEmptyIndexFromLast;\n\n      // Remove all empty panels from last\n      panels.splice(lastIndex + 1);\n      if (isCircular) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    }\n\n    // Update range & length\n    this.range = {\n      min: findIndex(panels, panel => !!panel),\n      max: lastIndex,\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n    }\n\n    return deletedPanels;\n  }\n\n  public chainAllPanels() {\n    const allPanels = this.allPanels().filter(panel => !!panel);\n    const allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 0) {\n      return;\n    }\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanelsCount - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n\n    if (this.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanelsCount - 1];\n\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  }\n\n  public insertClones(cloneIndex: number, index: number, clonedPanels: Panel[], deleteCount: number = 0): void {\n    const clones = this.clones;\n    const lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      const newClones: Panel[] = [];\n      clonedPanels.forEach((panel, offset) => {\n        newClones[index + offset] = panel;\n      });\n\n      clones[cloneIndex] = newClones;\n    } else {\n      const insertTarget = clones[cloneIndex];\n\n      if (index >= insertTarget.length) {\n        clonedPanels.forEach((panel, offset) => {\n          insertTarget[index + offset] = panel;\n        });\n      } else {\n        insertTarget.splice(index, deleteCount, ...clonedPanels);\n        // Remove panels after last index\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }\n\n  // clones are operating in set\n  public removeClonesAfter(cloneIndex: number): void {\n    const panels = this.panels;\n    panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  }\n\n  // Clear both original & cloned\n  public clear(): void {\n    this.panels.forEach(panel => {\n      panel.remove();\n      panel.removeClonedPanelsAfter(0);\n    });\n\n    this.panels = [];\n    this.clones = [];\n    this.length = 0;\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n  }\n\n  public clearClone(): void {\n    this.panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(0);\n    });\n    this.clones = [];\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    const allPanels = this.allPanels();\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findFirstPanelFrom(index: number): Panel | undefined {\n    for (const panel of this.panels) {\n      if (panel && panel.getIndex() >= index) {\n        return panel;\n      }\n    }\n  }\n\n  private addNewClones(index: number, originalPanels: Panel[], deleteCount: number, nextSibling: Panel | undefined) {\n    const cameraElement = this.cameraElement;\n    const cloneCount = this.getCloneCount();\n    const lastPanel = this.lastPanel();\n    const lastPanelClones: Panel[] = lastPanel\n      ? lastPanel.getClonedPanels()\n      : [];\n    const nextSiblingClones: Panel[] = nextSibling\n      ? nextSibling.getClonedPanels()\n      : [];\n\n    for (const cloneIndex of counter(cloneCount)) {\n      const cloneNextSibling = nextSiblingClones[cloneIndex];\n      const lastPanelSibling = lastPanelClones[cloneIndex];\n\n      const cloneSiblingElement = cloneNextSibling\n        ? cloneNextSibling.getElement()\n        : lastPanelSibling\n          ? lastPanelSibling.getElement().nextElementSibling\n          : null;\n\n      const newClones = originalPanels.map(panel => {\n        const clone = panel.clone(cloneIndex);\n\n        cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        return clone;\n      });\n\n      this.insertClones(cloneIndex, index, newClones, deleteCount);\n    }\n  }\n\n  private updateIndex(insertingIndex: number) {\n    const panels = this.panels;\n    const range = this.range;\n\n    const newLastIndex = panels.length - 1;\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  }\n}\n\nexport default PanelManager;\n","import Panel from \"../components/Panel\";\nimport { ValueOf, Direction, StateType, FlickingContext } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: Panel | null = null;\n  public targetOffset: number = 0;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.targetOffset = prevState.targetOffset;\n  }\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","import State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.targetOffset = 0;\n  }\n\n  public onHold(e: any, { flicking, triggerEvent, transitTo }: FlickingContext): void {\n    // Shouldn't do any action until any panels on flicking area\n    if (flicking.getPanelCount() <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't be handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const clickedElement = releaseEvent.inputEvent.srcEvent.target;\n    const clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        index: clickedPanel.getIndex(),\n        panel: viewport.castToFlickingPanel(clickedPanel),\n      });\n    }\n  }\n}\n\nexport default HoldingState;\n","import State from \"./State\";\nimport Panel from \"../components/Panel\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext, MoveTypeObjectOption, MoveTypeSnapOption } from \"../types\";\nimport { clamp } from \"../utils\";\nimport Viewport from \"../components/Viewport\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onEnter(prevState: State): void {\n    super.onEnter(prevState);\n    this.delta = 0;\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, transitTo, stopCamera } = context;\n\n    const delta = this.delta;\n    const options = flicking.options;\n    const horizontal = options.horizontal;\n    const defaultDuration = options.duration;\n    const halfGap = options.gap / 2;\n    const moveType = options.moveType as MoveTypeObjectOption;\n    const isFreeScroll = moveType.type === \"freeScroll\";\n    const snapCount = isFreeScroll ? Infinity : (moveType as MoveTypeSnapOption).count;\n    const inputEvent = e.inputEvent;\n    const eventDelta = Math.abs(e.delta.flick);\n\n    const velocity = horizontal\n      ? inputEvent.velocityX\n      : inputEvent.velocityY;\n    const inputDelta = Math.abs(horizontal ? inputEvent.deltaX : inputEvent.deltaY);\n    const isNextDirection = Math.abs(velocity) > 0\n      ? velocity < 0\n      : delta > 0;\n    const swipeDistance = Math.max(Math.abs(delta), inputDelta);\n    const swipeAngle = inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI)\n      : 90;\n    const belowAngleThreshold = horizontal\n      ? swipeAngle <= options.thresholdAngle\n      : swipeAngle > options.thresholdAngle;\n    const overThreshold = swipeDistance >= options.threshold\n      && belowAngleThreshold;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (!overThreshold && this.targetPanel) {\n      // Interrupted while animating\n      viewport.moveTo(this.targetPanel, EVENTS.NONE, e, this.targetOffset);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      e.stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |--------|--------------|\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\n     */\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanel.getSize() - currentPanel.getRelativeAnchorPosition() + halfGap\n      : currentPanel.getRelativeAnchorPosition() + halfGap;\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    let duration = defaultDuration;\n    let panelToMove: Panel;\n    let offset: number = 0;\n\n    if (overThreshold) {\n      if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n        const basePanel = isFreeScroll\n          ? nearestPanel\n          : viewport.findNearestIdenticalPanel(currentPanel);\n\n        // FreeScroll & snap\n        const { panelAtDestPos, snapOffset, indexDiff } = this.findPanelWhenSnapIsOn({\n          isNextDirection,\n          e,\n          viewport,\n          basePanel,\n        });\n\n        panelToMove = panelAtDestPos;\n        offset = snapOffset;\n        duration = clamp(e.duration, defaultDuration, defaultDuration * indexDiff);\n      } else if (\n        !isFreeScroll\n        && !viewport.isOutOfBound()\n        && (\n          swipeDistance <= minimumDistanceToChange\n          // It's the same if there's not enough distance.\n          || nearestPanel.getIndex() === currentPanel.getIndex()\n        )\n      ) {\n        panelToMove = this.findAdjacentPanel(isNextDirection, viewport);\n      } else {\n        panelToMove = nearestPanel;\n      }\n    } else {\n      panelToMove = options.circular\n        ? this.findRestorePanelInCircularMode(isNextDirection, viewport)\n        : currentPanel;\n    }\n\n    const panelPosition = panelToMove.getPosition() + offset;\n    const movingToSamePanel = panelPosition === currentPanel.getPosition();\n    const eventType = (!overThreshold || movingToSamePanel)\n      ? isFreeScroll\n        ? EVENTS.NONE\n        : EVENTS.RESTORE\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      panelToMove,\n      eventType,\n      e,\n      offset,\n      duration,\n    ).onSuccess(() => {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(() => {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  }\n\n  private findRestorePanelInCircularMode(isNextDirection: boolean, viewport: Viewport): Panel {\n    const currentPanel = viewport.getCurrentPanel()!;\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n      > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n    const panelToMove = (!isNextDirection && lapped)\n      ? firstClonedPanel\n      : currentPanel;\n\n    return panelToMove;\n  }\n\n  private findPanelWhenSnapIsOn(params: {\n    isNextDirection: boolean,\n    e: any,\n    viewport: Viewport,\n    basePanel: Panel,\n  }): {\n    panelAtDestPos: Panel,\n    snapOffset: number,\n    indexDiff: number,\n  } {\n    const { isNextDirection, e, viewport, basePanel } = params;\n\n    const options = viewport.options;\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const indexRange = viewport.panelManager.getRange();\n    const halfGap = options.gap / 2;\n    const estimatedHangerPos = e.destPos.flick + viewport.getRelativeHangerPosition();\n    const moveType = options.moveType as MoveTypeObjectOption;\n    const snapCount = moveType.type === \"freeScroll\" ? Infinity : moveType.count;\n    let panelToMove = basePanel;\n    let passedPanelCount = 0;\n    let cycleIndex = panelToMove.getIndex() === indexRange.min\n      ? basePanel.getCloneIndex() + 1\n      : 0;\n\n    while (passedPanelCount < snapCount) {\n      const siblingPanel = isNextDirection\n        ? panelToMove.nextSibling\n        : panelToMove.prevSibling;\n      if (!siblingPanel) {\n        break;\n      }\n\n      const panelIndex = panelToMove.getIndex();\n      const siblingIndex = siblingPanel.getIndex();\n      if ((isNextDirection && siblingIndex <= panelIndex)\n        || (!isNextDirection && siblingIndex >= panelIndex)\n      ) {\n        cycleIndex = isNextDirection\n          ? cycleIndex + 1\n          : cycleIndex - 1;\n      }\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n\n      // Since panlToMove holds also cloned panels, we should use original panel's position\n      const originalPanel = panelToMove.getOriginalPanel();\n      const panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      const panelSize = originalPanel.getSize();\n\n      // Current panelToMove contains destPos\n      if (\n        (isNextDirection && (panelPosition + panelSize + halfGap) > estimatedHangerPos)\n        || (!isNextDirection && (panelPosition - halfGap) < estimatedHangerPos)\n      ) {\n        break;\n      }\n    }\n\n    const originalPosition = panelToMove.getOriginalPanel().getPosition();\n    const offset = cycleIndex * scrollAreaSize - (panelToMove.getPosition() - originalPosition);\n\n    return {\n      panelAtDestPos: panelToMove,\n      snapOffset: offset,\n      indexDiff: passedPanelCount,\n    };\n  }\n\n  private findAdjacentPanel(isNextDirection: boolean, viewport: Viewport): Panel {\n    const options = viewport.options;\n    const currentIndex = viewport.getCurrentIndex();\n    const currentPanel = viewport.panelManager.get(currentIndex)!;\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = options.circular\n      && (Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition));\n\n    // If lapped in circular mode, use first cloned panel as base panel\n    const basePanel = lapped\n      ? firstClonedPanel\n      : currentPanel;\n\n    const adjacentPanel = isNextDirection\n      ? basePanel.nextSibling\n      : basePanel.prevSibling;\n\n    const panelToMove = adjacentPanel\n      ? adjacentPanel\n      : basePanel;\n\n    return panelToMove;\n  }\n}\n\nexport default DraggingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { triggerEvent, transitTo }: FlickingContext): void {\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted);\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n}\n\nexport default AnimatingState;\n","import State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","import State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","import Axes, { PanInput } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport Panel from \"./Panel\";\nimport PanelManager from \"./PanelManager\";\nimport StateMachine from \"./StateMachine\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus, ElementLike, EventType, TriggerCallback, ChangeEvent, NeedPanelEvent, FlickingEvent, MoveTypeObjectOption } from \"../types\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS, EVENTS, DIRECTION, STATE_TYPE } from \"../consts\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray, parseElement, getProgress } from \"../utils\";\n\nexport default class Viewport {\n  public options: FlickingOptions;\n  public stateMachine: StateMachine;\n  public panelManager: PanelManager;\n\n  private flicking: Flicking;\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private triggerEvent: Flicking[\"triggerEvent\"];\n  private axesHandlers: {[key: string]: any};\n\n  private currentPanel: Panel | undefined;\n  private nearestPanel: Panel | undefined;\n\n  private state: {\n    size: number;\n    position: number;\n    relativeHangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    infiniteThreshold: number;\n    checkedIndexes: Array<[number, number]>;\n  };\n\n  constructor(\n    flicking: Flicking,\n    viewportElement: HTMLElement,\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n    triggerEvent: Flicking[\"triggerEvent\"],\n  ) {\n    this.flicking = flicking;\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    this.triggerEvent = triggerEvent;\n\n    this.state = {\n      size: 0,\n      position: 0,\n      relativeHangerPosition: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n    this.panelManager = new PanelManager(cameraElement, options);\n\n    this.build();\n  }\n\n  public moveTo(\n    panel: Panel,\n    eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | EventType[\"NONE\"],\n    axesEvent: any,\n    offset: number = 0,\n    duration: number = this.options.duration,\n  ): TriggerCallback {\n    const state = this.state;\n    const currentState = this.stateMachine.getState();\n    const freeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n\n    const currentPanel = this.currentPanel;\n    const currentPosition = state.position;\n    const castedPanel = this.castToFlickingPanel(panel, offset);\n\n    let estimatedPosition = castedPanel.getAnchorPosition() - state.relativeHangerPosition;\n    estimatedPosition = this.canSetBoundMode()\n      ? clamp(estimatedPosition, state.scrollArea.prev, state.scrollArea.next)\n      : estimatedPosition;\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const direction = estimatedPosition > currentPosition\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel: castedPanel,\n        direction,\n        prevIndex: currentPanel ? currentPanel.getIndex() : -1,\n        prevPanel: currentPanel ? this.castToFlickingPanel(currentPanel) : null,\n      } as ChangeEvent);\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      this.currentPanel = panel;\n      currentState.targetPanel = panel;\n      currentState.targetOffset = offset;\n      currentState.direction = estimatedPosition > currentPosition\n        ? DIRECTION.NEXT\n        : DIRECTION.PREV;\n      // freeScroll only occurs in release events\n      if (axesEvent && axesEvent.setTo) {\n        axesEvent.setTo({ flick: freeScroll ? axesEvent.destPos.flick : estimatedPosition }, duration);\n      } else {\n        if (estimatedPosition === currentPosition) {\n          // no move\n          this.nearestPanel = this.findNearestPanel();\n        } else {\n          this.axes.setTo({ flick: estimatedPosition }, duration);\n        }\n      }\n    });\n\n    return eventResult;\n  }\n\n  public moveCamera(pos: number, axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const transform = state.translate.name;\n\n    // Update position & nearestPanel\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n\n    const nearestPanel = this.nearestPanel;\n    const originalNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    this.checkNeedPanel(axesEvent);\n\n    // Possibly modified after need panel, if it's looped\n    const modifiedNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n    pos += (modifiedNearestPosition - originalNearestPosition);\n    state.position = pos;\n\n    const moveVector = options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n  }\n\n  public stopCamera = (axesEvent: any): void => {\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: this.state.position }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  public resize(): void {\n    const panelManager = this.panelManager;\n\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n\n    // Clone panels in circular mode\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n\n    panelManager.chainAllPanels();\n    this.updateCameraPosition();\n  }\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const { prev: prevRange, next: nextRange } = state.scrollArea;\n    const hangerPosition = this.getHangerPosition();\n    const relativeHangerPosition = this.getRelativeHangerPosition();\n\n    if (this.isOutOfBound()) {\n      const position = state.position;\n      const currentPanel = this.getCurrentPanel();\n\n      if (position < prevRange) {\n        return panelManager.firstPanel();\n      } else if (position > nextRange) {\n        return panelManager.lastPanel();\n      } else if (currentPanel) {\n        const currentAnchorPosition = currentPanel.getAnchorPosition();\n        if (\n          (position === prevRange && currentAnchorPosition <= prevRange + relativeHangerPosition) ||\n          (position === nextRange && currentAnchorPosition >= nextRange + relativeHangerPosition)\n         ) {\n          return currentPanel;\n        }\n      }\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  }\n\n  public findNearestPanelAt(position: number): Panel | undefined {\n    const panelManager = this.panelManager;\n\n    const allPanels = panelManager.allPanels();\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel | undefined;\n\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(position, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - position),\n          Math.abs(nextPosition - position),\n        );\n\n      if (distance >= minimumDistance) {\n        break;\n      }\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = this.getHangerPosition();\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = this.getHangerPosition();\n    const distance = Math.abs(hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.relativeHangerPosition\n        : anchorPosition > hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.relativeHangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public insert(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const lastIndex = this.panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this.options))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const pushedIndex = this.panelManager.insert(index, panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n    }\n\n    // Update checked indexes in infinite mode\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (isBetween(index, min, max)) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx, 1);\n      } else if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n\n    this.resize();\n\n    return panels.map(panel => this.castToFlickingPanel(panel));\n  }\n\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const panelManager = this.panelManager;\n    const lastIndex = panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this.options))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    panelManager.replace(index, panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n    }\n\n    // Update checked indexes in infinite mode\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (index <= max && index + panels.length > min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx, 1);\n      }\n    });\n\n    this.resize();\n\n    return panels.map(panel => this.castToFlickingPanel(panel));\n  }\n\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    // Index should not below 0\n    index = Math.max(index, 0);\n\n    const panelManager = this.panelManager;\n    const currentIndex = this.getCurrentIndex();\n\n    const removedPanels = panelManager.remove(index, deleteCount);\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      const newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    }\n    this.resize();\n\n    return removedPanels.map(panel => this.castToFlickingPanel(panel));\n  }\n\n  public updateAdaptiveSize(): void {\n    const options = this.options;\n    const horizontal = options.horizontal;\n    const currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    let sizeToApply: number;\n    if (options.adaptive) {\n      const panelBbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panelManager.originalPanels().reduce((maximum, panel) => {\n        const panelBbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const viewportElement = this.viewportElement;\n    const wrapper = viewportElement.parentElement;\n\n    wrapper!.removeChild(viewportElement);\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    this.panelManager.originalPanels().forEach(panel => {\n      wrapper!.appendChild(panel.getElement());\n      panel.destroy();\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const cameraElement = this.cameraElement;\n    const panelManager = this.panelManager;\n\n    // Restore index\n    panelManager.clear();\n    cameraElement.innerHTML = status.panels.map(panel => panel.html).join(\"\");\n\n    this.createPanels();\n    this.currentPanel = panelManager.get(status.index);\n\n    // Reset panel index\n    panelManager.originalPanels().forEach((panel, idx) => {\n      panel.setIndex(panels[idx].index);\n    });\n\n    this.resize();\n\n    this.axes.setTo({ flick: status.position }, 0);\n    this.moveCamera(status.position);\n  }\n\n  public getCurrentPanel(): Panel | undefined {\n    return this.currentPanel;\n  }\n\n  public getCurrentIndex(): number {\n    const currentPanel = this.currentPanel;\n\n    return currentPanel\n      ? currentPanel.getIndex()\n      : -1;\n  }\n\n  public getNearestPanel(): Panel | undefined {\n    return this.nearestPanel;\n  }\n\n  // Get progress from nearest panel\n  public getCurrentProgress(): number {\n    let nearestPanel = this.nearestPanel;\n    const panelManager = this.panelManager;\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n    const {prev: prevRange, next: nextRange} = this.getScrollArea();\n    const cameraPosition = this.getCameraPosition();\n    const isOutOfBound = this.isOutOfBound();\n    let prevPanel = nearestPanel.prevSibling;\n    let nextPanel = nearestPanel.nextSibling;\n    let hangerPosition = this.getHangerPosition();\n    let nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (\n      isOutOfBound\n      && prevPanel\n      && nextPanel\n      && cameraPosition < nextRange\n      // On the basis of anchor, prevPanel is nearestPanel.\n      && (hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition)\n    ) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n    const nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    const nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      const relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n    const hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    const gap = this.options.gap;\n\n    let basePosition = nearestAnchorPos;\n    let targetPosition = nearestAnchorPos;\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel\n        ? nextPanel.getAnchorPosition()\n        : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel\n        ? prevPanel.getAnchorPosition()\n        : basePosition = nearestAnchorPos - nearestSize - gap;\n    }\n\n    const progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    const startIndex = hangerIsNextToNearestPanel\n      ? nearestIndex\n      : prevPanel\n        ? prevPanel.getIndex()\n        : nearestIndex - 1;\n\n    return startIndex + progressBetween;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n  public isOutOfBound(): boolean {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n\n    return !this.options.circular\n      && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  }\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getRelativeHangerPosition(): number {\n    return this.state.relativeHangerPosition;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.position + this.state.relativeHangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public setLastIndex(index: number): void {\n    const currentPanel = this.currentPanel;\n    const panelManager = this.panelManager;\n\n    panelManager.setLastIndex(index);\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  }\n\n  public connectAxesHandler(handlers: {[key: string]: (event: { [key: string]: any; }) => any}): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  }\n\n  public castToFlickingPanel = (panel: Panel, offset = 0): FlickingPanel => {\n    const viewport = this;\n    const options = viewport.options;\n\n    return {\n      getElement() {\n        return panel.getElement();\n      },\n      getIndex() {\n        return panel.getIndex();\n      },\n      getPosition() {\n        return panel.getPosition() + offset;\n      },\n      getAnchorPosition() {\n        return this.getPosition() + panel.getRelativeAnchorPosition();\n      },\n      getSize() {\n        return panel.getSize();\n      },\n      getProgress() {\n        let progress: number = NaN;\n\n        const nearestPanel = viewport.getNearestPanel();\n        if (nearestPanel) {\n          // single\n          const panelCount = viewport.panelManager.getPanelCount();\n          const scrollAreaSize = viewport.getScrollAreaSize();\n          const relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n\n          progress = relativeIndex - viewport.getCurrentProgress();\n        }\n        return progress;\n      },\n      getOutsetProgress(this: FlickingPanel) {\n        let outsetProgress: number = NaN;\n\n        const nearestPanel = viewport.getNearestPanel();\n        if (nearestPanel) {\n          const outsetRange = [\n            -this.getSize(),\n            viewport.getRelativeHangerPosition() - panel.getRelativeAnchorPosition(),\n            viewport.getSize(),\n          ];\n          const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n\n          outsetProgress = getProgress(relativePanelPosition, outsetRange);\n        }\n\n        return outsetProgress;\n      },\n      getVisibleRatio(this: FlickingPanel) {\n        let visibleRatio = 0;\n\n        const panelSize = panel.getSize();\n        const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n        const rightRelativePanelPosition = relativePanelPosition + panelSize;\n        const visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n\n        visibleRatio = visibleSize >= 0\n          ? visibleSize / panelSize\n          : 0;\n\n        return visibleRatio;\n      },\n      focus(this: FlickingPanel, duration?: number): void {\n        const currentPanel = viewport.getCurrentPanel();\n        const hangerPosition = viewport.getHangerPosition();\n        const anchorPosition = panel.getAnchorPosition();\n        if (hangerPosition === anchorPosition || !currentPanel) {\n          return;\n        }\n\n        const currentPosition = currentPanel.getPosition();\n        viewport.moveTo(panel, currentPosition === this.getPosition() ? EVENTS.NONE : EVENTS.CHANGE, null, offset, duration);\n      },\n      update(this: FlickingPanel, updateFunction: (element: HTMLElement) => any): void {\n        panel.getIdenticalPanels()\n          .forEach(eachPanel => updateFunction(eachPanel.getElement()));\n      },\n      prev(this: FlickingPanel): FlickingPanel | null {\n        const prevSibling = panel.prevSibling;\n\n        if (!prevSibling) {\n          return null;\n        }\n\n        const currentIndex = this.getIndex();\n        const prevIndex = prevSibling.getIndex();\n\n        const hasEmptyPanelBetween = currentIndex - prevIndex > 1;\n        const notYetMinPanel = options.infinite\n          && currentIndex > 0\n          && prevIndex > currentIndex;\n\n        if (hasEmptyPanelBetween || notYetMinPanel) {\n          // Empty panel exists between\n          return null;\n        }\n\n        const prevPanelSize = prevSibling.getSize();\n        const newPosition = this.getPosition() - prevPanelSize - options.gap;\n        const newOffset = newPosition - prevSibling.getPosition();\n\n        return viewport.castToFlickingPanel(prevSibling, newOffset);\n      },\n      next(this: FlickingPanel): FlickingPanel | null {\n        const nextSibling = panel.nextSibling;\n        const lastIndex = viewport.panelManager.getLastIndex();\n\n        if (!nextSibling) {\n          return null;\n        }\n\n        const currentIndex = this.getIndex();\n        const nextIndex = nextSibling.getIndex();\n\n        const hasEmptyPanelBetween = nextIndex - currentIndex > 1;\n        const notYetMaxPanel = options.infinite\n          && currentIndex < lastIndex\n          && nextIndex < currentIndex;\n\n        if (hasEmptyPanelBetween || notYetMaxPanel) {\n          return null;\n        }\n\n        const newPosition = this.getPosition() + panel.getSize() + options.gap;\n        const newOffset = newPosition - nextSibling.getPosition();\n\n        return viewport.castToFlickingPanel(nextSibling, newOffset);\n      },\n      insertBefore(this: FlickingPanel, element: ElementLike | ElementLike[]): FlickingPanel[] {\n        const parsedElements = parseElement(element);\n        const firstPanel = viewport.panelManager.firstPanel()!;\n        const prevSibling = panel.prevSibling;\n        // Finding correct inserting index\n        // While it should insert removing empty spaces,\n        // It also should have to be bigger than prevSibling' s index\n        const targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex()\n          ? Math.max(prevSibling.getIndex() + 1, panel.getIndex() - parsedElements.length)\n          : Math.max(panel.getIndex() - parsedElements.length, 0);\n\n        return viewport.insert(targetIndex, parsedElements);\n      },\n      insertAfter(this: FlickingPanel, element: ElementLike | ElementLike[]): FlickingPanel[] {\n        return viewport.insert(panel.getIndex() + 1, element);\n      },\n      remove(this: FlickingPanel): FlickingPanel {\n        return viewport.remove(panel.getIndex())[0];\n      },\n    };\n  }\n\n  private build(): void {\n    this.applyCSSValue();\n    this.setAxesInstance();\n    this.createPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const classPrefix = options.classPrefix;\n\n    // Set default css values for each element\n    viewportElement.className = `${classPrefix}-viewport`;\n    cameraElement.className = `${classPrefix}-camera`;\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private createPanels(): void {\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n\n    // Initialize panels\n    const panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this.options),\n    );\n\n    if (panels.length > 0) {\n      this.panelManager.append(panels);\n    }\n  }\n\n  private setDefaultPanel(): void {\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const indexRange = this.panelManager.getRange();\n    const index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n\n    this.currentPanel = panelManager.get(index);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const panelManager = this.panelManager;\n\n    const viewportSize = state.size;\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n\n    // There're no panels exist\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + this.options.gap;\n    const visibleAreaSize = viewportSize + firstPanel.getRelativeAnchorPosition();\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const panels = panelManager.originalPanels();\n\n    const cloneCount = Math.ceil(visibleAreaSize / sumOriginalPanelSize);\n    const prevCloneCount = panelManager.getCloneCount();\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        const clones = panels.map(origPanel => {\n          const clonedPanel = origPanel.clone(cloneIndex);\n\n          this.cameraElement.appendChild(clonedPanel.getElement());\n          return clonedPanel;\n        });\n        panelManager.insertClones(cloneIndex, 0, clones);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const indexRange = this.panelManager.getRange();\n\n    const defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    const defaultPanel = panelManager.get(defaultIndex);\n\n    let defaultPosition = 0;\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode()\n        ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n        : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const lastPanel = this.panelManager.lastPanel();\n    if (!lastPanel) {\n      return false;\n    }\n\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const panels = this.panelManager.originalPanels();\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n      viewportElement.style.minWidth = \"\";\n    }\n\n    const bbox = viewportElement.getBoundingClientRect();\n\n    // Update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n    state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n\n    // Resize all panels\n    panels.forEach(panel => {\n      panel.resize();\n    });\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panelManager = this.panelManager;\n\n    const firstPanel = panelManager.firstPanel();\n    const panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const currentPanel = this.currentPanel!;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = firstPanel.getPosition();\n    let maintainingPanel: Panel = firstPanel;\n    if ((currentState.holding || currentState.playing) && nearestPanel) {\n      // We should maintain nearestPanel's position\n      const currentIndex = currentPanel.getIndex()\n        + (currentPanel.getCloneIndex() + 1) * panels.length;\n      const nearestIndex = nearestPanel.getIndex()\n        + (nearestPanel.getCloneIndex() + 1) * panels.length;\n      const looped = (currentIndex >= nearestIndex && currentState.delta > 0)\n        || (currentIndex <= nearestIndex && currentState.delta < 0);\n\n      maintainingPanel = looped\n        ? currentPanel\n        : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    const panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    const accumulatedSize = panelsBeforeMaintainPanel.reduce((total, panel) => {\n      return total + panel.getSize() + gap;\n    }, 0);\n\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n\n    panels.forEach(panel => {\n      const newPosition = nextPanelPos;\n      const currentPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n\n      if (currentPosition !== newPosition) {\n        panel.setPosition(newPosition);\n      }\n      nextPanelPos += panelSize + gap;\n    });\n  }\n\n  private updateClonedPanelPositions(): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const clonedPanels = panelManager.clonedPanels()\n      .filter(panel => !!panel);\n\n    const scrollArea = state.scrollArea;\n\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      if (!panel) {\n        continue;\n      }\n\n      const origPanel = panel.getOriginalPanel();\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n    const relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0,\n      };\n    } else if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    const flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  }\n\n  // Update camera position after resizing\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const axes = this.axes;\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.stateMachine.getState();\n\n    if (!currentPanel || currentState.holding || currentState.playing) {\n      return;\n    }\n\n    let newPosition = currentPanel.getAnchorPosition() - state.relativeHangerPosition;\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n    this.axes.off();\n    axes.setTo({\n      flick: newPosition,\n    }, 0);\n    this.axes.on(this.axesHandlers);\n    this.moveCamera(newPosition);\n  }\n\n  private checkNeedPanel(axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentPanel = this.currentPanel;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    const gap = options.gap;\n    const infiniteThreshold = state.infiniteThreshold;\n    const maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent,\n        index: 0,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1,\n        },\n      });\n      return;\n    }\n\n    const originalNearestPosition = nearestPanel.getPosition();\n\n    // Check next direction\n    let checkingPanel: Panel | null = !currentState.holding && !currentState.playing\n      ? currentPanel\n      : nearestPanel;\n    while (checkingPanel) {\n      const currentIndex = checkingPanel.getIndex();\n      const nextSibling = checkingPanel.nextSibling;\n      let lastPanel = panelManager.lastPanel()!;\n      let atLastPanel = currentIndex === lastPanel.getIndex();\n      const nextIndex = !atLastPanel && nextSibling\n        ? nextSibling.getIndex()\n        : maxLastIndex + 1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      const cameraNext = state.position + state.size;\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = (nextIndex - currentIndex > 1);\n      // Expected prev panel's left position is smaller than camera position\n      const overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          index: checkingPanel.getIndex(),\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at max panel index\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        const firstPanel = panelManager.firstPanel()!;\n        const firstIndex = firstPanel.getIndex();\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent,\n            index: checkingPanel.getIndex(),\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether insertion happened\n      lastPanel = panelManager.lastPanel()!;\n      atLastPanel = currentIndex === lastPanel.getIndex();\n\n      if (atLastPanel || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    }\n\n    // Check prev direction\n    checkingPanel = nearestPanel;\n    while (checkingPanel) {\n      const cameraPrev = state.position;\n      const checkingIndex = checkingPanel.getIndex();\n      const prevSibling = checkingPanel.prevSibling;\n      let firstPanel = panelManager.firstPanel()!;\n      let atFirstPanel = checkingIndex === firstPanel.getIndex();\n      const prevIndex = !atFirstPanel && prevSibling\n        ? prevSibling.getIndex()\n        : -1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition);\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = checkingIndex - prevIndex > 1;\n      // Expected prev panel's right position is smaller than camera position\n      const overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          index: checkingPanel.getIndex(),\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at panel 0\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        const lastPanel = panelManager.lastPanel()!;\n        const lastIndex = lastPanel.getIndex();\n\n        if (lastIndex < maxLastIndex) {\n          this.triggerNeedPanel({\n            axesEvent,\n            index: checkingPanel.getIndex(),\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether insertion happened\n      firstPanel = panelManager.firstPanel()!;\n      atFirstPanel = checkingIndex === firstPanel.getIndex();\n\n      // Looped in circular mode\n      if (atFirstPanel || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  }\n\n  private triggerNeedPanel(params: {\n    axesEvent: any;\n    index: number;\n    siblingPanel?: Panel,\n    direction: FlickingEvent[\"direction\"];\n    indexRange: NeedPanelEvent[\"range\"];\n  }): void {\n    const { axesEvent, index, siblingPanel, direction, indexRange } = params;\n    const checkedIndexes = this.state.checkedIndexes;\n    const alreadyTriggered = checkedIndexes.some(([min, max]) => min === indexRange.min || max === indexRange.max);\n    const hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    }\n\n    // Should done before triggering event, as we can directly add panels by event callback\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const panel = siblingPanel\n      ? this.castToFlickingPanel(siblingPanel)\n      : null;\n\n    this.triggerEvent(\n      EVENTS.NEED_PANEL,\n      axesEvent,\n      isTrusted,\n      {\n        index,\n        panel,\n        direction,\n        range: indexRange,\n      } as NeedPanelEvent,\n    );\n  }\n}\n","import Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\n\nimport { merge, getProgress, toArray, parseElement, isString } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE, DEFAULT_MOVE_TYPE_OPTIONS } from \"./consts\";\nimport { FlickingOptions, FlickingEvent, Direction, EventType, FlickingPanel, TriggerCallback, FlickingContext, FlickingStatus, Plugin, ElementLike } from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"9+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n * @throws {Error} An Error occur when given base element doesn't exist or it hasn't proper DOM structure to be initialized. <ko>주어진 기본 요소가 존재하지 않거나 초기화 할 적절한 DOM 구조가없는 경우 오류가 발생한다.</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event types\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n  private plugins: Plugin[] = [];\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix for class names of the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation where acceleration is manually enabled by user. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for infinite scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되여 무한 스크롤이 가능하다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to destination panel(unit: pixel). A panel element must be dragged beyond the threshold to move to the destination panel.<ko>목적 패널로의 이동 임계값 (단위: 픽셀). 패널 요소를 임계값 이상으로 끌어다 놓아야만이 목적 패널로 이동한다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] The easing function to apply to a panel moving animation. The default function is easeOutCubic.<ko>패널 이동 애니메이션에 적용할 `easing`함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing the module. A zero-based integer.<ko>모듈 초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput Reference})<br>- \"touch\": A touch input device.<br>- \"mouse\": A mouse.<ko>입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput 참고})<br>- \"touch\": 터치 입력 장치.<br>- \"mouse\": 마우스.</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold value that determines whether user input is horizontal or vertical. (0 ~ 90)<ko>사용자의 입력이 가로 방향인지 세로 방향인지 판단하는 기준 각도 (0 ~ 90)</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {Boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element<ko>뷰포트 요소의 z-index 값</ko>\n   * @param {boolean} [options.bound=false] Prevents view going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Position of hanger in viewport, which hangs panel anchors.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space between each panels.<br>Should be given in number(px).<ko>패널간에 부여할 간격의 크기를 나타내는 숫자(px)</ko>\n   * @param {number} [options.snap=1] The number of panels you're going to roll over to when you snap<ko>한 번 스냅 할 때 최대 몇 개의 패널까지 넘길 건지 나타내는 숫자</ko>\n   * @param {boolean} [options.freeScroll=false] If true, panels can scroll freely when flicked.<ko>활성화 했을 때 플릭한 경우에 패널들을 자유롭게 스크롤할 수 있다.</ko>\n   */\n  constructor(\n    element: ElementLike,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Override moveType option\n    const currentOptions = this.options;\n    const moveType = currentOptions.moveType;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType as keyof typeof DEFAULT_MOVE_TYPE_OPTIONS];\n    }\n    this.build();\n  }\n  /**\n   * Move to the previous panel. If `horizontal=true`is left panel. If `horizontal=false`is upper panel.\n   * @ko 이전 패널로 이동한다. `horizontal=true`이면 좌측 패널. `horizontal=false`이면 상측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public prev(duration?: number): this {\n    const options = this.options;\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const currentIndex = viewport.getCurrentIndex();\n    const indexRange = panelManager.getRange();\n    const panelCount = panelManager.getPanelCount();\n    const lastIndex = panelManager.getLastIndex();\n    const minimumRange = options.infinite\n      ? 0\n      : indexRange.min;\n    let prevIndex = currentIndex - 1;\n\n    if (prevIndex < minimumRange) {\n      prevIndex = this.options.circular && panelCount > 0\n        ? options.infinite\n          ? lastIndex\n          : indexRange.max\n        : -1;\n    }\n\n    return this.moveTo(prevIndex, duration);\n  }\n\n  /**\n   * Move to the next panel. If `horizontal=true`is right panel. If `horizontal=false`is lower panel.\n   * @ko 다음 패널로 이동한다. `horizontal=true`이면 우측 패널. `horizontal=false`이면 하측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public next(duration?: number): this {\n    const options = this.options;\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const currentIndex = viewport.getCurrentIndex();\n    const indexRange = panelManager.getRange();\n    const panelCount = panelManager.getPanelCount();\n    const lastIndex = panelManager.getLastIndex();\n    const maximumRange = options.infinite\n      ? lastIndex\n      : indexRange.max;\n    let nextIndex = currentIndex + 1;\n\n    if (nextIndex > maximumRange) {\n      nextIndex = options.circular && panelCount > 0\n        ? options.infinite\n          ? 0\n          : indexRange.min\n        : -1;\n    }\n\n    return this.moveTo(nextIndex, duration);\n  }\n\n  /**\n   * Moves to the panel in the order specified in `index`. If `index` is equal to selected panel's index, no action is taken.\n   * @ko `index`에 지정한 순서의 패널로 이동한다. `index`값이 현재 선택된 패널의 인덱스와 동일하다면, 아무 동작도 하지 않는다.\n   * @param index The index number of the panel to be moved.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    const state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = viewport.getHangerPosition();\n\n    let offset = 0;\n    if (this.options.circular) {\n      const scrollAreaSize = viewport.getScrollAreaSize();\n      // Check all three possible locations, find the nearest position among them.\n      const possiblePositions = [\n        anchorPosition - scrollAreaSize,\n        anchorPosition,\n        anchorPosition + scrollAreaSize,\n      ];\n      const nearestPosition = possiblePositions.reduce((nearest, current) => {\n        return (Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition))\n          ? current\n          : nearest;\n      }, Infinity);\n\n      offset = nearestPosition - anchorPosition;\n    }\n    const currentIndex = this.getIndex();\n\n    if (hangerPosition === anchorPosition + offset && currentIndex === index) {\n      return this;\n    }\n\n    const eventType = panel.getIndex() === viewport.getCurrentIndex()\n      ? EVENTS.NONE\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      panel,\n      eventType,\n      null,\n      offset,\n      duration,\n    );\n    return this;\n  }\n\n  /**\n   * Returns the index number of the selected panel.\n   * @ko 현재 선택된 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the current panel element.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getCurrentIndex();\n  }\n\n  /**\n   * Returns the wrapper element user provided in Flicking constructor.\n   * @ko 사용자가 생성자에서 제공한 래퍼 엘리먼트를 반환한다.\n   * @return Wrapper element user provided.<ko>사용자가 제공한 래퍼 엘리먼트</ko>\n   */\n  public getElement(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Returns the selected panel object\n   * @ko 현재 선택된 패널의 오브젝트를 반환한다.\n   * @return Selected panel object.<ko>선택된 패널 오브젝트</ko>\n   */\n  public getCurrentPanel(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel();\n    return panel\n      ? viewport.castToFlickingPanel(panel)\n      : null;\n  }\n\n  /**\n   * Returns the panel object of given index\n   * @ko 주어진 인덱스에 해당하는 패널의 오브젝트를 반환한다.\n   * @return panel object of given index, `null` if it doesn't exists.<ko>주어진 인덱스에 해당하는 패널의 오브젝트, 해당 패널이 존재하지 않을 시 `null`.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    return panel\n      ? viewport.castToFlickingPanel(panel)\n      : null;\n  }\n  /**\n   * Returns all panel objects in flicking.\n   * @ko 플리킹 안에 있는 모든 패널 오브젝트들을 반환한다.\n   * @param - Check whether to include clone or not <ko>복사본을 포함할 건지 안 할 건지 확인한다</ko>\n   * @return All panel objects <ko>플리킹 안에 있는 모든 패널 오브젝트들</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const panels = includeClone\n      ? panelManager.allPanels()\n      : panelManager.originalPanels();\n\n    return panels\n      .filter(panel => !!panel)\n      .map(panel => viewport.castToFlickingPanel(panel));\n  }\n  /**\n   * Returns the panel objects shown in the flicking area.\n   * @ko 플리킹 영역에서 보여지는 패널 오브젝트들을 반환한다.\n   * @return The panel objects shown in the flicking area. <ko>플리킹 영역에서 보여지는 패널 오브젝트들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.getAllPanels(true).filter(panel => {\n      const outsetProgress = panel.getOutsetProgress();\n\n      return outsetProgress > -1 && outsetProgress < 1;\n    });\n  }\n  /**\n   * Returns the total length of original panels\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.panelManager.getPanelCount();\n  }\n\n  /**\n   * Set last panel index for `infinite' mode. [needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it. Also, you can't add more panels after it.\n   * @ko `infinite` 모드에서 적용되는 패널의 최대 인덱스를 설정한다. 마지막 패널의 인덱스가 설정한 값에 도달할 경우 더 이상 [needPanel]{@link eg.Flicking#events:needPanel} 이벤트가 발생되지 않는다. 또한, 설정한 인덱스 이후로 새로운 패널을 추가할 수 없다.\n   * @param - Last panel index.\n   * @see {@link eg.Flicking.FlickingOptions}\n   */\n  public setLastIndex(index: number): void {\n    this.viewport.setLastIndex(index);\n  }\n\n  /**\n   * Checks whether the animated panel is playing.\n   * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n   * @return Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n   */\n  public isPlaying(): boolean {\n    return this.viewport.stateMachine.getState().playing;\n  }\n\n  /**\n   * The input from the input device is not blocked so that the panel can be moved by the input device.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return  An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * The input from the input device is blocked so that the panel is not moved by the input device.\n   * @ko 패널이 입력 장치에 의해 움직이지 않도록 입력 장치로부터의 입력을 막는다.\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Get current flicking status. If the returned value is specified as a [setStatus()]{@link eg.Flicking#setStatus} method argument, it can be returned to its value status.\n   * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메서드 인자로 지정하면 그 값 상태로 되돌릴 수 있다.\n   * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus(): Readonly<FlickingStatus> {\n    const viewport = this.viewport;\n\n    const panels = viewport.panelManager.originalPanels()\n      .filter(panel => !!panel)\n      .map(panel => {\n        return {\n          html: panel.getElement().outerHTML,\n          index: panel.getIndex(),\n        };\n      });\n\n    return {\n      index: viewport.getCurrentIndex(),\n      panels,\n      position: viewport.getCameraPosition(),\n    };\n  }\n\n  /**\n   * Restore to the state of the `status`.\n   * @ko `status`의 상태로 복원한다.\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n   */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add <ko>추가할 플러그인(들)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n  /**\n   * Remove plugins from Flicking\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove <ko>제거 플러그인(들)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(this);\n    });\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    this.plugins.forEach(plugin => {\n      plugin.destroy(this);\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * The horizontal or vertical length of the panel is updated according to the base element. If `horizontal=true` is horizontal. If `horizontal=false` is vertical.\n   * @ko 패널의 가로 혹은 세로 길이를 기준요소에 맞춰 갱신한다. `horizontal=true`이면 가로, `horizontal=false`이면 세로.\n   * @return An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n  public resize(): this {\n    const viewport = this.viewport;\n\n    viewport.panelManager.allPanels()\n      .forEach(panel => panel.reset());\n    viewport.resize();\n\n    return this;\n  }\n\n  /**\n   * Add new panel at the start.\n   * @ko 제일 앞에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\n   */\n  public prepend(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n\n    const insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    return viewport.insert(insertingIndex, parsedElements);\n  }\n\n  /**\n   * Add new panel at the end.\n   * @ko 제일 끝에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\n   */\n  public append(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n\n    return viewport.insert(viewport.panelManager.getRange().max + 1, element);\n  }\n\n  /**\n   * Replace panels with new panels from given index. If index is empty, add new panel at target index.\n   * @ko 주어진 인덱스로부터의 패널들을 새로운 패널들로 교체한다. 인덱스에 해당하는 자리가 비어있다면, 새로운 패널을 해당 자리에 집어넣는다.\n   * @param index - Start index to replace new panels.<ko>새로운 패널들로 교체할 시작 인덱스</ko>\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of created panels by replace.<ko>교체되어 새롭게 추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   *\n   * // This will add new panel at index 3,\n   * // Index 0, 1, 2 is empty at this moment.\n   * // [empty, empty, empty, PANEL]\n   * flicking.replace(3, document.createElement(\"div\"));\n   *\n   * // As index 2 was empty, this will also add new panel at index 2.\n   * // [empty, empty, PANEL, PANEL]\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\n   *\n   * // Index 3 was not empty, so it will replace previous one.\n   * // It will also add new panels at index 4 and 5.\n   * // before - [empty, empty, PANEL, PANEL]\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\n   */\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.replace(index, element);\n  }\n\n  /**\n   * Remove panel at target index. This will decrease index of panels behind it.\n   * @ko `index`에 해당하는 자리의 패널을 제거한다. 수행시 `index` 이후의 패널들의 인덱스가 감소된다.\n   * @param index - Index of panel to remove.<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index` 이후로 제거할 패널의 개수.</ko>\n   * @return Array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    return this.viewport.remove(index, deleteCount);\n  }\n\n  private build(): void {\n    this.initViewport();\n    this.listenInput();\n    this.listenResize();\n  }\n\n  private initViewport(): void {\n    const wrapper = this.wrapper;\n    const options = this.options;\n    const cameraElement = document.createElement(\"div\");\n\n    // Make all panels to be a child of camera element\n    // wrapper <- viewport <- camera <- panels[1...n]\n    toArray(wrapper.children).forEach(child => {\n      cameraElement.appendChild(child);\n    });\n\n    // Clipping area for camera element\n    const viewportElement = document.createElement(\"div\");\n    viewportElement.appendChild(cameraElement);\n\n    // Add viewport element to wrapper\n    wrapper.appendChild(viewportElement);\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(this, viewportElement, cameraElement, options, this.triggerEvent);\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const viewport = flicking.viewport;\n    const stateMachine = viewport.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", () => {\n        this.resize();\n      });\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n\n    let canceled: boolean = true;\n\n    // Ignore events before viewport is initialized\n    if (viewport) {\n      const state = viewport.stateMachine.getState();\n      const { prev, next } = viewport.getScrollArea();\n      const pos = viewport.getCameraPosition();\n      let progress = getProgress(pos, [prev, prev, next]);\n\n      if (this.options.circular) {\n        progress %= 1;\n      }\n      canceled = !super.trigger(eventName, merge({\n        type: eventName,\n        index: this.getIndex(),\n        panel: this.getCurrentPanel(),\n        direction: state.direction,\n        holding: state.holding,\n        progress,\n        axesEvent,\n        isTrusted,\n      }, params));\n    }\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = viewport.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n    const previousPosition = viewport.getCameraPosition();\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNextDirection = inputOffset < 0;\n\n      let cameraChange = pos - previousPosition;\n      const looped = isNextDirection === (pos < previousPosition);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = -Math.sign(cameraChange) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.delta += cameraChange;\n      state.direction = currentDirection;\n    }\n\n    viewport.moveCamera(pos, axesEvent);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted)\n      .onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n  }\n}\n\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","element","Array","isArray","elements","el","isString","tempDiv","document","createElement","innerHTML","push","toArray","children","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","className","classList","add","indexOf","replace","cssObj","property","val","min","max","Math","iterable","slice","call","arr","constructor","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","callback","i","counterArray","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","DEFAULT_VIEWPORT_CSS","position","width","height","DEFAULT_CAMERA_CSS","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","NONE","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","IDLE","HOLDING","DRAGGING","ANIMATING","DISABLED","DIRECTION","PREV","NEXT","TRANSFORM","index","options","prevSibling","nextSibling","state","relativeAnchorPosition","size","clonedPanels","isClone","cloneIndex","originalStyle","getAttribute","cachedBbox","addClass","applyCSS","bbox","getBbox","parseArithmeticExpression","panel","resize","setAttribute","removeAttribute","getBoundingClientRect","original","getClonedPanels","getIdenticalPanels","elementStyle","left","top","cloneElement","cloneNode","clonedPanel","Panel","clonedState","parentNode","removeClonedPanelsAfter","start","removingPanels","splice","remove","cameraElement","panels","clones","reduce","allClones","firstPanel","lastPanel","getIndex","firstRemovedPanel","filter","possibleLastPanel","newPanels","_a","isCircular","findFirstPanelFrom","siblingElement","getElement","fragment","createDocumentFragment","appendChild","pushedIndex","offset","panelsAfterIndex","emptyPanelCount","findIndex","removedPanels","Boolean","setIndex","addNewClones","updateIndex","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","cloneSet","reversedPanels","concat","reverse","nonEmptyIndexFromLast","allPanels","allPanelsCount","prevPanel","nextPanel","newClones_1","insertTarget_1","allPanels_1","panelElement","contains","originalPanels","cloneCount","getCloneCount","lastPanelClones","nextSiblingClones","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","newClones","map","clone","this_1","insertClones","counter","insertingIndex","newLastIndex","prevState","delta","direction","targetPanel","targetOffset","nextState","e","context","tslib_1","_this","flicking","triggerEvent","transitTo","getPanelCount","onSuccess","onStopped","onChange","State","inputEvent","offsetX","offsetY","viewport","flick","setTo","getCameraPosition","releaseEvent","clickedElement","srcEvent","clickedPanel","panelManager","findPanelOf","cameraPosition","clickedPanelPosition","getPosition","castToFlickingPanel","_super","onEnter","moveCamera","stopCamera","defaultDuration","halfGap","isFreeScroll","snapCount","eventDelta","abs","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","moveTo","currentPanel","getCurrentPanel","nearestPanel","getNearestPanel","stop","minimumDistanceToChange","getSize","getRelativeAnchorPosition","panelToMove","basePanel","findNearestIdenticalPanel","panelAtDestPos","snapOffset","indexDiff","isOutOfBound","findAdjacentPanel","findRestorePanelInCircularMode","panelPosition","movingToSamePanel","eventType","hangerPosition","getHangerPosition","firstClonedPanel","lapped","getAnchorPosition","params","scrollAreaSize","getScrollAreaSize","indexRange","getRange","estimatedHangerPos","destPos","getRelativeHangerPosition","passedPanelCount","cycleIndex","getCloneIndex","siblingPanel","panelIndex","siblingIndex","originalPanel","getOriginalPanel","panelSize","originalPosition","currentIndex","getCurrentIndex","get","adjacentPanel","isTrusted","updateAdaptiveSize","IdleState","nextStateType","currentState","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onHold","onRelease","onAnimationEnd","onFinish","viewportElement","axesEvent","stateMachine","getProgress","progress","NaN","panelCount","relativeIndex","floor","getCurrentProgress","getOutsetProgress","outsetProgress","outsetRange","relativePanelPosition","getVisibleRatio","visibleRatio","rightRelativePanelPosition","visibleSize","focus","anchorPosition","currentPosition","update","updateFunction","eachPanel","prev","prevIndex","hasEmptyPanelBetween","notYetMinPanel","prevPanelSize","newPosition","newOffset","next","getLastIndex","nextIndex","notYetMaxPanel","parsedElements","parseElement","targetIndex","insert","insertAfter","relativeHangerPosition","scrollArea","translate","checkedIndexes","StateMachine","PanelManager","build","getState","castedPanel","estimatedPosition","canSetBoundMode","eventResult","findNearestPanel","axes","originalNearestPosition","checkNeedPanel","modifiedNearestPosition","moveVector","moveCoord","coord","round","join","updateSize","updateOriginalPanelPositions","updateScrollArea","clonePanels","updateClonedPanelPositions","chainAllPanels","updateCameraPosition","prevRange","nextRange","currentAnchorPosition","findNearestPanelAt","minimumDistance","prevPosition","nextPosition","distance","isBetween","nearest","shortestDistance","identicals","identical","panInput","enable","disable","indexes","newCurrentIndex","sizeToApply","panelBbox","maximumPanelSize","maximum","viewportStyle","minHeight","minWidth","wrapper","destroy","status","clear","html","createPanels","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","basePosition","targetPosition","progressBetween","startIndex","setLastIndex","handlers","axesHandlers","on","applyCSSValue","setAxesInstance","setDefaultPanel","moveToDefaultPanel","Axes","easing","interruptable","PanInput","scale","connect","panelElements","append","viewportSize","sumOriginalPanelSize","visibleAreaSize","ceil","prevCloneCount","origPanel","removeClonesAfter","defaultPanel","defaultPosition","summedPanelSize","nextPanelPos","maintainingPanel","holding","playing","looped","panelsBeforeMaintainPanel","accumulatedSize","total","setPosition","clonedPanels_1","cloneBasePos","clonedPanelPos","lastReplacePosition","_b","replacePosition","parsedBounce","parsedVal","axis","off","maxLastIndex","triggerNeedPanel","checkingPanel","atLastPanel","currentNearestPosition","panelRight","cameraNext","emptyPanelExistsBetween","firstIndex","cameraPrev","checkingIndex","atFirstPanel","panelLeft","alreadyTriggered","some","hasHandler","hasOn","eventName","canceled","trigger","merge","previousPosition","inputOffset","cameraChange","currentDirection","querySelector","nodeName","nodeType","currentOptions","minimumRange","maximumRange","possiblePositions","nearestPosition","current","includeClone","getAllPanels","outerHTML","restore","plugins","newPlugins","plugin","init","currentPlugins","removedPlugins","reset","initViewport","listenInput","listenResize","child","Viewport","eventContext","fire","connectAxesHandler","addEventListener","Flicking","Component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eAEsBA;eAAgB;;OAAA,YAAAC,uBAAAA;IAAAC,YAAA,gBAAA;;;EACpCA,IAAI,CAACC,OAAL,CAAa,UAAAC,MAAA;IACXC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBD,OAApB,CAA4B,UAAAI,GAAA;UACpBC,KAAK,GAAGJ,MAAM,CAACG,GAAD,CAApB;MACAP,MAAM,CAACO,GAAD,CAAN,GAAcC,KAAd;KAFF;GADF;SAOOR,MAAP;;AAGF,sBAA6BS;MACvB,CAACC,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAL,EAA6B;IAC3BA,OAAO,GAAG,CAACA,OAAD,CAAV;;;MAGIG,QAAQ,GAAkB,EAAhC;EACAH,OAAO,CAACN,OAAR,CAAgB,UAAAU,EAAA;QACVC,QAAQ,CAACD,EAAD,CAAZ,EAAkB;UACVE,OAAO,GAAGC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAhB;MACAF,OAAO,CAACG,SAAR,GAAoBL,EAApB;MAEAD,QAAQ,CAACO,IAAT,MAAA,CAAAP,QAAA,EAAiBQ,OAAO,CAACL,OAAO,CAACM,QAAT,CAAxB;KAJF,MAKO;MACLT,QAAQ,CAACO,IAAT,CAAcN,EAAd;;GAPJ;SAWOD,QAAP;;;;AAKF,AAAO,IAAIU,qBAAqB,GAAG;MAC3BC,UAAU,GAAG;IACjBC,eAAe,EAAE,mBADA;IAEjBC,WAAW,EAAE,eAFI;IAGjBC,YAAY,EAAE,gBAHG;IAIjBC,UAAU,EAAE,cAJK;IAKjBC,SAAS,EAAE;GALb;MAQMC,cAAc,GAAGb,QAAQ,CAACc,eAAT,CAAyBC,KAAhD;MACIC,aAAa,GAAG,EAApB;;OACK,IAAMC,iBAAX,IAAgCV,UAAhC,EAA4C;QACtCU,iBAAiB,IAAIJ,cAAzB,EAAyC;MACvCG,aAAa,GAAGC,iBAAhB;;;;MAIA,CAACD,aAAL,EAAoB;UACZ,IAAIE,KAAJ,CAAU,6CAAV,CAAN;;;MAGIrB,EAAE,GAAGG,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAX;EAEAD,QAAQ,CAACc,eAAT,CAAyBK,YAAzB,CAAsCtB,EAAtC,EAA0C,IAA1C;EAEAA,EAAE,CAACkB,KAAH,CAASC,aAAT,IAA0B,4BAA1B;MACMI,QAAQ,GAAGC,MAAM,CAACC,gBAAP,CAAwBzB,EAAxB,EAA4B0B,gBAA5B,CAA6ChB,UAAU,CAACS,aAAD,CAAvD,CAAjB;EAEAnB,EAAE,CAAC2B,aAAH,CAAkBC,WAAlB,CAA8B5B,EAA9B;MAEM6B,aAAa,GAAG;IACpBC,IAAI,EAAEX,aADc;IAEpBY,KAAK,EAAER,QAAQ,CAACS,MAAT,GAAkB,CAAlB,IAAuBT,QAAQ,KAAK;GAF7C;;EAKAd,qBAAqB,GAAG;WAAMoB,aAAA;GAA9B;;SAEOA,aAAP;CArCK;AAuCP,kBAAyBlC;SAChB,OAAOA,KAAP,KAAiB,QAAxB;;;AAUF,kBAAyBC,SAAsBqC;MACzCrC,OAAO,CAACsC,SAAZ,EAAuB;IACrBtC,OAAO,CAACsC,SAAR,CAAkBC,GAAlB,CAAsBF,SAAtB;GADF,MAEO;QACDrC,OAAO,CAACqC,SAAR,CAAkBG,OAAlB,CAA0BH,SAA1B,IAAuC,CAA3C,EAA8C;MAC5CrC,OAAO,CAACqC,SAAR,GAAoB,CAAIrC,OAAO,CAACqC,SAAR,MAAA,GAAqBA,SAAzB,EAAsCI,OAAtC,CAA8C,SAA9C,EAAyD,GAAzD,CAApB;;;;AAKN,kBAAyBzC,SAAsB0C;EAC7C9C,MAAM,CAACC,IAAP,CAAY6C,MAAZ,EAAoBhD,OAApB,CAA4B,UAAAiD,QAAA;IAC1B3C,OAAO,CAACsB,KAAR,CAAcqB,QAAd,IAA0BD,MAAM,CAACC,QAAD,CAAhC;GADF;;AAKF,eAAsBC,KAAaC,KAAaC;SACvCC,IAAI,CAACD,GAAL,CAASC,IAAI,CAACF,GAAL,CAASD,GAAT,EAAcE,GAAd,CAAT,EAA6BD,GAA7B,CAAP;;;AAIF,mBAA0BD,KAAaC,KAAaC;SAC3CF,GAAG,IAAIC,GAAP,IAAcD,GAAG,IAAIE,GAA5B;;AAQF,iBAA2BE;SAClB,GAAGC,KAAH,CAASC,IAAT,CAAcF,QAAd,CAAP;;AAGF,iBAAwBG;SACfA,GAAG,IAAIA,GAAG,CAACC,WAAJ,KAAoBnD,KAAlC;;AAGF,mCAA0CoD,UAA2BC,MAAcC;;MAE3EC,YAAY,GAAGD,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkCD,IAAI,GAAG,CAA9D;MACMG,QAAQ,GAAG,wCAAjB;;MAEI,OAAOJ,QAAP,KAAoB,QAAxB,EAAkC;WACzBK,KAAK,CAACL,QAAD,EAAW,CAAX,EAAcC,IAAd,CAAZ;;;MAGEK,GAAG,GAAG,CAAV;MACIC,eAAe,GAAG,CAAtB;MACIC,WAAW,GAAGJ,QAAQ,CAACK,IAAT,CAAcT,QAAd,CAAlB;;SACOQ,WAAW,IAAI,IAAtB,EAA4B;QACtBE,IAAI,GAAGF,WAAW,CAAC,CAAD,CAAtB;QACM9D,KAAK,GAAG8D,WAAW,CAAC,CAAD,CAAzB;QACMG,IAAI,GAAGH,WAAW,CAAC,CAAD,CAAxB;QAEII,WAAW,GAAGC,UAAU,CAACnE,KAAD,CAA5B;;QAEI4D,GAAG,IAAI,CAAX,EAAc;MACZI,IAAI,GAAGA,IAAI,IAAI,GAAf;KARwB;;;QAYtB,CAACA,IAAL,EAAW;aACFP,YAAP;;;QAGEQ,IAAI,KAAK,GAAb,EAAkB;MAChBC,WAAW,GAAIA,WAAW,GAAG,GAAf,GAAsBX,IAApC;;;IAGFM,eAAe,IAAIG,IAAI,KAAK,GAAT,GACfE,WADe,GAEf,CAACA,WAFL,CApB0B;;MAyBxBN,GAAF;IACAE,WAAW,GAAGJ,QAAQ,CAACK,IAAT,CAAcT,QAAd,CAAd;;;;MAIEM,GAAG,KAAK,CAAZ,EAAe;WACNH,YAAP;;;;SAIKE,KAAK,CAACE,eAAD,EAAkB,CAAlB,EAAqBN,IAArB,CAAZ;;AAGF,qBAA4Ba,KAAaC;;;MAGhCvB,cAAA;MAAKwB,iBAAL;MAAavB,cAAb;;MAEHqB,GAAG,GAAGE,MAAN,IAAiBvB,GAAG,GAAGuB,MAA3B,EAAoC;;WAE3B,CAACF,GAAG,GAAGE,MAAP,KAAkBvB,GAAG,GAAGuB,MAAxB,CAAP;GAFF,MAGO,IAAIF,GAAG,GAAGE,MAAN,IAAiBA,MAAM,GAAGxB,GAA9B,EAAoC;;WAElC,CAACsB,GAAG,GAAGE,MAAP,KAAkBA,MAAM,GAAGxB,GAA3B,CAAP;GAFK,MAGA,IAAIsB,GAAG,KAAKE,MAAR,IAAkBvB,GAAG,GAAGD,GAA5B,EAAiC;WAC/B,CAACsB,GAAG,GAAGtB,GAAP,KAAeC,GAAG,GAAGD,GAArB,CAAP;;;SAEK,CAAP;;AAGF,mBAA6BG,UAAesB;OACrC,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,QAAQ,CAACZ,MAA7B,EAAqCmC,CAAC,IAAI,CAA1C,EAA6C;QACrCvE,OAAO,GAAGgD,QAAQ,CAACuB,CAAD,CAAxB;;QACIvE,OAAO,IAAIsE,QAAQ,CAACtE,OAAD,CAAvB,EAAkC;aACzBuE,CAAP;;;;SAIG,CAAC,CAAR;;;AAIF,iBAAwBzB;MAChB0B,YAAY,GAAa,EAA/B;;OACK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,GAApB,EAAyByB,CAAC,IAAI,CAA9B,EAAiC;IAC/BC,YAAY,CAACD,CAAD,CAAZ,GAAkBA,CAAlB;;;SAEKC,YAAP;;;AC5MK,IAAMC,yBAAyB,GAGlC;EACFC,IAAI,EAAE;IACJC,IAAI,EAAE,MADF;IAEJC,KAAK,EAAE;GAHP;EAKFC,UAAU,EAAE;IACVF,IAAI,EAAE;;CATH;AAaP,AAAO,IAAMG,eAAe,GAA8B;EACxDC,WAAW,EAAE,UAD2C;EAExDC,YAAY,EAAE,MAF0C;EAGxDC,UAAU,EAAE,IAH4C;EAIxDC,QAAQ,EAAE,KAJ8C;EAKxDC,QAAQ,EAAE,KAL8C;EAMxDC,iBAAiB,EAAE,CANqC;EAOxDC,SAAS,EAAEC,QAP6C;EAQxDC,SAAS,EAAE,EAR6C;EASxDC,QAAQ,EAAE,GAT8C;EAUxDC,WAAW,EAAE,UAAAC,CAAA;WAAK,IAAI3C,IAAI,CAAC4C,GAAL,CAAS,IAAID,CAAb,EAAgB,CAAhB,CAAJ;GAVsC;EAWxDE,YAAY,EAAE,CAX0C;EAYxDC,SAAS,EAAE,CAAC,OAAD,EAAU,OAAV,CAZ6C;EAaxDC,cAAc,EAAE,EAbwC;EAcxDC,MAAM,EAAE,EAdgD;EAexDC,UAAU,EAAE,KAf4C;EAgBxDC,QAAQ,EAAE,KAhB8C;EAiBxDC,MAAM,EAAE,IAjBgD;EAkBxDC,KAAK,EAAE,KAlBiD;EAmBxDC,QAAQ,EAAE,KAnB8C;EAoBxDC,MAAM,EAAE,KApBgD;EAqBxDC,MAAM,EAAE,KArBgD;EAsBxDC,GAAG,EAAE,CAtBmD;EAuBxDC,QAAQ,EAAE/B,yBAAyB,CAACC;CAvB/B;AA0BP,AAAO,IAAM+B,oBAAoB,GAAG;EAClCC,QAAQ,EAAE,UADwB;EAElCR,MAAM,EAAEpB,eAAe,CAACoB,MAFU;EAGlCS,KAAK,EAAE,MAH2B;EAIlCC,MAAM,EAAE,MAJ0B;;EAMlCR,QAAQ,EAAE;CANL;AASP,AAAO,IAAMS,kBAAkB,GAAG;EAChCF,KAAK,EAAE,MADyB;EAEhCC,MAAM,EAAE,MAFwB;EAGhCE,UAAU,EAAE;CAHP;AAMP,AAAO,IAAMC,iBAAiB,GAAG;EAC/BL,QAAQ,EAAE;CADL;AAIP,AAAO,IAAMM,MAAM,GAAc;EAC/BC,UAAU,EAAE,WADmB;EAE/BC,QAAQ,EAAE,SAFqB;EAG/BC,UAAU,EAAE,WAHmB;EAI/BC,IAAI,EAAE,MAJyB;EAK/BC,QAAQ,EAAE,SALqB;EAM/BC,MAAM,EAAE,QANuB;EAO/BC,OAAO,EAAE,SAPsB;EAQ/BC,MAAM,EAAE,QARuB;EAS/BC,UAAU,EAAE,WATmB;EAU/BC,IAAI,EAAE;CAVD;AAaP,AAAO,IAAMC,WAAW,GAAkB;EACxCC,IAAI,EAAE,MADkC;EAExCN,MAAM,EAAE,QAFgC;EAGxCO,OAAO,EAAE,SAH+B;EAIxCC,aAAa,EAAE,cAJyB;EAKxCC,MAAM,EAAE;CALH;AAQP,AAAO,IAAMC,UAAU,GAAc;EACnCC,IAAI,EAAE,CAD6B;EAEnCC,OAAO,EAAE,CAF0B;EAGnCC,QAAQ,EAAE,CAHyB;EAInCC,SAAS,EAAE,CAJwB;EAKnCC,QAAQ,EAAE;CALL;AAQP,AAAO,IAAMC,SAAS,GAAc;EAClCC,IAAI,EAAE,MAD4B;EAElCC,IAAI,EAAE;CAFD;AAKP,AAAO,IAAMC,SAAS,GAAG5H,qBAAqB,EAAvC;;AC3FP;;;gBAqBE,CACEb,OADF,EAEE0I,KAFF,EAGEC,OAHF;SAKO3I,OAAL,GAAeA,OAAf;SACK4I,WAAL,GAAmB,IAAnB;SACKC,WAAL,GAAmB,IAAnB;SAEKC,KAAL,GAAa;MACXJ,KAAK,OADM;MAEXhC,QAAQ,EAAE,CAFC;MAGXqC,sBAAsB,EAAE,CAHb;MAIXC,IAAI,EAAE,CAJK;MAKXC,YAAY,EAAE,EALH;MAMXC,OAAO,EAAE,KANE;MAOXC,UAAU,EAAE,CAAC,CAPF;MAQXC,aAAa,EAAE;QACb/G,SAAS,EAAErC,OAAO,CAACqJ,YAAR,CAAqB,OAArB,KAAiC,IAD/B;QAEb/H,KAAK,EAAEtB,OAAO,CAACqJ,YAAR,CAAqB,OAArB,KAAiC;OAV/B;MAYXC,UAAU,EAAE;KAZd;SAcKX,OAAL,GAAeA,OAAf;;QAEIA,OAAO,CAAC5D,WAAZ,EAAyB;MACvBwE,QAAQ,CAACvJ,OAAD,EAAa2I,OAAO,CAAC5D,WAAR,WAAb,CAAR;;;;IAIFyE,QAAQ,CAAC,KAAKxJ,OAAN,EAAe+G,iBAAf,CAAR;;;;;gBAGK,GAAP;QACQ+B,KAAK,GAAG,KAAKA,KAAnB;QACMW,IAAI,GAAG,KAAKC,OAAL,EAAb;IAEAZ,KAAK,CAACE,IAAN,GAAa,KAAKL,OAAL,CAAa1D,UAAb,GACTwE,IAAI,CAAC9C,KADI,GAET8C,IAAI,CAAC7C,MAFT;IAGAkC,KAAK,CAACC,sBAAN,GAA+BY,yBAAyB,CAAC,KAAKhB,OAAL,CAAarC,MAAd,EAAsBwC,KAAK,CAACE,IAA5B,CAAxD;;QAEI,CAACF,KAAK,CAACI,OAAX,EAAoB;MAClBJ,KAAK,CAACG,YAAN,CAAmBvJ,OAAnB,CAA2B,UAAAkK,KAAA;eAASA,KAAK,CAACC,MAAN,EAAA;OAApC;;GAVG;;eAcA,GAAP;SACOf,KAAL,CAAWQ,UAAX,GAAwB,IAAxB;GADK;;iBAIA,GAAP;QACQlJ,EAAE,GAAG,KAAKJ,OAAhB;QACMoJ,aAAa,GAAG,KAAKN,KAAL,CAAWM,aAAjC;IAEAA,aAAa,CAAC/G,SAAd,GACIjC,EAAE,CAAC0J,YAAH,CAAgB,OAAhB,EAAyBV,aAAa,CAAC/G,SAAvC,CADJ,GAEIjC,EAAE,CAAC2J,eAAH,CAAmB,OAAnB,CAFJ;IAGAX,aAAa,CAAC9H,KAAd,GACIlB,EAAE,CAAC0J,YAAH,CAAgB,OAAhB,EAAyBV,aAAa,CAAC9H,KAAvC,CADJ,GAEIlB,EAAE,CAAC2J,eAAH,CAAmB,OAAnB,CAFJ;;SAKK,IAAMrE,CAAX,IAAgB,IAAhB,EAAsB;WACNA,CAAb,IAAkB,IAAlB;;GAbE;;oBAiBA,GAAP;WACS,KAAK1F,OAAZ;GADK;;2BAIA,GAAP;WACS,KAAK8I,KAAL,CAAWpC,QAAX,GAAsB,KAAKoC,KAAL,CAAWC,sBAAxC;GADK;;mCAIA,GAAP;WACS,KAAKD,KAAL,CAAWC,sBAAlB;GADK;;kBAIA,GAAP;WACS,KAAKD,KAAL,CAAWJ,KAAlB;GADK;;qBAIA,GAAP;WACS,KAAKI,KAAL,CAAWpC,QAAlB;GADK;;iBAIA,GAAP;WACS,KAAKoC,KAAL,CAAWE,IAAlB;GADK;;iBAIA,GAAP;QACQF,KAAK,GAAG,KAAKA,KAAnB;;QACI,CAACA,KAAK,CAACQ,UAAX,EAAuB;MACrBR,KAAK,CAACQ,UAAN,GAAmB,KAAKtJ,OAAL,CAAagK,qBAAb,EAAnB;;;WAEKlB,KAAK,CAACQ,UAAb;GALK;;iBAQA,GAAP;WACS,KAAKR,KAAL,CAAWI,OAAlB;GADK;;uBAIA,GAAP;WACS,KAAKJ,KAAL,CAAWK,UAAlB;GADK;;yBAIA,GAAP;QACQL,KAAK,GAAG,KAAKA,KAAnB;WAEOA,KAAK,CAACI,OAAN,GACH,KAAKe,QAAL,CAAeC,eAAf,EADG,GAEHpB,KAAK,CAACG,YAFV;GAHK;;4BAQA,GAAP;QACQH,KAAK,GAAG,KAAKA,KAAnB;WAEOA,KAAK,CAACI,OAAN,GACH,KAAKe,QAAL,CAAeE,kBAAf,EADG,IAEF,aAASrB,KAAK,CAACG,aAFpB;GAHK;;0BAQA,GAAP;WACS,KAAKH,KAAL,CAAWI,OAAX,GACH,KAAKe,QADF,GAEH,IAFJ;GADK;;kBAMA,GAAP,UAAgBvB,KAAhB;QACQI,KAAK,GAAG,KAAKA,KAAnB;IAEAA,KAAK,CAACJ,KAAN,GAAcA,KAAd;IACAI,KAAK,CAACG,YAAN,CAAmBvJ,OAAnB,CAA2B,UAAAkK,KAAA;aAASA,KAAK,CAACd,KAAN,CAAYJ,KAAZ,GAAoBA,KAApB;KAApC;GAJK;;qBAOA,GAAP,UAAmBvE,GAAnB;QACQ2E,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QACMyB,YAAY,GAAG,KAAKpK,OAAL,CAAasB,KAAlC;IAEAwH,KAAK,CAACpC,QAAN,GAAiBvC,GAAjB;IACAwE,OAAO,CAAC1D,UAAR,GACImF,YAAY,CAACC,IAAb,GAAuBlG,GAAG,OAD9B,GAEIiG,YAAY,CAACE,GAAb,GAAsBnG,GAAG,OAF7B;GANK;;eAWA,GAAP,UAAagF,UAAb;QACQL,KAAK,GAAG,KAAKA,KAAnB;QAEMyB,YAAY,GAAG,KAAKvK,OAAL,CAAawK,SAAb,CAAuB,IAAvB,CAArB;QACMC,WAAW,GAAG,IAAIC,KAAJ,CAAUH,YAAV,EAAwBzB,KAAK,CAACJ,KAA9B,EAAqC,KAAKC,OAA1C,CAApB;QACMgC,WAAW,GAAGF,WAAW,CAAC3B,KAAhC;IAEA2B,WAAW,CAACR,QAAZ,GAAuB,IAAvB;IACAU,WAAW,CAACzB,OAAZ,GAAsB,IAAtB;IACAyB,WAAW,CAACxB,UAAZ,GAAyBA,UAAzB;;IAEAwB,WAAW,CAAC3B,IAAZ,GAAmBF,KAAK,CAACE,IAAzB;IACA2B,WAAW,CAAC5B,sBAAZ,GAAqCD,KAAK,CAACC,sBAA3C;IACA4B,WAAW,CAACvB,aAAZ,GAA4BN,KAAK,CAACM,aAAlC;IACAuB,WAAW,CAACrB,UAAZ,GAAyBR,KAAK,CAACQ,UAA/B;IACAR,KAAK,CAACG,YAAN,CAAmBvI,IAAnB,CAAwB+J,WAAxB;WAEOA,WAAP;GAjBK;;gBAoBA,GAAP;QACQzK,OAAO,GAAG,KAAKA,OAArB;IACAA,OAAO,CAAC4K,UAAR,CAAoB5I,WAApB,CAAgChC,OAAhC;;QAEI,CAAC,KAAK8I,KAAL,CAAWI,OAAhB,EAAyB;WAClB2B,uBAAL,CAA6B,CAA7B;;GALG;;iCASA,GAAP,UAA+BC,KAA/B;QACQhC,KAAK,GAAG,KAAKA,KAAnB;QACMiC,cAAc,GAAGjC,KAAK,CAACG,YAAN,CAAmB+B,MAAnB,CAA0BF,KAA1B,CAAvB;IAEAC,cAAc,CAACrL,OAAf,CAAuB,UAAAkK,KAAA;MACrBA,KAAK,CAACqB,MAAN;KADF;GAJK;;cAQT;GA9MA;;ACAA;;;uBAaE,CACEC,aADF,EAEEvC,OAFF;SAIOuC,aAAL,GAAqBA,aAArB;SACKC,MAAL,GAAc,EAAd;SACKC,MAAL,GAAc,EAAd;SACKhH,KAAL,GAAa;MACXvB,GAAG,EAAE,CAAC,CADK;MAEXC,GAAG,EAAE,CAAC;KAFR;SAIKV,MAAL,GAAc,CAAd;SACKuG,OAAL,GAAeA,OAAf;SACKtD,SAAL,GAAiBsD,OAAO,CAACtD,SAAzB;;;;;oBAGK,GAAP;WACS,KAAK8F,MAAL,CAAY,KAAK/G,KAAL,CAAWvB,GAAvB,CAAP;GADK;;mBAIA,GAAP;WACS,KAAKsI,MAAL,CAAY,KAAK/G,KAAL,CAAWtB,GAAvB,CAAP;GADK;;mBAIA,GAAP;WAEO,KAAKqI,MAAL,OAAA,CACA,KAAKlC,YAAL,EADA,CADL;GADK;;wBAOA,GAAP;WACS,KAAKkC,MAAZ;GADK;;sBAIA,GAAP;WACS,KAAKC,MAAL,CAAYC,MAAZ,CAAmB,UAACC,SAAD,EAAYF,MAAZ;aAA2BE,SAAS,OAAT,CAAcF,MAAd,CAAJ;KAA1C,EAAqE,EAArE,CAAP;GADK;;aAIA,GAAP,UAAW1C,KAAX;WACS,CAAC,CAAC,KAAKyC,MAAL,CAAYzC,KAAZ,CAAT;GADK;;aAIA,GAAP,UAAWA,KAAX;WACS,KAAKyC,MAAL,CAAYzC,KAAZ,CAAP;GADK;;uBAIA,GAAP;WACS,KAAKtG,MAAZ;GADK;;sBAIA,GAAP;WACS,KAAKiD,SAAZ;GADK;;kBAIA,GAAP;WACS,KAAKjB,KAAZ;GADK;;uBAIA,GAAP;WACS,KAAKgH,MAAL,CAAYhJ,MAAnB;GADK;;sBAIA,GAAP,UAAoBiD,SAApB;SACOA,SAAL,GAAiBA,SAAjB;QAEMkG,UAAU,GAAG,KAAKA,UAAL,EAAnB;QACMC,SAAS,GAAG,KAAKA,SAAL,EAAlB;;QAEI,CAACD,UAAD,IAAe,CAACC,SAApB,EAA+B;aAAA;;;;QAKzBpH,KAAK,GAAG,KAAKA,KAAnB;;QACIoH,SAAS,CAACC,QAAV,KAAuBpG,SAA3B,EAAsC;UAC9B0F,cAAc,GAAG,KAAKI,MAAL,CAAYH,MAAZ,CAAmB3F,SAAS,GAAG,CAA/B,CAAvB;MACA0F,cAAc,CAACrL,OAAf,CAAuB,UAAAkK,KAAA;eAASA,KAAK,CAACqB,MAAN,EAAA;OAAhC;WACK7I,MAAL,IAAe2I,cAAc,CAAC3I,MAA9B;UAEMsJ,iBAAiB,GAAGX,cAAc,CAACY,MAAf,CAAsB,UAAA/B,KAAA;eAAS,CAAC,CAACA,KAAF;OAA/B,EAAwC,CAAxC,CAA1B;UACMgC,iBAAiB,GAAGF,iBAAiB,CAAC9C,WAA5C;;UACIgD,iBAAJ,EAAuB;QACrBxH,KAAK,CAACtB,GAAN,GAAY8I,iBAAiB,CAACH,QAAlB,EAAZ;OADF,MAEO;QACLrH,KAAK,CAACvB,GAAN,GAAY,CAAC,CAAb;QACAuB,KAAK,CAACtB,GAAN,GAAY,CAAC,CAAb;;;GAvBC;;gBA4BA,GAAP,UAAc+I,SAAd;QACQzH,KAAK,GAAG,KAAKA,KAAnB;;KACA0H,KAAA,KAAKX,MAAL,EAAYzK,IAAZ,MAAA,GAAA,EAAoBmL,SAApB;;QAEIA,SAAS,CAACzJ,MAAV,GAAmB,CAAvB,EAA0B;MACxBgC,KAAK,CAACvB,GAAN,GAAYE,IAAI,CAACD,GAAL,CAAS,CAAT,EAAYsB,KAAK,CAACvB,GAAlB,CAAZ;MACAuB,KAAK,CAACtB,GAAN,IAAa+I,SAAS,CAACzJ,MAAvB;WACKA,MAAL,IAAeyJ,SAAS,CAACzJ,MAAzB;;;;GAPG;;;;gBAaA,GAAP,UAAcsG,KAAd,EAA6BmD,SAA7B;QACQV,MAAM,GAAG,KAAKA,MAApB;QACM/G,KAAK,GAAG,KAAKA,KAAnB;QACM8G,aAAa,GAAG,KAAKA,aAA3B;QACMa,UAAU,GAAG,KAAKpD,OAAL,CAAazD,QAAhC;QACMG,SAAS,GAAG,KAAKA,SAAvB;;QAGMwD,WAAW,GAAG,KAAKmD,kBAAL,CAAwBtD,KAAxB,CAApB;;;QAIM6C,UAAU,GAAG,KAAKA,UAAL,EAAnB;QACMU,cAAc,GAAGpD,WAAW,GAC9BA,WAAW,CAACqD,UAAZ,EAD8B,GAE9BH,UAAU,IAAIR,UAAd,GACEA,UAAU,CAACrB,eAAX,GAA6B,CAA7B,EAAgCgC,UAAhC,EADF,GAEE,IAJN;;QAOMC,QAAQ,GAAG5L,QAAQ,CAAC6L,sBAAT,EAAjB;IACAP,SAAS,CAACnM,OAAV,CAAkB,UAAAkK,KAAA;aAASuC,QAAQ,CAACE,WAAT,CAAqBzC,KAAK,CAACsC,UAAN,EAArB,CAAA;KAA3B;IACAhB,aAAa,CAACxJ,YAAd,CAA2ByK,QAA3B,EAAqCF,cAArC;QAEIK,WAAW,GAAGT,SAAS,CAACzJ,MAA5B;;QAEIsG,KAAK,GAAGtE,KAAK,CAACtB,GAAlB,EAAuB;MACrB+I,SAAS,CAACnM,OAAV,CAAkB,UAACkK,KAAD,EAAQ2C,MAAR;QAChBpB,MAAM,CAACzC,KAAK,GAAG6D,MAAT,CAAN,GAAyB3C,KAAzB;OADF;KADF,MAIO;UACC4C,gBAAgB,GAAGrB,MAAM,CAAClI,KAAP,CAAayF,KAAb,EAAoBA,KAAK,GAAGmD,SAAS,CAACzJ,MAAtC,CAAzB,CADK;;UAGDqK,eAAe,GAAGC,SAAS,CAACF,gBAAD,EAAmB,UAAA5C,KAAA;eAAS,CAAC,CAACA,KAAF;OAA5B,CAA/B;;UACI6C,eAAe,GAAG,CAAtB,EAAyB;;QAEvBA,eAAe,GAAGD,gBAAgB,CAACpK,MAAnC;;;MAEFkK,WAAW,GAAGT,SAAS,CAACzJ,MAAV,GAAmBqK,eAAjC,CARK;;MAWLtB,MAAM,CAACH,MAAP,MAAA,CAAAG,MAAA,GAAczC,OAAO+D,wBAAoBZ,UAAzC,EAXK;;UAcDV,MAAM,CAAC/I,MAAP,GAAgBiD,SAAS,GAAG,CAAhC,EAAmC;YAC3BsH,aAAa,GAAGxB,MAAM,CAACH,MAAP,CAAc3F,SAAS,GAAG,CAA1B,EACnBsG,MADmB,CACZ,UAAA/B,KAAA;iBAASgD,OAAO,CAAChD,KAAD,CAAP;SADG,CAAtB;QAEA+C,aAAa,CAACjN,OAAd,CAAsB,UAAAkK,KAAA;iBAASA,KAAK,CAACqB,MAAN,EAAA;SAA/B;aACK7I,MAAL,IAAeuK,aAAa,CAACvK,MAA7B;;;;;QAKAkK,WAAW,GAAG,CAAlB,EAAqB;MACnBnB,MAAM,CAAClI,KAAP,CAAayF,KAAK,GAAGmD,SAAS,CAACzJ,MAA/B,EAAuC1C,OAAvC,CAA+C,UAAAkK,KAAA;QAC7CA,KAAK,CAACiD,QAAN,CAAejD,KAAK,CAAC6B,QAAN,KAAmBa,WAAlC;OADF;;;QAKEP,UAAJ,EAAgB;WACTe,YAAL,CAAkBpE,KAAlB,EAAyBmD,SAAzB,EAAoCA,SAAS,CAACzJ,MAAV,GAAmBkK,WAAvD,EAAoEzD,WAApE;;;;SAIGzG,MAAL,IAAeyJ,SAAS,CAACzJ,MAAzB;SACK2K,WAAL,CAAiBrE,KAAjB;WAEO4D,WAAP;GAnEK;;iBAsEA,GAAP,UAAe5D,KAAf,EAA8BmD,SAA9B;QACQV,MAAM,GAAG,KAAKA,MAApB;QACM/G,KAAK,GAAG,KAAKA,KAAnB;QACM8G,aAAa,GAAG,KAAKA,aAA3B;QACMa,UAAU,GAAG,KAAKpD,OAAL,CAAazD,QAAhC;;QAGM2D,WAAW,GAAG,KAAKmD,kBAAL,CAAwBtD,KAAK,GAAGmD,SAAS,CAACzJ,MAA1C,CAApB;;;QAIMmJ,UAAU,GAAG,KAAKA,UAAL,EAAnB;QACMU,cAAc,GAAGpD,WAAW,GAC9BA,WAAW,CAACqD,UAAZ,EAD8B,GAE9BH,UAAU,IAAIR,UAAd,GACEA,UAAU,CAACrB,eAAX,GAA6B,CAA7B,EAAgCgC,UAAhC,EADF,GAEE,IAJN;;QAOMC,QAAQ,GAAG5L,QAAQ,CAAC6L,sBAAT,EAAjB;IACAP,SAAS,CAACnM,OAAV,CAAkB,UAAAkK,KAAA;aAASuC,QAAQ,CAACE,WAAT,CAAqBzC,KAAK,CAACsC,UAAN,EAArB,CAAA;KAA3B;IACAhB,aAAa,CAACxJ,YAAd,CAA2ByK,QAA3B,EAAqCF,cAArC;;QAEIvD,KAAK,GAAGtE,KAAK,CAACtB,GAAlB,EAAuB;;MAEpBqI,MAAM,CAACzC,KAAD,CAAN,GAAwB,IAAxB;;;QAGGsE,cAAc,GAAG7B,MAAM,CAACH,MAAP,MAAA,CAAAG,MAAA,GAAczC,OAAOmD,SAAS,CAACzJ,eAAWyJ,UAA1C,CAAvB;QACMoB,gBAAgB,GAAGD,cAAc,CAACrB,MAAf,CAAsB,UAAA/B,KAAA;aAASgD,OAAO,CAAChD,KAAD,CAAP;KAA/B,EAA+CxH,MAAxE;IACA4K,cAAc,CAACtN,OAAf,CAAuB,UAAAkK,KAAA;UACjBA,KAAJ,EAAW;QACTA,KAAK,CAACqB,MAAN;;KAFJ;;;SAQK7I,MAAL,IAAeyJ,SAAS,CAACzJ,MAAV,GAAmB6K,gBAAlC;SACKF,WAAL,CAAiBrE,KAAjB;;QAEIqD,UAAJ,EAAgB;WACTe,YAAL,CAAkBpE,KAAlB,EAAyBmD,SAAzB,EAAoCA,SAAS,CAACzJ,MAA9C,EAAsDyG,WAAtD;;GA1CG;;gBA8CA,GAAP,UAAcH,KAAd,EAA6BwE,WAA7B;8BAA6B,EAAA;MAAAA,eAAA;;;QACrBnB,UAAU,GAAG,KAAKpD,OAAL,CAAazD,QAAhC;QACMiG,MAAM,GAAG,KAAKA,MAApB;QACMC,MAAM,GAAG,KAAKA,MAApB;;IAEA8B,WAAW,GAAGnK,IAAI,CAACD,GAAL,CAASoK,WAAT,EAAsB,CAAtB,CAAd;QAEMC,aAAa,GAAGhC,MAAM,CACzBH,MADmB,CACZtC,KADY,EACLwE,WADK,EAEnBvB,MAFmB,CAEZ,UAAA/B,KAAA;aAAS,CAAC,CAACA,KAAF;KAFG,CAAtB;IAIAuD,aAAa,CAACzN,OAAd,CAAsB,UAAAkK,KAAA;MACpBA,KAAK,CAACqB,MAAN;KADF;;QAIIc,UAAJ,EAAgB;MACdX,MAAM,CAAC1L,OAAP,CAAe,UAAA0N,QAAA;QACbA,QAAQ,CAACpC,MAAT,CAAgBtC,KAAhB,EAAuBwE,WAAvB;OADF;;;;IAMF/B,MAAM,CACHlI,KADH,CACSyF,KADT,EAEGhJ,OAFH,CAEW,UAAAkK,KAAA;MACPA,KAAK,CAACiD,QAAN,CAAejD,KAAK,CAAC6B,QAAN,KAAmByB,WAAlC;KAHJ;;QAOI7H,SAAS,GAAG8F,MAAM,CAAC/I,MAAP,GAAgB,CAAhC;;QACI,CAAC+I,MAAM,CAAC9F,SAAD,CAAX,EAAwB;UAChBgI,cAAc,GAAGlC,MAAM,CAACmC,MAAP,GAAgBC,OAAhB,EAAvB;UACMC,qBAAqB,GAAGd,SAAS,CAACW,cAAD,EAAiB,UAAAzD,KAAA;eAAS,CAAC,CAACA,KAAF;OAA1B,CAAvC;MACAvE,SAAS,GAAGmI,qBAAqB,GAAG,CAAxB,GACR,CAAC,CADO;QAERnI,SAAS,GAAGmI,qBAFhB,CAHsB;;MAQtBrC,MAAM,CAACH,MAAP,CAAc3F,SAAS,GAAG,CAA1B;;UACI0G,UAAJ,EAAgB;QACdX,MAAM,CAAC1L,OAAP,CAAe,UAAA0N,QAAA;UACbA,QAAQ,CAACpC,MAAT,CAAgB3F,SAAS,GAAG,CAA5B;SADF;;;;;SAOCjB,KAAL,GAAa;MACXvB,GAAG,EAAE6J,SAAS,CAACvB,MAAD,EAAS,UAAAvB,KAAA;eAAS,CAAC,CAACA,KAAF;OAAlB,CADH;MAEX9G,GAAG,EAAEuC;KAFP;SAIKjD,MAAL,IAAe+K,aAAa,CAAC/K,MAA7B;;QAEI,KAAKA,MAAL,IAAe,CAAnB,EAAsB;;WAEfgJ,MAAL,GAAc,EAAd;;;WAGK+B,aAAP;GA1DK;;wBA6DA,GAAP;QACQM,SAAS,GAAG,KAAKA,SAAL,GAAiB9B,MAAjB,CAAwB,UAAA/B,KAAA;aAAS,CAAC,CAACA,KAAF;KAAjC,CAAlB;QACM8D,cAAc,GAAGD,SAAS,CAACrL,MAAjC;;QAEIsL,cAAc,IAAI,CAAtB,EAAyB;;;;IAIzBD,SAAS,CAAC/N,OAAV,CAAkB,UAACkK,KAAD,EAAQjG,GAAR;UACVgK,SAAS,GAAIhK,GAAG,GAAG,CAAP,GACd8J,SAAS,CAAC9J,GAAG,GAAG,CAAP,CADK,GAEd,IAFJ;UAIMiK,SAAS,GAAIjK,GAAG,GAAG+J,cAAc,GAAG,CAAxB,GACdD,SAAS,CAAC9J,GAAG,GAAG,CAAP,CADK,GAEd,IAFJ;MAIAiG,KAAK,CAAChB,WAAN,GAAoB+E,SAApB;MACA/D,KAAK,CAACf,WAAN,GAAoB+E,SAApB;KAVF;;QAaI,KAAKjF,OAAL,CAAazD,QAAjB,EAA2B;UACnBqG,UAAU,GAAGkC,SAAS,CAAC,CAAD,CAA5B;UACMjC,SAAS,GAAGiC,SAAS,CAACC,cAAc,GAAG,CAAlB,CAA3B;MAEAnC,UAAU,CAAC3C,WAAX,GAAyB4C,SAAzB;MACAA,SAAS,CAAC3C,WAAV,GAAwB0C,UAAxB;;GA1BG;;sBA8BA,GAAP,UAAoBpC,UAApB,EAAwCT,KAAxC,EAAuDO,YAAvD,EAA8EiE,WAA9E;8BAA8E,EAAA;MAAAA,eAAA;;;QACtE9B,MAAM,GAAG,KAAKA,MAApB;QACM/F,SAAS,GAAG,KAAKA,SAAvB;;QAEI,CAAC+F,MAAM,CAACjC,UAAD,CAAX,EAAyB;UACjB0E,WAAS,GAAY,EAA3B;MACA5E,YAAY,CAACvJ,OAAb,CAAqB,UAACkK,KAAD,EAAQ2C,MAAR;QACnBsB,WAAS,CAACnF,KAAK,GAAG6D,MAAT,CAAT,GAA4B3C,KAA5B;OADF;MAIAwB,MAAM,CAACjC,UAAD,CAAN,GAAqB0E,WAArB;KANF,MAOO;UACCC,cAAY,GAAG1C,MAAM,CAACjC,UAAD,CAA3B;;UAEIT,KAAK,IAAIoF,cAAY,CAAC1L,MAA1B,EAAkC;QAChC6G,YAAY,CAACvJ,OAAb,CAAqB,UAACkK,KAAD,EAAQ2C,MAAR;UACnBuB,cAAY,CAACpF,KAAK,GAAG6D,MAAT,CAAZ,GAA+B3C,KAA/B;SADF;OADF,MAIO;QACLkE,cAAY,CAAC9C,MAAb,MAAA,CAAA8C,cAAA,GAAoBpF,OAAOwE,oBAAgBjE,aAA3C,EADK;;YAGDA,YAAY,CAAC7G,MAAb,GAAsBiD,SAAS,GAAG,CAAtC,EAAyC;UACvC4D,YAAY,CAAC+B,MAAb,CAAoB3F,SAAS,GAAG,CAAhC;;;;GAtBD;;;2BA6BA,GAAP,UAAyB8D,UAAzB;QACQgC,MAAM,GAAG,KAAKA,MAApB;IACAA,MAAM,CAACzL,OAAP,CAAe,UAAAkK,KAAA;MACbA,KAAK,CAACiB,uBAAN,CAA8B1B,UAA9B;KADF;SAGKiC,MAAL,CAAYJ,MAAZ,CAAmB7B,UAAnB;GALK;;;eASA,GAAP;SACOgC,MAAL,CAAYzL,OAAZ,CAAoB,UAAAkK,KAAA;MAClBA,KAAK,CAACqB,MAAN;MACArB,KAAK,CAACiB,uBAAN,CAA8B,CAA9B;KAFF;SAKKM,MAAL,GAAc,EAAd;SACKC,MAAL,GAAc,EAAd;SACKhJ,MAAL,GAAc,CAAd;SACKgC,KAAL,GAAa;MACXvB,GAAG,EAAE,CAAC,CADK;MAEXC,GAAG,EAAE,CAAC;KAFR;GATK;;oBAeA,GAAP;SACOqI,MAAL,CAAYzL,OAAZ,CAAoB,UAAAkK,KAAA;MAClBA,KAAK,CAACiB,uBAAN,CAA8B,CAA9B;KADF;SAGKO,MAAL,GAAc,EAAd;GAJK;;qBAOA,GAAP,UAAmBpL,OAAnB;QACQyN,SAAS,GAAG,KAAKA,SAAL,EAAlB;;SACoB,UAAA,EAAAM,uBAApB,EAAoBvO,uBAApB,EAAoBA,IAApB;UAAWoK,KAAK,kBAAX;;UACC,CAACA,KAAL,EAAY;;;;UAGNoE,YAAY,GAAGpE,KAAK,CAACsC,UAAN,EAArB;;UACI8B,YAAY,CAACC,QAAb,CAAsBjO,OAAtB,CAAJ,EAAoC;eAC3B4J,KAAP;;;GARC;;4BAaA,GAAP,UAA0BlB,KAA1B;SACsB,UAAA,EAAAoD,KAAA,KAAKX,MAAzB,EAAoB3L,cAApB,EAAoBA,IAApB;UAAWoK,KAAK,SAAX;;UACCA,KAAK,IAAIA,KAAK,CAAC6B,QAAN,MAAoB/C,KAAjC,EAAwC;eAC/BkB,KAAP;;;GAHC;;sBAQC,GAAR,UAAqBlB,KAArB,EAAoCwF,cAApC,EAA6DhB,WAA7D,EAAkFrE,WAAlF;QACQqC,aAAa,GAAG,KAAKA,aAA3B;QACMiD,UAAU,GAAG,KAAKC,aAAL,EAAnB;QACM5C,SAAS,GAAG,KAAKA,SAAL,EAAlB;QACM6C,eAAe,GAAY7C,SAAS,GACtCA,SAAS,CAACtB,eAAV,EADsC,GAEtC,EAFJ;QAGMoE,iBAAiB,GAAYzF,WAAW,GAC1CA,WAAW,CAACqB,eAAZ,EAD0C,GAE1C,EAFJ;;4BAIWf;UACHoF,gBAAgB,GAAGD,iBAAiB,CAACnF,UAAD,CAA1C;UACMqF,gBAAgB,GAAGH,eAAe,CAAClF,UAAD,CAAxC;UAEMsF,mBAAmB,GAAGF,gBAAgB,GACxCA,gBAAgB,CAACrC,UAAjB,EADwC,GAExCsC,gBAAgB,GACdA,gBAAgB,CAACtC,UAAjB,GAA8BwC,kBADhB,GAEd,IAJN;UAMMC,SAAS,GAAGT,cAAc,CAACU,GAAf,CAAmB,UAAAhF,KAAA;YAC7BiF,KAAK,GAAGjF,KAAK,CAACiF,KAAN,CAAY1F,UAAZ,CAAd;QAEA+B,aAAa,CAACxJ,YAAd,CAA2BmN,KAAK,CAAC3C,UAAN,EAA3B,EAA+CuC,mBAA/C;eACOI,KAAP;OAJgB,CAAlB;MAOAC,OAAKC,YAAL,CAAkB5F,UAAlB,EAA8BT,KAA9B,EAAqCiG,SAArC,EAAgDzB,WAAhD;;;;;SAjBuB,UAAA,EAAApB,KAAAkD,OAAO,CAACb,UAAD,CAAhC,EAAyB3O,cAAzB,EAAyBA,IAAzB;UAAW2J,UAAU,SAAhB;;cAAMA;;GAXL;;qBAgCA,GAAR,UAAoB8F,cAApB;QACQ9D,MAAM,GAAG,KAAKA,MAApB;QACM/G,KAAK,GAAG,KAAKA,KAAnB;QAEM8K,YAAY,GAAG/D,MAAM,CAAC/I,MAAP,GAAgB,CAArC;;QACI8M,YAAY,GAAG9K,KAAK,CAACtB,GAAzB,EAA8B;MAC5BsB,KAAK,CAACtB,GAAN,GAAYoM,YAAZ;;;QAEED,cAAc,GAAG7K,KAAK,CAACvB,GAAvB,IAA8BuB,KAAK,CAACvB,GAAN,GAAY,CAA9C,EAAiD;MAC/CuB,KAAK,CAACvB,GAAN,GAAYoM,cAAZ;;GATI;;qBAYV;GAjcA;;ACDA;;;gBAAA;cACS,GAAgB,CAAhB;kBACA,GAAuC,IAAvC;oBACA,GAA4B,IAA5B;qBACA,GAAuB,CAAvB;;;;;iBAKA,GAAP,UAAeE,SAAf;SACOC,KAAL,GAAaD,SAAS,CAACC,KAAvB;SACKC,SAAL,GAAiBF,SAAS,CAACE,SAA3B;SACKC,WAAL,GAAmBH,SAAS,CAACG,WAA7B;SACKC,YAAL,GAAoBJ,SAAS,CAACI,YAA9B;GAJK;;gBAMA,GAAP,UAAcC,SAAd;GAAO;;gBAGA,GAAP,UAAcC,CAAd,EAAsBC,OAAtB;GAAO;;kBAGA,GAAP,UAAgBD,CAAhB,EAAwBC,OAAxB;GAAO;;mBAGA,GAAP,UAAiBD,CAAjB,EAAyBC,OAAzB;GAAO;;wBAGA,GAAP,UAAsBD,CAAtB,EAA8BC,OAA9B;GAAO;;kBAGA,GAAP,UAAgBD,CAAhB,EAAwBC,OAAxB;GAAO;;cAGT;GAjCA;;ACCA;;;EAAwBC,SAAA,UAAA,QAAA;;oBAAxB;wEAAA;;IACkBC,UAAA,GAAO5H,UAAU,CAACC,IAAlB;IACA2H,aAAA,GAAU,KAAV;IACAA,aAAA,GAAU,KAAV;;;;;;iBAET,GAAP;SACOP,SAAL,GAAiB,IAAjB;SACKC,WAAL,GAAmB,IAAnB;SACKF,KAAL,GAAa,CAAb;SACKG,YAAL,GAAoB,CAApB;GAJK;;gBAOA,GAAP,UAAcE,CAAd,EAAsB3D,EAAtB;QAAwB+D;QAAUC;QAAcC;;QAE1CF,QAAQ,CAACG,aAAT,MAA4B,CAAhC,EAAmC;MACjCD,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;;;;IAIFyH,YAAY,CAAC9I,MAAM,CAACC,UAAR,EAAoBwI,CAApB,EAAuB,IAAvB,CAAZ,CACGQ,SADH,CACa;MACTF,SAAS,CAAC/H,UAAU,CAACE,OAAZ,CAAT;KAFJ,EAIGgI,SAJH,CAIa;MACTH,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;KALJ;GAPK;;;kBAiBA,GAAP,UAAgBoH,CAAhB,EAAwBC,OAAxB;QACUI,mCAAA;QAAcC,6BAAd;IAERD,YAAY,CAAC9I,MAAM,CAACG,UAAR,EAAoBsI,CAApB,EAAuB,KAAvB,CAAZ,CACGQ,SADH,CACa;;MAETF,SAAS,CAAC/H,UAAU,CAACI,SAAZ,CAAT,CACG+H,QADH,CACYV,CADZ,EACeC,OADf;KAHJ,EAMGQ,SANH,CAMa;MACTH,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;KAPJ;GAHK;;kBAaT;EA1CwB+H,MAAxB;;ACAA;;;EAA2BT,SAAA,aAAA,QAAA;;uBAA3B;wEAAA;;IACkBC,UAAA,GAAO5H,UAAU,CAACE,OAAlB;IACA0H,aAAA,GAAU,IAAV;IACAA,aAAA,GAAU,IAAV;IAERA,kBAAA,GAAoB,IAApB;;;;;;kBAED,GAAP,UAAgBH,CAAhB,EAAwBC,OAAxB;QACUG,2BAAA;QAAUC,mCAAV;QAAwBC,6BAAxB;QAEFxD,MAAM,GAAGsD,QAAQ,CAAClH,OAAT,CAAiB1D,UAAjB,GACXwK,CAAC,CAACY,UAAF,CAAaC,OADF,GAEXb,CAAC,CAACY,UAAF,CAAaE,OAFjB;SAGKlB,SAAL,GAAiB9C,MAAM,GAAG,CAAT,GACbjE,SAAS,CAACE,IADG,GAEbF,SAAS,CAACC,IAFd;IAIAuH,YAAY,CAAC9I,MAAM,CAACG,UAAR,EAAoBsI,CAApB,EAAuB,IAAvB,CAAZ,CACGQ,SADH,CACa;;MAETF,SAAS,CAAC/H,UAAU,CAACG,QAAZ,CAAT,CACGgI,QADH,CACYV,CADZ,EACeC,OADf;KAHJ,EAMGQ,SANH,CAMa;MACTH,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;KAPJ;GAVK;;mBAqBA,GAAP,UAAiBoH,CAAjB,EAAyBC,OAAzB;QACUc,2BAAA;QAAUV,mCAAV;QAAwBC,6BAAxB;IAERD,YAAY,CAAC9I,MAAM,CAACE,QAAR,EAAkBuI,CAAlB,EAAqB,IAArB,CAAZ;;QAEIA,CAAC,CAACL,KAAF,CAAQqB,KAAR,KAAkB,CAAtB,EAAyB;;;;;;MAOvBhB,CAAC,CAACiB,KAAF,CAAQ;QAAED,KAAK,EAAED,QAAQ,CAACG,iBAAT;OAAjB,EAAiD,CAAjD;MACAZ,SAAS,CAAC/H,UAAU,CAACC,IAAZ,CAAT;;;;;;SAMG2I,YAAL,GAAoBnB,CAApB;GAnBK;;kBAsBA,GAAP,UAAgBA,CAAhB,EAAwB3D,EAAxB;QAA0B0E;QAAUV;QAAcC;;;IAGhDA,SAAS,CAAC/H,UAAU,CAACC,IAAZ,CAAT;;QAEI,CAAC,KAAK2I,YAAV,EAAwB;;;;;;QAMlBA,YAAY,GAAG,KAAKA,YAA1B;;QAGMC,cAAc,GAAGD,YAAY,CAACP,UAAb,CAAwBS,QAAxB,CAAiCvR,MAAxD;QACMwR,YAAY,GAAGP,QAAQ,CAACQ,YAAT,CAAsBC,WAAtB,CAAkCJ,cAAlC,CAArB;QACMK,cAAc,GAAGV,QAAQ,CAACG,iBAAT,EAAvB;;QAEII,YAAJ,EAAkB;UACVI,oBAAoB,GAAGJ,YAAY,CAACK,WAAb,EAA7B;UACM/B,SAAS,GAAG8B,oBAAoB,GAAGD,cAAvB,GACd5I,SAAS,CAACE,IADI,GAEd2I,oBAAoB,GAAGD,cAAvB,GACE5I,SAAS,CAACC,IADZ,GAEE,IAJN,CAFgB;;MAShBuH,YAAY,CAAC9I,MAAM,CAACQ,MAAR,EAAgB,IAAhB,EAAsB,IAAtB,EAA4B;QACtC6H,SAAS,WAD6B;QAEtC3G,KAAK,EAAEqI,YAAY,CAACtF,QAAb,EAF+B;QAGtC7B,KAAK,EAAE4G,QAAQ,CAACa,mBAAT,CAA6BN,YAA7B;OAHG,CAAZ;;GA3BG;;qBAkCT;EApF2BX,MAA3B;;ACGA;;;EAA4BT,SAAA,cAAA,QAAA;;wBAA5B;wEAAA;;IACkBC,UAAA,GAAO5H,UAAU,CAACG,QAAlB;IACAyH,aAAA,GAAU,IAAV;IACAA,aAAA,GAAU,IAAV;;;;;;iBAET,GAAP,UAAeT,SAAf;IACEmC,gBAAA,CAAMC,OAAN,KAAA,KAAA,EAAcpC,SAAd;;SACKC,KAAL,GAAa,CAAb;GAFK;;kBAKA,GAAP,UAAgBK,CAAhB,EAAwB3D,EAAxB;QAA0B0F;QAAYzB;;QAChC,CAACN,CAAC,CAACL,KAAF,CAAQqB,KAAb,EAAoB;;;;IAIpBe,UAAU,CAAC/B,CAAD,CAAV,CACGS,SADH,CACa;MACTH,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;KAFJ;GALK;;mBAWA,GAAP,UAAiBoH,CAAjB,EAAyBC,OAAzB;QACUG,2BAAA;QAAUW,2BAAV;QAAoBV,mCAApB;QAAkCC,6BAAlC;QAA6C0B,+BAA7C;QAEFrC,KAAK,GAAG,KAAKA,KAAnB;QACMzG,OAAO,GAAGkH,QAAQ,CAAClH,OAAzB;QACM1D,UAAU,GAAG0D,OAAO,CAAC1D,UAA3B;QACMyM,eAAe,GAAG/I,OAAO,CAACnD,QAAhC;QACMmM,OAAO,GAAGhJ,OAAO,CAACpC,GAAR,GAAc,CAA9B;QACMC,QAAQ,GAAGmC,OAAO,CAACnC,QAAzB;QACMoL,YAAY,GAAGpL,QAAQ,CAAC7B,IAAT,KAAkB,YAAvC;QACMkN,SAAS,GAAGD,YAAY,GAAGtM,QAAH,GAAekB,QAA+B,CAAC5B,KAA7E;QACMyL,UAAU,GAAGZ,CAAC,CAACY,UAArB;QACMyB,UAAU,GAAG/O,IAAI,CAACgP,GAAL,CAAStC,CAAC,CAACL,KAAF,CAAQqB,KAAjB,CAAnB;QAEMuB,QAAQ,GAAG/M,UAAU,GACvBoL,UAAU,CAAC4B,SADY,GAEvB5B,UAAU,CAAC6B,SAFf;QAGMC,UAAU,GAAGpP,IAAI,CAACgP,GAAL,CAAS9M,UAAU,GAAGoL,UAAU,CAAC+B,MAAd,GAAuB/B,UAAU,CAACgC,MAArD,CAAnB;QACMC,eAAe,GAAGvP,IAAI,CAACgP,GAAL,CAASC,QAAT,IAAqB,CAArB,GACpBA,QAAQ,GAAG,CADS,GAEpB5C,KAAK,GAAG,CAFZ;QAGMmD,aAAa,GAAGxP,IAAI,CAACD,GAAL,CAASC,IAAI,CAACgP,GAAL,CAAS3C,KAAT,CAAT,EAA0B+C,UAA1B,CAAtB;QACMK,UAAU,GAAGnC,UAAU,CAAC+B,MAAX,GACfrP,IAAI,CAACgP,GAAL,CAAS,MAAMhP,IAAI,CAAC0P,IAAL,CAAUpC,UAAU,CAACgC,MAAX,GAAoBhC,UAAU,CAAC+B,MAAzC,CAAN,GAAyDrP,IAAI,CAAC2P,EAAvE,CADe,GAEf,EAFJ;QAGMC,mBAAmB,GAAG1N,UAAU,GAClCuN,UAAU,IAAI7J,OAAO,CAAC7C,cADY,GAElC0M,UAAU,GAAG7J,OAAO,CAAC7C,cAFzB;QAGM8M,aAAa,GAAGL,aAAa,IAAI5J,OAAO,CAACpD,SAAzB,IACjBoN,mBADL;IAGA7C,YAAY,CAAC9I,MAAM,CAACE,QAAR,EAAkBuI,CAAlB,EAAqB,IAArB,CAAZ;;QAEI,CAACmD,aAAD,IAAkB,KAAKtD,WAA3B,EAAwC;;MAEtCkB,QAAQ,CAACqC,MAAT,CAAgB,KAAKvD,WAArB,EAAkCtI,MAAM,CAACU,IAAzC,EAA+C+H,CAA/C,EAAkD,KAAKF,YAAvD;MACAQ,SAAS,CAAC/H,UAAU,CAACI,SAAZ,CAAT;;;;QAII0K,YAAY,GAAGtC,QAAQ,CAACuC,eAAT,EAArB;QACMC,YAAY,GAAGxC,QAAQ,CAACyC,eAAT,EAArB;;QAEI,CAACH,YAAD,IAAiB,CAACE,YAAtB,EAAoC;;MAElCvD,CAAC,CAACyD,IAAF;MACAnD,SAAS,CAAC/H,UAAU,CAACC,IAAZ,CAAT;;;;;;;;;;;QAUEkL,uBAAuB,GAAGb,eAAe,GACzCQ,YAAY,CAACM,OAAb,KAAyBN,YAAY,CAACO,yBAAb,EAAzB,GAAoE1B,OAD3B,GAEzCmB,YAAY,CAACO,yBAAb,KAA2C1B,OAF/C;IAGAwB,uBAAuB,GAAGpQ,IAAI,CAACD,GAAL,CAASqQ,uBAAT,EAAkCxK,OAAO,CAACpD,SAA1C,CAA1B;QAEIC,QAAQ,GAAGkM,eAAf;QACI4B,WAAJ;QACI/G,MAAM,GAAW,CAArB;;QAEIqG,aAAJ,EAAmB;UACbf,SAAS,GAAG,CAAZ,IAAiBC,UAAU,GAAGqB,uBAAlC,EAA2D;YACnDI,SAAS,GAAG3B,YAAY,GAC1BoB,YAD0B,GAE1BxC,QAAQ,CAACgD,yBAAT,CAAmCV,YAAnC,CAFJ,CADyD;;YAMnDhH;;;;;UAAA;YAAE2H,kCAAF;YAAkBC,0BAAlB;YAA8BC,wBAA9B;;QAONL,WAAW,GAAGG,cAAd;QACAlH,MAAM,GAAGmH,UAAT;QACAlO,QAAQ,GAAG9B,KAAK,CAAC+L,CAAC,CAACjK,QAAH,EAAakM,eAAb,EAA8BA,eAAe,GAAGiC,SAAhD,CAAhB;OAfF,MAgBO,IACL,CAAC/B,YAAD,IACG,CAACpB,QAAQ,CAACoD,YAAT,EADJ,KAGErB,aAAa,IAAIY,uBAAjB;SAEGH,YAAY,CAACvH,QAAb,OAA4BqH,YAAY,CAACrH,QAAb,EALjC,CADK,EAQL;QACA6H,WAAW,GAAG,KAAKO,iBAAL,CAAuBvB,eAAvB,EAAwC9B,QAAxC,CAAd;OATK,MAUA;QACL8C,WAAW,GAAGN,YAAd;;KA5BJ,MA8BO;MACLM,WAAW,GAAG3K,OAAO,CAACzD,QAAR,GACV,KAAK4O,8BAAL,CAAoCxB,eAApC,EAAqD9B,QAArD,CADU,GAEVsC,YAFJ;;;QAKIiB,aAAa,GAAGT,WAAW,CAAClC,WAAZ,KAA4B7E,MAAlD;QACMyH,iBAAiB,GAAGD,aAAa,KAAKjB,YAAY,CAAC1B,WAAb,EAA5C;QACM6C,SAAS,GAAI,CAACrB,aAAD,IAAkBoB,iBAAnB,GACdpC,YAAY,GACV5K,MAAM,CAACU,IADG,GAEVV,MAAM,CAACO,OAHK,GAIdP,MAAM,CAACM,MAJX;IAMAkJ,QAAQ,CAACqC,MAAT,CACES,WADF,EAEEW,SAFF,EAGExE,CAHF,EAIElD,MAJF,EAKE/G,QALF,EAMEyK,SANF,CAMY;MACVF,SAAS,CAAC/H,UAAU,CAACI,SAAZ,CAAT;KAPF,EAQG8H,SARH,CAQa;MACXH,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;MACAoJ,UAAU,CAAChC,CAAD,CAAV;KAVF;GA7GK;;wCA2HC,GAAR,UAAuC6C,eAAvC,EAAiE9B,QAAjE;QACQsC,YAAY,GAAGtC,QAAQ,CAACuC,eAAT,EAArB;QACMmB,cAAc,GAAG1D,QAAQ,CAAC2D,iBAAT,EAAvB;QAEMC,gBAAgB,GAAGtB,YAAY,CAAC3I,kBAAb,GAAkC,CAAlC,CAAzB;QACMkK,MAAM,GAAGtR,IAAI,CAACgP,GAAL,CAASe,YAAY,CAACwB,iBAAb,KAAmCJ,cAA5C,IACXnR,IAAI,CAACgP,GAAL,CAASqC,gBAAgB,CAACE,iBAAjB,KAAuCJ,cAAhD,CADJ;QAGMZ,WAAW,GAAI,CAAChB,eAAD,IAAoB+B,MAArB,GAChBD,gBADgB,GAEhBtB,YAFJ;WAIOQ,WAAP;GAZM;;+BAeA,GAAR,UAA8BiB,MAA9B;QAUUjC,wCAAA;QAAiB7C,YAAjB;QAAoBe,0BAApB;QAA8B+C,4BAA9B;QAEF5K,OAAO,GAAG6H,QAAQ,CAAC7H,OAAzB;QACM6L,cAAc,GAAGhE,QAAQ,CAACiE,iBAAT,EAAvB;QACMC,UAAU,GAAGlE,QAAQ,CAACQ,YAAT,CAAsB2D,QAAtB,EAAnB;QACMhD,OAAO,GAAGhJ,OAAO,CAACpC,GAAR,GAAc,CAA9B;QACMqO,kBAAkB,GAAGnF,CAAC,CAACoF,OAAF,CAAUpE,KAAV,GAAkBD,QAAQ,CAACsE,yBAAT,EAA7C;QACMtO,QAAQ,GAAGmC,OAAO,CAACnC,QAAzB;QACMqL,SAAS,GAAGrL,QAAQ,CAAC7B,IAAT,KAAkB,YAAlB,GAAiCW,QAAjC,GAA4CkB,QAAQ,CAAC5B,KAAvE;QACI0O,WAAW,GAAGC,SAAlB;QACIwB,gBAAgB,GAAG,CAAvB;QACIC,UAAU,GAAG1B,WAAW,CAAC7H,QAAZ,OAA2BiJ,UAAU,CAAC7R,GAAtC,GACb0Q,SAAS,CAAC0B,aAAV,KAA4B,CADf,GAEb,CAFJ;;WAIOF,gBAAgB,GAAGlD,SAA1B,EAAqC;UAC7BqD,YAAY,GAAG5C,eAAe,GAChCgB,WAAW,CAACzK,WADoB,GAEhCyK,WAAW,CAAC1K,WAFhB;;UAGI,CAACsM,YAAL,EAAmB;;;;UAIbC,UAAU,GAAG7B,WAAW,CAAC7H,QAAZ,EAAnB;UACM2J,YAAY,GAAGF,YAAY,CAACzJ,QAAb,EAArB;;UACK6G,eAAe,IAAI8C,YAAY,IAAID,UAApC,IACE,CAAC7C,eAAD,IAAoB8C,YAAY,IAAID,UAD1C,EAEE;QACAH,UAAU,GAAG1C,eAAe,GACxB0C,UAAU,GAAG,CADW,GAExBA,UAAU,GAAG,CAFjB;;;MAIF1B,WAAW,GAAG4B,YAAd;MACAH,gBAAgB,IAAI,CAApB,CAlBmC;;UAqB7BM,aAAa,GAAG/B,WAAW,CAACgC,gBAAZ,EAAtB;UACMvB,aAAa,GAAGsB,aAAa,CAACjE,WAAd,KAA8B4D,UAAU,GAAGR,cAAjE;UACMe,SAAS,GAAGF,aAAa,CAACjC,OAAd,EAAlB,CAvBmC;;UA2BhCd,eAAe,IAAKyB,aAAa,GAAGwB,SAAhB,GAA4B5D,OAA7B,GAAwCiD,kBAA5D,IACI,CAACtC,eAAD,IAAqByB,aAAa,GAAGpC,OAAjB,GAA4BiD,kBAFtD,EAGE;;;;;QAKEY,gBAAgB,GAAGlC,WAAW,CAACgC,gBAAZ,GAA+BlE,WAA/B,EAAzB;QACM7E,MAAM,GAAGyI,UAAU,GAAGR,cAAb,IAA+BlB,WAAW,CAAClC,WAAZ,KAA4BoE,gBAA3D,CAAf;WAEO;MACL/B,cAAc,EAAEH,WADX;MAELI,UAAU,EAAEnH,MAFP;MAGLoH,SAAS,EAAEoB;KAHb;GA9DM;;2BAqEA,GAAR,UAA0BzC,eAA1B,EAAoD9B,QAApD;QACQ7H,OAAO,GAAG6H,QAAQ,CAAC7H,OAAzB;QACM8M,YAAY,GAAGjF,QAAQ,CAACkF,eAAT,EAArB;QACM5C,YAAY,GAAGtC,QAAQ,CAACQ,YAAT,CAAsB2E,GAAtB,CAA0BF,YAA1B,CAArB;QACMvB,cAAc,GAAG1D,QAAQ,CAAC2D,iBAAT,EAAvB;QAEMC,gBAAgB,GAAGtB,YAAY,CAAC3I,kBAAb,GAAkC,CAAlC,CAAzB;QACMkK,MAAM,GAAG1L,OAAO,CAACzD,QAAR,IACTnC,IAAI,CAACgP,GAAL,CAASe,YAAY,CAACwB,iBAAb,KAAmCJ,cAA5C,IACAnR,IAAI,CAACgP,GAAL,CAASqC,gBAAgB,CAACE,iBAAjB,KAAuCJ,cAAhD,CAFN;;QAKMX,SAAS,GAAGc,MAAM,GACpBD,gBADoB,GAEpBtB,YAFJ;QAIM8C,aAAa,GAAGtD,eAAe,GACjCiB,SAAS,CAAC1K,WADuB,GAEjC0K,SAAS,CAAC3K,WAFd;QAIM0K,WAAW,GAAGsC,aAAa,GAC7BA,aAD6B,GAE7BrC,SAFJ;WAIOD,WAAP;GAxBM;;sBA0BV;EA9P4BlD,MAA5B;;ACHA;;;EAA6BT,SAAA,eAAA,QAAA;;yBAA7B;wEAAA;;IACkBC,UAAA,GAAO5H,UAAU,CAACI,SAAlB;IACAwH,aAAA,GAAU,KAAV;IACAA,aAAA,GAAU,IAAV;;;;;;gBAET,GAAP,UAAcH,CAAd,EAAsB3D,EAAtB;QAAwBgE;QAAcC;IACpCD,YAAY,CAAC9I,MAAM,CAACC,UAAR,EAAoBwI,CAApB,EAAuB,IAAvB,CAAZ,CACGQ,SADH,CACa;MACTF,SAAS,CAAC/H,UAAU,CAACG,QAAZ,CAAT;KAFJ,EAIG+H,SAJH,CAIa;MACTH,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;KALJ;GADK;;kBAUA,GAAP,UAAgBoH,CAAhB,EAAwB3D,EAAxB;QAA0B0F;QAAYzB;;QAChC,CAACN,CAAC,CAACL,KAAF,CAAQqB,KAAb,EAAoB;;;;IAIpBe,UAAU,CAAC/B,CAAD,CAAV,CACGS,SADH,CACa;MACTH,SAAS,CAAC/H,UAAU,CAACK,QAAZ,CAAT;KAFJ;GALK;;kBAWA,GAAP,UAAgBoH,CAAhB,EAAwB3D,EAAxB;QAA0B+D;QAAUW;QAAUV;QAAcC;QACpD8F,SAAS,GAAGpG,CAAC,IAAIA,CAAC,CAACoG,SAAzB;IACA/F,YAAY,CAAC9I,MAAM,CAACK,QAAR,EAAkBoI,CAAlB,EAAqBoG,SAArB,CAAZ;;QAEIhG,QAAQ,CAAClH,OAAT,CAAiB1C,QAArB,EAA+B;MAC7BuK,QAAQ,CAACsF,kBAAT;;;IAGF/F,SAAS,CAAC/H,UAAU,CAACC,IAAZ,CAAT;GARK;;uBAUT;EApC6BmI,MAA7B;;ACAA;;;EAA4BT,SAAA,cAAA,QAAA;;wBAA5B;wEAAA;;IACkBC,UAAA,GAAO5H,UAAU,CAACK,QAAlB;IACAuH,aAAA,GAAU,KAAV;IACAA,aAAA,GAAU,IAAV;;;;;;wBAET,GAAP,UAAsBH,CAAtB,EAA8B3D,EAA9B;QAAgCiE;IAC9BA,SAAS,CAAC/H,UAAU,CAACC,IAAZ,CAAT;GADK;;mBAIA,GAAP,UAAiBwH,CAAjB,EAAyB3D,EAAzB;QAA2BiE;;QAErBN,CAAC,CAACL,KAAF,CAAQqB,KAAR,KAAkB,CAAtB,EAAyB;MACvBV,SAAS,CAAC/H,UAAU,CAACC,IAAZ,CAAT;;GAHG;;sBAMT;EAf4BmI,MAA5B;;ACKA;;;uBAAA;oBAAA;;cACU,GAAe,IAAI2F,SAAJ,EAAf;;kBA2BD,GAAY,UAACC,aAAD;UACXC,YAAY,GAAGrG,KAAI,CAAC9G,KAA1B;;UAEImN,YAAY,CAACtR,IAAb,KAAsBqR,aAA1B,EAAyC;YACnCxG,SAAS,SAAb;;gBAEQwG,aAAR;eACOhO,UAAU,CAACC,IAAhB;YACEuH,SAAS,GAAG,IAAIuG,SAAJ,EAAZ;;;eAEG/N,UAAU,CAACE,OAAhB;YACEsH,SAAS,GAAG,IAAI0G,YAAJ,EAAZ;;;eAEGlO,UAAU,CAACG,QAAhB;YACEqH,SAAS,GAAG,IAAI2G,aAAJ,EAAZ;;;eAEGnO,UAAU,CAACI,SAAhB;YACEoH,SAAS,GAAG,IAAI4G,cAAJ,EAAZ;;;eAEGpO,UAAU,CAACK,QAAhB;YACEmH,SAAS,GAAG,IAAI6G,aAAJ,EAAZ;;;;QAIJJ,YAAY,CAACK,MAAb,CAAoB9G,SAApB;QACAA,SAAU,CAAC+B,OAAX,CAAmB0E,YAAnB;QAEArG,KAAI,CAAC9G,KAAL,GAAa0G,SAAb;;;aAEKI,KAAI,CAAC9G,KAAZ;KA7BK;;;;;cAzBA,GAAP,UAAYmL,SAAZ,EAA+CxE,CAA/C,EAAuDC,OAAvD;QACQuG,YAAY,GAAG,KAAKnN,KAA1B;;YACQmL,SAAR;WACOtM,WAAW,CAACC,IAAjB;QACEqO,YAAY,CAACM,MAAb,CAAoB9G,CAApB,EAAuBC,OAAvB;;;WAEG/H,WAAW,CAACL,MAAjB;QACE2O,YAAY,CAAC9F,QAAb,CAAsBV,CAAtB,EAAyBC,OAAzB;;;WAEG/H,WAAW,CAACE,OAAjB;QACEoO,YAAY,CAACO,SAAb,CAAuB/G,CAAvB,EAA0BC,OAA1B;;;WAEG/H,WAAW,CAACG,aAAjB;QACEmO,YAAY,CAACQ,cAAb,CAA4BhH,CAA5B,EAA+BC,OAA/B;;;WAEG/H,WAAW,CAACI,MAAjB;QACEkO,YAAY,CAACS,QAAb,CAAsBjH,CAAtB,EAAyBC,OAAzB;;;GAhBC;;kBAqBA,GAAP;WACS,KAAK5G,KAAZ;GADK;;qBAmCT;GA3DA;;ACCA;;;mBAkCE,CACE+G,QADF,EAEE8G,eAFF,EAGEzL,aAHF,EAIEvC,OAJF,EAKEmH,YALF;oBAAA;;mBAwIO,GAAa,UAAC8G,SAAD;UACdA,SAAS,IAAIA,SAAS,CAAClG,KAA3B,EAAkC;QAChCkG,SAAS,CAAClG,KAAV,CAAgB;UAAED,KAAK,EAAEb,KAAI,CAAC9G,KAAL,CAAWpC;SAApC,EAAgD,CAAhD;;;MAGFkJ,KAAI,CAACiH,YAAL,CAAkB9G,SAAlB,CAA4B/H,UAAU,CAACC,IAAvC;KALK;;4BAwcA,GAAsB,UAAC2B,KAAD,EAAe2C,MAAf;2BAAe,EAAA;QAAAA,UAAA;;;UACpCiE,QAAQ,GAAGZ,KAAjB;UACMjH,OAAO,GAAG6H,QAAQ,CAAC7H,OAAzB;aAEO;QACLuD,UAAU;iBACDtC,KAAK,CAACsC,UAAN,EAAP;SAFG;QAILT,QAAQ;iBACC7B,KAAK,CAAC6B,QAAN,EAAP;SALG;QAOL2F,WAAW;iBACFxH,KAAK,CAACwH,WAAN,KAAsB7E,MAA7B;SARG;QAUL+H,iBAAiB;iBACR,KAAKlD,WAAL,KAAqBxH,KAAK,CAACyJ,yBAAN,EAA5B;SAXG;QAaLD,OAAO;iBACExJ,KAAK,CAACwJ,OAAN,EAAP;SAdG;QAgBL0D,WAAW;cACLC,QAAQ,GAAWC,GAAvB;cAEMhE,YAAY,GAAGxC,QAAQ,CAACyC,eAAT,EAArB;;cACID,YAAJ,EAAkB;;gBAEViE,UAAU,GAAGzG,QAAQ,CAACQ,YAAT,CAAsBhB,aAAtB,EAAnB;gBACMwE,cAAc,GAAGhE,QAAQ,CAACiE,iBAAT,EAAvB;gBACMyC,aAAa,GAAG,CAACvO,OAAO,CAACzD,QAAR,GAAmBnC,IAAI,CAACoU,KAAL,CAAW,KAAK/F,WAAL,KAAqBoD,cAAhC,IAAkDyC,UAArE,GAAkF,CAAnF,IAAwF,KAAKxL,QAAL,EAA9G;YAEAsL,QAAQ,GAAGG,aAAa,GAAG1G,QAAQ,CAAC4G,kBAAT,EAA3B;;;iBAEKL,QAAP;SA5BG;QA8BLM,iBAAiB;cACXC,cAAc,GAAWN,GAA7B;cAEMhE,YAAY,GAAGxC,QAAQ,CAACyC,eAAT,EAArB;;cACID,YAAJ,EAAkB;gBACVuE,WAAW,GAAG,CAClB,CAAC,KAAKnE,OAAL,EADiB,EAElB5C,QAAQ,CAACsE,yBAAT,KAAuClL,KAAK,CAACyJ,yBAAN,EAFrB,EAGlB7C,QAAQ,CAAC4C,OAAT,EAHkB,CAApB;gBAKMoE,qBAAqB,GAAG,KAAKpG,WAAL,KAAqBZ,QAAQ,CAACG,iBAAT,EAAnD;YAEA2G,cAAc,GAAGR,WAAW,CAACU,qBAAD,EAAwBD,WAAxB,CAA5B;;;iBAGKD,cAAP;SA7CG;QA+CLG,eAAe;cACTC,YAAY,GAAG,CAAnB;cAEMnC,SAAS,GAAG3L,KAAK,CAACwJ,OAAN,EAAlB;cACMoE,qBAAqB,GAAG,KAAKpG,WAAL,KAAqBZ,QAAQ,CAACG,iBAAT,EAAnD;cACMgH,0BAA0B,GAAGH,qBAAqB,GAAGjC,SAA3D;cACMqC,WAAW,GAAG7U,IAAI,CAACF,GAAL,CAAS2N,QAAQ,CAAC4C,OAAT,EAAT,EAA6BuE,0BAA7B,IAA2D5U,IAAI,CAACD,GAAL,CAAS0U,qBAAT,EAAgC,CAAhC,CAA/E;UAEAE,YAAY,GAAGE,WAAW,IAAI,CAAf,GACXA,WAAW,GAAGrC,SADH,GAEX,CAFJ;iBAIOmC,YAAP;SA3DG;QA6DLG,KAAK,EAAL,UAA2BrS,QAA3B;cACQsN,YAAY,GAAGtC,QAAQ,CAACuC,eAAT,EAArB;cACMmB,cAAc,GAAG1D,QAAQ,CAAC2D,iBAAT,EAAvB;cACM2D,cAAc,GAAGlO,KAAK,CAAC0K,iBAAN,EAAvB;;cACIJ,cAAc,KAAK4D,cAAnB,IAAqC,CAAChF,YAA1C,EAAwD;;;;cAIlDiF,eAAe,GAAGjF,YAAY,CAAC1B,WAAb,EAAxB;UACAZ,QAAQ,CAACqC,MAAT,CAAgBjJ,KAAhB,EAAuBmO,eAAe,KAAK,KAAK3G,WAAL,EAApB,GAAyCpK,MAAM,CAACU,IAAhD,GAAuDV,MAAM,CAACM,MAArF,EAA6F,IAA7F,EAAmGiF,MAAnG,EAA2G/G,QAA3G;SAtEG;QAwELwS,MAAM,EAAN,UAA4BC,cAA5B;UACErO,KAAK,CAACO,kBAAN,GACGzK,OADH,CACW,UAAAwY,SAAA;mBAAaD,cAAc,CAACC,SAAS,CAAChM,UAAV,EAAD,CAAd;WADxB;SAzEG;QA4ELiM,IAAI,EAAJ;cACQvP,WAAW,GAAGgB,KAAK,CAAChB,WAA1B;;cAEI,CAACA,WAAL,EAAkB;mBACT,IAAP;;;cAGI6M,YAAY,GAAG,KAAKhK,QAAL,EAArB;cACM2M,SAAS,GAAGxP,WAAW,CAAC6C,QAAZ,EAAlB;cAEM4M,oBAAoB,GAAG5C,YAAY,GAAG2C,SAAf,GAA2B,CAAxD;cACME,cAAc,GAAG3P,OAAO,CAACxD,QAAR,IAClBsQ,YAAY,GAAG,CADG,IAElB2C,SAAS,GAAG3C,YAFjB;;cAII4C,oBAAoB,IAAIC,cAA5B,EAA4C;;mBAEnC,IAAP;;;cAGIC,aAAa,GAAG3P,WAAW,CAACwK,OAAZ,EAAtB;cACMoF,WAAW,GAAG,KAAKpH,WAAL,KAAqBmH,aAArB,GAAqC5P,OAAO,CAACpC,GAAjE;cACMkS,SAAS,GAAGD,WAAW,GAAG5P,WAAW,CAACwI,WAAZ,EAAhC;iBAEOZ,QAAQ,CAACa,mBAAT,CAA6BzI,WAA7B,EAA0C6P,SAA1C,CAAP;SApGG;QAsGLC,IAAI,EAAJ;cACQ7P,WAAW,GAAGe,KAAK,CAACf,WAA1B;cACMxD,SAAS,GAAGmL,QAAQ,CAACQ,YAAT,CAAsB2H,YAAtB,EAAlB;;cAEI,CAAC9P,WAAL,EAAkB;mBACT,IAAP;;;cAGI4M,YAAY,GAAG,KAAKhK,QAAL,EAArB;cACMmN,SAAS,GAAG/P,WAAW,CAAC4C,QAAZ,EAAlB;cAEM4M,oBAAoB,GAAGO,SAAS,GAAGnD,YAAZ,GAA2B,CAAxD;cACMoD,cAAc,GAAGlQ,OAAO,CAACxD,QAAR,IAClBsQ,YAAY,GAAGpQ,SADG,IAElBuT,SAAS,GAAGnD,YAFjB;;cAII4C,oBAAoB,IAAIQ,cAA5B,EAA4C;mBACnC,IAAP;;;cAGIL,WAAW,GAAG,KAAKpH,WAAL,KAAqBxH,KAAK,CAACwJ,OAAN,EAArB,GAAuCzK,OAAO,CAACpC,GAAnE;cACMkS,SAAS,GAAGD,WAAW,GAAG3P,WAAW,CAACuI,WAAZ,EAAhC;iBAEOZ,QAAQ,CAACa,mBAAT,CAA6BxI,WAA7B,EAA0C4P,SAA1C,CAAP;SA7HG;QA+HL/W,YAAY,EAAZ,UAAkC1B,OAAlC;cACQ8Y,cAAc,GAAGC,YAAY,CAAC/Y,OAAD,CAAnC;cACMuL,UAAU,GAAGiF,QAAQ,CAACQ,YAAT,CAAsBzF,UAAtB,EAAnB;cACM3C,WAAW,GAAGgB,KAAK,CAAChB,WAA1B;;;;cAIMoQ,WAAW,GAAGpQ,WAAW,IAAI2C,UAAU,CAACE,QAAX,OAA0B,KAAKA,QAAL,EAAzC,GAChB1I,IAAI,CAACD,GAAL,CAAS8F,WAAW,CAAC6C,QAAZ,KAAyB,CAAlC,EAAqC7B,KAAK,CAAC6B,QAAN,KAAmBqN,cAAc,CAAC1W,MAAvE,CADgB,GAEhBW,IAAI,CAACD,GAAL,CAAS8G,KAAK,CAAC6B,QAAN,KAAmBqN,cAAc,CAAC1W,MAA3C,EAAmD,CAAnD,CAFJ;iBAIOoO,QAAQ,CAACyI,MAAT,CAAgBD,WAAhB,EAA6BF,cAA7B,CAAP;SA1IG;QA4ILI,WAAW,EAAX,UAAiClZ,OAAjC;iBACSwQ,QAAQ,CAACyI,MAAT,CAAgBrP,KAAK,CAAC6B,QAAN,KAAmB,CAAnC,EAAsCzL,OAAtC,CAAP;SA7IG;QA+ILiL,MAAM,EAAN;iBACSuF,QAAQ,CAACvF,MAAT,CAAgBrB,KAAK,CAAC6B,QAAN,EAAhB,EAAkC,CAAlC,CAAP;;OAhJJ;KAJK;;SAzkBAoE,QAAL,GAAgBA,QAAhB;SACK8G,eAAL,GAAuBA,eAAvB;SACKzL,aAAL,GAAqBA,aAArB;SACK4E,YAAL,GAAoBA,YAApB;SAEKhH,KAAL,GAAa;MACXE,IAAI,EAAE,CADK;MAEXtC,QAAQ,EAAE,CAFC;MAGXyS,sBAAsB,EAAE,CAHb;MAIXC,UAAU,EAAE;QACVjB,IAAI,EAAE,CADI;QAEVO,IAAI,EAAE;OANG;MAQXW,SAAS,EAAE5Q,SARA;MASXrD,iBAAiB,EAAE,CATR;MAUXkU,cAAc,EAAE;KAVlB;SAYK3Q,OAAL,GAAeA,OAAf;SACKkO,YAAL,GAAoB,IAAI0C,YAAJ,EAApB;SACKvI,YAAL,GAAoB,IAAIwI,YAAJ,CAAiBtO,aAAjB,EAAgCvC,OAAhC,CAApB;SAEK8Q,KAAL;;;;;gBAGK,GAAP,UACE7P,KADF,EAEEqK,SAFF,EAGE2C,SAHF,EAIErK,MAJF,EAKE/G,QALF;oBAAA;;yBAIE,EAAA;MAAA+G,UAAA;;;2BACA,EAAA;MAAA/G,WAAmB,KAAKmD,OAAL,CAAanD,QAAhC;;;QAEMsD,KAAK,GAAG,KAAKA,KAAnB;QACMmN,YAAY,GAAG,KAAKY,YAAL,CAAkB6C,QAAlB,EAArB;QACM7U,UAAU,GAAI,KAAK8D,OAAL,CAAanC,QAAb,CAA+C7B,IAA/C,KAAwD,YAA5E;QAEMmO,YAAY,GAAG,KAAKA,YAA1B;QACMiF,eAAe,GAAGjP,KAAK,CAACpC,QAA9B;QACMiT,WAAW,GAAG,KAAKtI,mBAAL,CAAyBzH,KAAzB,EAAgC2C,MAAhC,CAApB;QAEIqN,iBAAiB,GAAGD,WAAW,CAACrF,iBAAZ,KAAkCxL,KAAK,CAACqQ,sBAAhE;IACAS,iBAAiB,GAAG,KAAKC,eAAL,KAChBnW,KAAK,CAACkW,iBAAD,EAAoB9Q,KAAK,CAACsQ,UAAN,CAAiBjB,IAArC,EAA2CrP,KAAK,CAACsQ,UAAN,CAAiBV,IAA5D,CADW,GAEhBkB,iBAFJ;QAIM/D,SAAS,GAAGe,SAAS,GACvBA,SAAS,CAACf,SADa,GAEvB,KAFJ;QAGMxG,SAAS,GAAGuK,iBAAiB,GAAG7B,eAApB,GACdzP,SAAS,CAACE,IADI,GAEdF,SAAS,CAACC,IAFd;QAIIuR,WAAJ;;QACI7F,SAAS,KAAKjN,MAAM,CAACM,MAAzB,EAAiC;MAC/BwS,WAAW,GAAG,KAAKhK,YAAL,CAAkB9I,MAAM,CAACM,MAAzB,EAAiCsP,SAAjC,EAA4Cf,SAA5C,EAAuD;QACnEnN,KAAK,EAAEkB,KAAK,CAAC6B,QAAN,EAD4D;QAEnE7B,KAAK,EAAE+P,WAF4D;QAGnEtK,SAAS,WAH0D;QAInE+I,SAAS,EAAEtF,YAAY,GAAGA,YAAY,CAACrH,QAAb,EAAH,GAA6B,CAAC,CAJc;QAKnEkC,SAAS,EAAEmF,YAAY,GAAG,KAAKzB,mBAAL,CAAyByB,YAAzB,CAAH,GAA4C;OALvD,CAAd;KADF,MAQO,IAAImB,SAAS,KAAKjN,MAAM,CAACO,OAAzB,EAAkC;MACvCuS,WAAW,GAAG,KAAKhK,YAAL,CAAkB9I,MAAM,CAACO,OAAzB,EAAkCqP,SAAlC,EAA6Cf,SAA7C,CAAd;KADK,MAEA;MACLiE,WAAW,GAAG;QACZ7J,SAAS,EAAT,UAAU3L,QAAV;UACEA,QAAQ;iBACD,IAAP;SAHU;QAKZ4L,SAAS,EAAT;iBACS,IAAP;;OANJ;;;IAWF4J,WAAW,CAAC7J,SAAZ,CAAsB;MACpBL,KAAI,CAACkD,YAAL,GAAoBlJ,KAApB;MACAqM,YAAY,CAAC3G,WAAb,GAA2B1F,KAA3B;MACAqM,YAAY,CAAC1G,YAAb,GAA4BhD,MAA5B;MACA0J,YAAY,CAAC5G,SAAb,GAAyBuK,iBAAiB,GAAG7B,eAApB,GACrBzP,SAAS,CAACE,IADW,GAErBF,SAAS,CAACC,IAFd;;UAIIqO,SAAS,IAAIA,SAAS,CAAClG,KAA3B,EAAkC;QAChCkG,SAAS,CAAClG,KAAV,CAAgB;UAAED,KAAK,EAAE5L,UAAU,GAAG+R,SAAS,CAAC/B,OAAV,CAAkBpE,KAArB,GAA6BmJ;SAAhE,EAAqFpU,QAArF;OADF,MAEO;YACDoU,iBAAiB,KAAK7B,eAA1B,EAA2C;;UAEzCnI,KAAI,CAACoD,YAAL,GAAoBpD,KAAI,CAACmK,gBAAL,EAApB;SAFF,MAGO;UACLnK,KAAI,CAACoK,IAAL,CAAUtJ,KAAV,CAAgB;YAAED,KAAK,EAAEmJ;WAAzB,EAA8CpU,QAA9C;;;KAfN;WAoBOsU,WAAP;GAtEK;;oBAyEA,GAAP,UAAkB3V,GAAlB,EAA+ByS,SAA/B;QACQ9N,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QACMxH,SAAS,GAAG2H,KAAK,CAACuQ,SAAN,CAAgBnX,IAAlC;;IAGA4G,KAAK,CAACpC,QAAN,GAAiBvC,GAAjB;SACK6O,YAAL,GAAoB,KAAK+G,gBAAL,EAApB;QAEM/G,YAAY,GAAG,KAAKA,YAA1B;QACMiH,uBAAuB,GAAGjH,YAAY,GACxCA,YAAY,CAAC5B,WAAb,EADwC,GAExC,CAFJ;SAIK8I,cAAL,CAAoBtD,SAApB;;QAGMuD,uBAAuB,GAAGnH,YAAY,GACxCA,YAAY,CAAC5B,WAAb,EADwC,GAExC,CAFJ;IAGAjN,GAAG,IAAKgW,uBAAuB,GAAGF,uBAAlC;IACAnR,KAAK,CAACpC,QAAN,GAAiBvC,GAAjB;QAEMiW,UAAU,GAAGzR,OAAO,CAAC1D,UAAR,GACf,CAAC,CAACd,GAAF,EAAO,CAAP,CADe,GACH,CAAC,CAAD,EAAI,CAACA,GAAL,CADhB;QAEMkW,SAAS,GAAGD,UAAU,CAACxL,GAAX,CAAe,UAAA0L,KAAA;aAAYvX,IAAI,CAACwX,KAAL,CAAWD,KAAX,QAAH;KAAxB,EAAkDE,IAAlD,CAAuD,IAAvD,CAAlB;SAEKtP,aAAL,CAAmB5J,KAAnB,CAAyBH,SAAzB,IAAsC2H,KAAK,CAACuQ,SAAN,CAAgBlX,KAAhB,GAClC,iBAAekY,SAAf,WADkC,GAElC,eAAaA,SAAb,MAFJ;GA3BK;;gBAwCA,GAAP;QACQrJ,YAAY,GAAG,KAAKA,YAA1B;SAEKyJ,UAAL;SACKC,4BAAL;SACK5E,kBAAL;SACK6E,gBAAL;;QAGI,KAAKhS,OAAL,CAAazD,QAAb,IAAyB8L,YAAY,CAAChB,aAAb,KAA+B,CAA5D,EAA+D;WACxD4K,WAAL;WACKC,0BAAL;;;IAGF7J,YAAY,CAAC8J,cAAb;SACKC,oBAAL;GAfK;;;0BAkBA,GAAP;QACQjS,KAAK,GAAG,KAAKA,KAAnB;QACMkI,YAAY,GAAG,KAAKA,YAA1B;QACMlF,qBAAA;QAAEkP,mBAAF;QAAmBC,mBAAnB;QACA/G,cAAc,GAAG,KAAKC,iBAAL,EAAvB;QACMgF,sBAAsB,GAAG,KAAKrE,yBAAL,EAA/B;;QAEI,KAAKlB,YAAL,EAAJ,EAAyB;UACjBlN,QAAQ,GAAGoC,KAAK,CAACpC,QAAvB;UACMoM,YAAY,GAAG,KAAKC,eAAL,EAArB;;UAEIrM,QAAQ,GAAGsU,SAAf,EAA0B;eACjBhK,YAAY,CAACzF,UAAb,EAAP;OADF,MAEO,IAAI7E,QAAQ,GAAGuU,SAAf,EAA0B;eACxBjK,YAAY,CAACxF,SAAb,EAAP;OADK,MAEA,IAAIsH,YAAJ,EAAkB;YACjBoI,qBAAqB,GAAGpI,YAAY,CAACwB,iBAAb,EAA9B;;YAEG5N,QAAQ,KAAKsU,SAAb,IAA0BE,qBAAqB,IAAIF,SAAS,GAAG7B,sBAAhE,IACCzS,QAAQ,KAAKuU,SAAb,IAA0BC,qBAAqB,IAAID,SAAS,GAAG9B,sBAFlE,EAGG;iBACMrG,YAAP;;;;;WAKC,KAAKqI,kBAAL,CAAwBjH,cAAxB,CAAP;GA1BK;;4BA6BA,GAAP,UAA0BxN,QAA1B;QACQsK,YAAY,GAAG,KAAKA,YAA1B;QAEMvD,SAAS,GAAGuD,YAAY,CAACvD,SAAb,EAAlB;QACI2N,eAAe,GAAG9V,QAAtB;QACI0N,YAAJ;;SAEoB,UAAA,EAAAjF,uBAApB,EAAoBvO,uBAApB,EAAoBA,IAApB;UAAWoK,KAAK,kBAAX;;UACC,CAACA,KAAL,EAAY;;;;UAGNyR,YAAY,GAAGzR,KAAK,CAACwH,WAAN,EAArB;UACMkK,YAAY,GAAGD,YAAY,GAAGzR,KAAK,CAACwJ,OAAN,EAApC;;UAGMmI,QAAQ,GAAGC,SAAS,CAAC9U,QAAD,EAAW2U,YAAX,EAAyBC,YAAzB,CAAT,GACb,CADa,GAEbvY,IAAI,CAACF,GAAL,CACAE,IAAI,CAACgP,GAAL,CAASsJ,YAAY,GAAG3U,QAAxB,CADA,EAEA3D,IAAI,CAACgP,GAAL,CAASuJ,YAAY,GAAG5U,QAAxB,CAFA,CAFJ;;UAOI6U,QAAQ,IAAIH,eAAhB,EAAiC;;;;MAGjCA,eAAe,GAAGG,QAAlB;MACAvI,YAAY,GAAGpJ,KAAf;;;WAGKoJ,YAAP;GA7BK;;mCAgCA,GAAP,UAAiCpJ,KAAjC;QACM6R,OAAO,GAAG7R,KAAd;QACI8R,gBAAgB,GAAGpW,QAAvB;QACM4O,cAAc,GAAG,KAAKC,iBAAL,EAAvB;QAEMwH,UAAU,GAAG/R,KAAK,CAACO,kBAAN,EAAnB;IACAwR,UAAU,CAACjc,OAAX,CAAmB,UAAAkc,SAAA;UACX9D,cAAc,GAAG8D,SAAS,CAACtH,iBAAV,EAAvB;UACMiH,QAAQ,GAAGxY,IAAI,CAACgP,GAAL,CAAS+F,cAAc,GAAG5D,cAA1B,CAAjB;;UAEIqH,QAAQ,GAAGG,gBAAf,EAAiC;QAC/BD,OAAO,GAAGG,SAAV;QACAF,gBAAgB,GAAGH,QAAnB;;KANJ;WAUOE,OAAP;GAhBK;;;qCAoBA,GAAP,UAAmC7R,KAAnC;QACQd,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QACMmP,cAAc,GAAGlO,KAAK,CAAC0K,iBAAN,EAAvB;QACMJ,cAAc,GAAG,KAAKC,iBAAL,EAAvB;QACMoH,QAAQ,GAAGxY,IAAI,CAACgP,GAAL,CAASmC,cAAc,GAAG4D,cAA1B,CAAjB;QACMtD,cAAc,GAAG1L,KAAK,CAACsQ,UAAN,CAAiBV,IAAjB,GAAwB5P,KAAK,CAACsQ,UAAN,CAAiBjB,IAAhE;;QAEI,CAACxP,OAAO,CAACzD,QAAb,EAAuB;UACfwB,QAAQ,GAAGoR,cAAc,GAAGhP,KAAK,CAACqQ,sBAAxC;aACO,KAAKU,eAAL,KACHnW,KAAK,CAACgD,QAAD,EAAWoC,KAAK,CAACsQ,UAAN,CAAiBjB,IAA5B,EAAkCrP,KAAK,CAACsQ,UAAN,CAAiBV,IAAnD,CADF,GAEHhS,QAFJ;KAFF,MAKO;;aAEE6U,QAAQ,IAAI/G,cAAc,GAAG+G,QAA7B,GACHzD,cAAc,GAAGhP,KAAK,CAACqQ,sBADpB,GAEHrB,cAAc,GAAG5D,cAAjB;QAEE4D,cAAc,GAAGhP,KAAK,CAACqQ,sBAAvB,GAAgD3E,cAFlD;QAIEsD,cAAc,GAAGhP,KAAK,CAACqQ,sBAAvB,GAAgD3E,cANtD;;GAfG;;gBAyBA,GAAP;SACOqH,QAAL,CAAcC,MAAd;GADK;;iBAIA,GAAP;SACOD,QAAL,CAAcE,OAAd;GADK;;gBAIA,GAAP,UAAcrT,KAAd,EAA6B1I,OAA7B;oBAAA;;QACQqF,SAAS,GAAG,KAAK2L,YAAL,CAAkB2H,YAAlB,EAAlB;;QAGIjQ,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAGrD,SAAzB,EAAoC;aAC3B,EAAP;;;QAGIyD,KAAK,GAAG,KAAKA,KAAnB;QACMgQ,cAAc,GAAGC,YAAY,CAAC/Y,OAAD,CAAnC;QAEMmL,MAAM,GAAG2N,cAAc,CAC1BlK,GADY,CACR,UAACxO,EAAD,EAAKuD,GAAL;aAAa,IAAI+G,KAAJ,CAAUtK,EAAV,EAAcsI,KAAK,GAAG/E,GAAtB,EAA2BiM,KAAI,CAACjH,OAAhC,CAAA;KADL,EAEZ1F,KAFY,CAEN,CAFM,EAEHoC,SAAS,GAAGqD,KAAZ,GAAoB,CAFjB,CAAf;;QAIIyC,MAAM,CAAC/I,MAAP,IAAiB,CAArB,EAAwB;aACf,EAAP;;;QAGIkK,WAAW,GAAG,KAAK0E,YAAL,CAAkBiI,MAAlB,CAAyBvQ,KAAzB,EAAgCyC,MAAhC,CAApB;;QAEI,CAAC,KAAK2H,YAAV,EAAwB;WACjBA,YAAL,GAAoB3H,MAAM,CAAC,CAAD,CAA1B;;;;IAIFrC,KAAK,CAACwQ,cAAN,CAAqB5Z,OAArB,CAA6B,UAACsc,OAAD,EAAUrY,GAAV;UACpBd,gBAAA;UAAKC,gBAAL;;UAEH0Y,SAAS,CAAC9S,KAAD,EAAQ7F,GAAR,EAAaC,GAAb,CAAb,EAAgC;;QAE9BgG,KAAK,CAACwQ,cAAN,CAAqBtO,MAArB,CAA4BrH,GAA5B,EAAiC,CAAjC;OAFF,MAGO,IAAI+E,KAAK,GAAG7F,GAAZ,EAAiB;;QAEtBiG,KAAK,CAACwQ,cAAN,CAAqBtO,MAArB,CAA4BrH,GAA5B,EAAiC,CAAjC,EAAoC,CAACd,GAAG,GAAGyJ,WAAP,EAAoBxJ,GAAG,GAAGwJ,WAA1B,CAApC;;KARJ;SAYKzC,MAAL;WAEOsB,MAAM,CAACyD,GAAP,CAAW,UAAAhF,KAAA;aAASgG,KAAI,CAACyB,mBAAL,CAAyBzH,KAAzB,CAAA;KAApB,CAAP;GAxCK;;iBA2CA,GAAP,UAAelB,KAAf,EAA8B1I,OAA9B;oBAAA;;QACQgR,YAAY,GAAG,KAAKA,YAA1B;QACM3L,SAAS,GAAG2L,YAAY,CAAC2H,YAAb,EAAlB;;QAGIjQ,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAGrD,SAAzB,EAAoC;aAC3B,EAAP;;;QAGIyD,KAAK,GAAG,KAAKA,KAAnB;QACMgQ,cAAc,GAAGC,YAAY,CAAC/Y,OAAD,CAAnC;QACMmL,MAAM,GAAG2N,cAAc,CAC1BlK,GADY,CACR,UAACxO,EAAD,EAAKuD,GAAL;aAAa,IAAI+G,KAAJ,CAAUtK,EAAV,EAAcsI,KAAK,GAAG/E,GAAtB,EAA2BiM,KAAI,CAACjH,OAAhC,CAAA;KADL,EAEZ1F,KAFY,CAEN,CAFM,EAEHoC,SAAS,GAAGqD,KAAZ,GAAoB,CAFjB,CAAf;;QAIIyC,MAAM,CAAC/I,MAAP,IAAiB,CAArB,EAAwB;aACf,EAAP;;;IAGF4O,YAAY,CAACvO,OAAb,CAAqBiG,KAArB,EAA4ByC,MAA5B;;QAEI,CAAC,KAAK2H,YAAV,EAAwB;WACjBA,YAAL,GAAoB3H,MAAM,CAAC,CAAD,CAA1B;;;;IAIFrC,KAAK,CAACwQ,cAAN,CAAqB5Z,OAArB,CAA6B,UAACsc,OAAD,EAAUrY,GAAV;UACpBd,gBAAA;UAAKC,gBAAL;;UAEH4F,KAAK,IAAI5F,GAAT,IAAgB4F,KAAK,GAAGyC,MAAM,CAAC/I,MAAf,GAAwBS,GAA5C,EAAiD;;QAE/CiG,KAAK,CAACwQ,cAAN,CAAqBtO,MAArB,CAA4BrH,GAA5B,EAAiC,CAAjC;;KALJ;SASKkG,MAAL;WAEOsB,MAAM,CAACyD,GAAP,CAAW,UAAAhF,KAAA;aAASgG,KAAI,CAACyB,mBAAL,CAAyBzH,KAAzB,CAAA;KAApB,CAAP;GArCK;;gBAwCA,GAAP,UAAclB,KAAd,EAA6BwE,WAA7B;oBAAA;;8BAA6B,EAAA;MAAAA,eAAA;;;;IAE3BxE,KAAK,GAAG3F,IAAI,CAACD,GAAL,CAAS4F,KAAT,EAAgB,CAAhB,CAAR;QAEMsI,YAAY,GAAG,KAAKA,YAA1B;QACMyE,YAAY,GAAG,KAAKC,eAAL,EAArB;QAEM/I,aAAa,GAAGqE,YAAY,CAAC/F,MAAb,CAAoBvC,KAApB,EAA2BwE,WAA3B,CAAtB;;QACIsO,SAAS,CAAC/F,YAAD,EAAe/M,KAAf,EAAsBA,KAAK,GAAGwE,WAAR,GAAsB,CAA5C,CAAb,EAA6D;;;UAGrD+O,eAAe,GAAGlZ,IAAI,CAACD,GAAL,CAAS4F,KAAK,GAAG,CAAjB,EAAoBsI,YAAY,CAAC2D,QAAb,GAAwB9R,GAA5C,CAAxB;WACKiQ,YAAL,GAAoB9B,YAAY,CAAC2E,GAAb,CAAiBsG,eAAjB,CAApB;;;SAEGpS,MAAL;WAEO8C,aAAa,CAACiC,GAAd,CAAkB,UAAAhF,KAAA;aAASgG,KAAI,CAACyB,mBAAL,CAAyBzH,KAAzB,CAAA;KAA3B,CAAP;GAhBK;;4BAmBA,GAAP;QACQjB,OAAO,GAAG,KAAKA,OAArB;QACM1D,UAAU,GAAG0D,OAAO,CAAC1D,UAA3B;QACM6N,YAAY,GAAG,KAAKC,eAAL,EAArB;;QAEI,CAACD,YAAL,EAAmB;;;;QAIfoJ,WAAJ;;QACIvT,OAAO,CAAC1C,QAAZ,EAAsB;UACdkW,SAAS,GAAGrJ,YAAY,CAACpJ,OAAb,EAAlB;MAEAwS,WAAW,GAAGjX,UAAU,GAAGkX,SAAS,CAACvV,MAAb,GAAsBuV,SAAS,CAACxV,KAAxD;KAHF,MAIO;;UAECyV,gBAAgB,GAAG,KAAKpL,YAAL,CAAkB9C,cAAlB,GAAmC7C,MAAnC,CAA0C,UAACgR,OAAD,EAAUzS,KAAV;YAC3DuS,SAAS,GAAGvS,KAAK,CAACF,OAAN,EAAlB;eACO3G,IAAI,CAACD,GAAL,CAASuZ,OAAT,EAAkBpX,UAAU,GAAGkX,SAAS,CAACvV,MAAb,GAAsBuV,SAAS,CAACxV,KAA5D,CAAP;OAFuB,EAGtB,CAHsB,CAAzB;MAKAuV,WAAW,GAAGE,gBAAd;;;QAGIE,aAAa,GAAG,KAAK3F,eAAL,CAAqBrV,KAA3C;;QACI2D,UAAJ,EAAgB;MACdqX,aAAa,CAAC1V,MAAd,GAA0BsV,WAAW,OAArC;MACAI,aAAa,CAACC,SAAd,GAA0B,MAA1B;MACAD,aAAa,CAAC3V,KAAd,GAAsB,MAAtB;KAHF,MAIO;MACL2V,aAAa,CAAC3V,KAAd,GAAyBuV,WAAW,OAApC;MACAI,aAAa,CAACE,QAAd,GAAyB,MAAzB;MACAF,aAAa,CAAC1V,MAAd,GAAuB,MAAvB;;GAhCG;;iBAoCA,GAAP;QACQ+P,eAAe,GAAG,KAAKA,eAA7B;QACM8F,OAAO,GAAG9F,eAAe,CAAC5U,aAAhC;IAEA0a,OAAQ,CAACza,WAAT,CAAqB2U,eAArB;SAEKqD,IAAL,CAAU0C,OAAV;SACKb,QAAL,CAAca,OAAd;SAEK1L,YAAL,CAAkB9C,cAAlB,GAAmCxO,OAAnC,CAA2C,UAAAkK,KAAA;MACzC6S,OAAQ,CAACpQ,WAAT,CAAqBzC,KAAK,CAACsC,UAAN,EAArB;MACAtC,KAAK,CAAC8S,OAAN;KAFF;;SAMK,IAAMhX,CAAX,IAAgB,IAAhB,EAAsB;WACNA,CAAb,IAAkB,IAAlB;;GAhBE;;iBAoBA,GAAP,UAAeiX,MAAf;QACQxR,MAAM,GAAGwR,MAAM,CAACxR,MAAtB;QACMD,aAAa,GAAG,KAAKA,aAA3B;QACM8F,YAAY,GAAG,KAAKA,YAA1B;;IAGAA,YAAY,CAAC4L,KAAb;IACA1R,aAAa,CAACzK,SAAd,GAA0Bkc,MAAM,CAACxR,MAAP,CAAcyD,GAAd,CAAkB,UAAAhF,KAAA;aAASA,KAAK,CAACiT,IAAN;KAA3B,EAAuCrC,IAAvC,CAA4C,EAA5C,CAA1B;SAEKsC,YAAL;SACKhK,YAAL,GAAoB9B,YAAY,CAAC2E,GAAb,CAAiBgH,MAAM,CAACjU,KAAxB,CAApB;;IAGAsI,YAAY,CAAC9C,cAAb,GAA8BxO,OAA9B,CAAsC,UAACkK,KAAD,EAAQjG,GAAR;MACpCiG,KAAK,CAACiD,QAAN,CAAe1B,MAAM,CAACxH,GAAD,CAAN,CAAY+E,KAA3B;KADF;SAIKmB,MAAL;SAEKmQ,IAAL,CAAUtJ,KAAV,CAAgB;MAAED,KAAK,EAAEkM,MAAM,CAACjW;KAAhC,EAA4C,CAA5C;SACK8K,UAAL,CAAgBmL,MAAM,CAACjW,QAAvB;GApBK;;yBAuBA,GAAP;WACS,KAAKoM,YAAZ;GADK;;yBAIA,GAAP;QACQA,YAAY,GAAG,KAAKA,YAA1B;WAEOA,YAAY,GACfA,YAAY,CAACrH,QAAb,EADe,GAEf,CAAC,CAFL;GAHK;;yBAQA,GAAP;WACS,KAAKuH,YAAZ;GADK;;;4BAKA,GAAP;QACMA,YAAY,GAAG,KAAKA,YAAxB;QACMhC,YAAY,GAAG,KAAKA,YAA1B;;QACI,CAACgC,YAAL,EAAmB;;aAEVgE,GAAP;;;QAEIlL,yBAAA;QAACkP,mBAAD;QAAkBC,mBAAlB;;QACA/J,cAAc,GAAG,KAAKP,iBAAL,EAAvB;QACMiD,YAAY,GAAG,KAAKA,YAAL,EAArB;QACIjG,SAAS,GAAGqF,YAAY,CAACpK,WAA7B;QACIgF,SAAS,GAAGoF,YAAY,CAACnK,WAA7B;QACIqL,cAAc,GAAG,KAAKC,iBAAL,EAArB;QACI4I,gBAAgB,GAAG/J,YAAY,CAACsB,iBAAb,EAAvB;;QAGEV,YAAY,IACTjG,SADH,IAEGC,SAFH,IAGGsD,cAAc,GAAG+J,SAHpB;OAKI/G,cAAc,GAAGvG,SAAS,CAAC2G,iBAAV,EAAjB,GAAiDyI,gBAAgB,GAAG7I,cAN1E,EAOE;MACAlB,YAAY,GAAGrF,SAAf;MACAC,SAAS,GAAGoF,YAAY,CAACnK,WAAzB;MACA8E,SAAS,GAAGqF,YAAY,CAACpK,WAAzB;MACAmU,gBAAgB,GAAG/J,YAAY,CAACsB,iBAAb,EAAnB;;;QAEI0I,YAAY,GAAGhK,YAAY,CAACvH,QAAb,KAA0B,CAACuH,YAAY,CAACiC,aAAb,KAA+B,CAAhC,IAAqCjE,YAAY,CAAChB,aAAb,EAApF;QACMiN,WAAW,GAAGjK,YAAY,CAACI,OAAb,EAApB;;QAEIQ,YAAJ,EAAkB;UACVuF,sBAAsB,GAAG,KAAKrE,yBAAL,EAA/B;;UAEIiI,gBAAgB,GAAG9B,SAAS,GAAG9B,sBAAnC,EAA2D;;QAEzDjF,cAAc,GAAG6I,gBAAgB,GAAG7I,cAAnB,GAAoCiF,sBAApC,GAA6D8B,SAA9E;OAFF,MAGO,IAAI8B,gBAAgB,GAAG/B,SAAS,GAAG7B,sBAAnC,EAA2D;;QAEhEjF,cAAc,GAAG6I,gBAAgB,GAAG7I,cAAnB,GAAoCiF,sBAApC,GAA6D6B,SAA9E;;;;QAGEkC,0BAA0B,GAAGhJ,cAAc,IAAI6I,gBAArD;QACMxW,GAAG,GAAG,KAAKoC,OAAL,CAAapC,GAAzB;QAEI4W,YAAY,GAAGJ,gBAAnB;QACIK,cAAc,GAAGL,gBAArB;;QACIG,0BAAJ,EAAgC;MAC9BE,cAAc,GAAGxP,SAAS,GACtBA,SAAS,CAAC0G,iBAAV,EADsB,GAEtByI,gBAAgB,GAAGE,WAAnB,GAAiC1W,GAFrC;KADF,MAIO;MACL4W,YAAY,GAAGxP,SAAS,GACpBA,SAAS,CAAC2G,iBAAV,EADoB,GAEpB6I,YAAY,GAAGJ,gBAAgB,GAAGE,WAAnB,GAAiC1W,GAFpD;;;QAKI8W,eAAe,GAAG,CAACnJ,cAAc,GAAGiJ,YAAlB,KAAmCC,cAAc,GAAGD,YAApD,CAAxB;QACMG,UAAU,GAAGJ,0BAA0B,GACzCF,YADyC,GAEzCrP,SAAS,GACPA,SAAS,CAAClC,QAAV,EADO,GAEPuR,YAAY,GAAG,CAJrB;WAMOM,UAAU,GAAGD,eAApB;GAhEK;;iBAmEA,GAAP;WACS,KAAKvU,KAAL,CAAWE,IAAlB;GADK;;uBAIA,GAAP;WACS,KAAKF,KAAL,CAAWsQ,UAAlB;GADK;;sBAGA,GAAP;QACQtQ,KAAK,GAAG,KAAKA,KAAnB;QACMsQ,UAAU,GAAGtQ,KAAK,CAACsQ,UAAzB;WAEO,CAAC,KAAKzQ,OAAL,CAAazD,QAAd,KACD4D,KAAK,CAACpC,QAAN,IAAkB0S,UAAU,CAACjB,IAA7B,IAAqCrP,KAAK,CAACpC,QAAN,IAAkB0S,UAAU,CAACV,IADjE,CAAP;GAJK;;2BAOA,GAAP;QACQU,UAAU,GAAG,KAAKtQ,KAAL,CAAWsQ,UAA9B;WAEOA,UAAU,CAACV,IAAX,GAAkBU,UAAU,CAACjB,IAApC;GAHK;;mCAMA,GAAP;WACS,KAAKrP,KAAL,CAAWqQ,sBAAlB;GADK;;2BAIA,GAAP;WACS,KAAKrQ,KAAL,CAAWpC,QAAX,GAAsB,KAAKoC,KAAL,CAAWqQ,sBAAxC;GADK;;2BAIA,GAAP;WACS,KAAKrQ,KAAL,CAAWpC,QAAlB;GADK;;sBAIA,GAAP,UAAoBgC,KAApB;QACQoK,YAAY,GAAG,KAAKA,YAA1B;QACM9B,YAAY,GAAG,KAAKA,YAA1B;IAEAA,YAAY,CAACuM,YAAb,CAA0B7U,KAA1B;;QACIoK,YAAY,IAAIA,YAAY,CAACrH,QAAb,KAA0B/C,KAA9C,EAAqD;WAC9CoK,YAAL,GAAoB9B,YAAY,CAACxF,SAAb,EAApB;;;SAGG3B,MAAL;GATK;;4BAYA,GAAP,UAA0B2T,QAA1B;QACQxD,IAAI,GAAG,KAAKA,IAAlB;SAEKyD,YAAL,GAAoBD,QAApB;IACAxD,IAAI,CAAC0D,EAAL,CAAQF,QAAR;GAJK;;eAgKC,GAAR;SACOG,aAAL;SACKC,eAAL;SACKd,YAAL;SACKe,eAAL;SACKhU,MAAL;SACKiU,kBAAL;GANM;;uBASA,GAAR;QACQnV,OAAO,GAAG,KAAKA,OAArB;QACMgO,eAAe,GAAG,KAAKA,eAA7B;QACMzL,aAAa,GAAG,KAAKA,aAA3B;QACMnG,WAAW,GAAG4D,OAAO,CAAC5D,WAA5B;;IAGA4R,eAAe,CAACtU,SAAhB,GAA+B0C,WAAW,cAA1C;IACAmG,aAAa,CAAC7I,SAAd,GAA6B0C,WAAW,YAAxC;IAEAyE,QAAQ,CAACmN,eAAD,EAAkBlQ,oBAAlB,CAAR;IACA+C,QAAQ,CAAC0B,aAAD,EAAgBrE,kBAAhB,CAAR;;QAEI8B,OAAO,CAACzC,MAAZ,EAAoB;MAClByQ,eAAe,CAACrV,KAAhB,CAAsB4E,MAAtB,GAA+B,KAAGyC,OAAO,CAACzC,MAA1C;;;QAEEyC,OAAO,CAACvC,QAAZ,EAAsB;MACpBuQ,eAAe,CAACrV,KAAhB,CAAsB8E,QAAtB,GAAiC,SAAjC;;GAjBI;;yBAqBA,GAAR;QACQ0C,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QAEMyQ,UAAU,GAAGtQ,KAAK,CAACsQ,UAAzB;QACMnU,UAAU,GAAG0D,OAAO,CAAC1D,UAA3B;SAEK+U,IAAL,GAAY,IAAI+D,IAAJ,CAAS;MACnBtN,KAAK,EAAE;QACLrM,KAAK,EAAE,CAACgV,UAAU,CAACjB,IAAZ,EAAkBiB,UAAU,CAACV,IAA7B,CADF;QAELxT,QAAQ,EAAEyD,OAAO,CAACzD,QAFb;QAGLa,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ;;KAJA,EAMT;MACDiY,MAAM,EAAErV,OAAO,CAAClD,WADf;MAEDT,YAAY,EAAE2D,OAAO,CAAC3D,YAFrB;MAGDiZ,aAAa,EAAE;KATL,CAAZ;SAYKpC,QAAL,GAAgB,IAAIqC,QAAJ,CAAa,KAAKvH,eAAlB,EAAmC;MACjD9Q,SAAS,EAAE8C,OAAO,CAAC9C,SAD8B;MAEjDC,cAAc,EAAE6C,OAAO,CAAC7C,cAFyB;MAGjDqY,KAAK,EAAExV,OAAO,CAAC1D,UAAR,GAAqB,CAAC,CAAC,CAAF,EAAK,CAAL,CAArB,GAA+B,CAAC,CAAD,EAAI,CAAC,CAAL;KAHxB,CAAhB;SAMK+U,IAAL,CAAUoE,OAAV,CAAkBnZ,UAAU,GAAG,CAAC,OAAD,EAAU,EAAV,CAAH,GAAmB,CAAC,EAAD,EAAK,OAAL,CAA/C,EAA8D,KAAK4W,QAAnE;GAzBM;;sBA4BA,GAAR;oBAAA;;;QAEQwC,aAAa,GAAG,KAAKnT,aAAL,CAAmBtK,QAAzC;;QAGMuK,MAAM,GAAGxK,OAAO,CAAC0d,aAAD,CAAP,CAAuBzP,GAAvB,CACb,UAACxO,EAAD,EAAkBuD,GAAlB;aAAkC,IAAI+G,KAAJ,CAAUtK,EAAV,EAAcuD,GAAd,EAAmBiM,KAAI,CAACjH,OAAxB,CAAA;KADrB,CAAf;;QAIIwC,MAAM,CAAC/I,MAAP,GAAgB,CAApB,EAAuB;WAChB4O,YAAL,CAAkBsN,MAAlB,CAAyBnT,MAAzB;;GAVI;;yBAcA,GAAR;QACQxC,OAAO,GAAG,KAAKA,OAArB;QACMqI,YAAY,GAAG,KAAKA,YAA1B;QACM0D,UAAU,GAAG,KAAK1D,YAAL,CAAkB2D,QAAlB,EAAnB;QACMjM,KAAK,GAAGhF,KAAK,CAACiF,OAAO,CAAC/C,YAAT,EAAuB8O,UAAU,CAAC7R,GAAlC,EAAuC6R,UAAU,CAAC5R,GAAlD,CAAnB;SAEKgQ,YAAL,GAAoB9B,YAAY,CAAC2E,GAAb,CAAiBjN,KAAjB,CAApB;GANM;;qBASA,GAAR;oBAAA;;QACQI,KAAK,GAAG,KAAKA,KAAnB;QACMkI,YAAY,GAAG,KAAKA,YAA1B;QAEMuN,YAAY,GAAGzV,KAAK,CAACE,IAA3B;QACMuC,UAAU,GAAGyF,YAAY,CAACzF,UAAb,EAAnB;QACMC,SAAS,GAAGwF,YAAY,CAACxF,SAAb,EAAlB;;QAGI,CAACD,UAAL,EAAiB;;;;QAIXiT,oBAAoB,GAAGhT,SAAS,CAAC4F,WAAV,KAA0B5F,SAAS,CAAC4H,OAAV,EAA1B,GAAgD7H,UAAU,CAAC6F,WAAX,EAAhD,GAA2E,KAAKzI,OAAL,CAAapC,GAArH;QACMkY,eAAe,GAAGF,YAAY,GAAGhT,UAAU,CAAC8H,yBAAX,EAAvC;;QAGMlI,MAAM,GAAG6F,YAAY,CAAC9C,cAAb,EAAf;QAEMC,UAAU,GAAGpL,IAAI,CAAC2b,IAAL,CAAUD,eAAe,GAAGD,oBAA5B,CAAnB;QACMG,cAAc,GAAG3N,YAAY,CAAC5C,aAAb,EAAvB;;QAEID,UAAU,GAAGwQ,cAAjB,EAAiC;8BAEtBxV;YACDiC,MAAM,GAAGD,MAAM,CAACyD,GAAP,CAAW,UAAAgQ,SAAA;cAClBnU,WAAW,GAAGmU,SAAS,CAAC/P,KAAV,CAAgB1F,UAAhB,CAApB;;UAEAyG,KAAI,CAAC1E,aAAL,CAAmBmB,WAAnB,CAA+B5B,WAAW,CAACyB,UAAZ,EAA/B;;iBACOzB,WAAP;SAJa,CAAf;QAMAuG,YAAY,CAACjC,YAAb,CAA0B5F,UAA1B,EAAsC,CAAtC,EAAyCiC,MAAzC;QAT6B;;;WAE1B,IAAIjC,UAAU,GAAGwV,cAAtB,EAAsCxV,UAAU,GAAGgF,UAAnD,EAA+DhF,UAAU,EAAzE;gBAASA;;KAFX,MAWO,IAAIgF,UAAU,GAAGwQ,cAAjB,EAAiC;;MAEtC3N,YAAY,CAAC6N,iBAAb,CAA+B1Q,UAA/B;;GAnCI;;4BAuCA,GAAR;QACQrF,KAAK,GAAG,KAAKA,KAAnB;QACMkI,YAAY,GAAG,KAAKA,YAA1B;QACMrI,OAAO,GAAG,KAAKA,OAArB;QACM+L,UAAU,GAAG,KAAK1D,YAAL,CAAkB2D,QAAlB,EAAnB;QAEM/O,YAAY,GAAGlC,KAAK,CAACiF,OAAO,CAAC/C,YAAT,EAAuB8O,UAAU,CAAC7R,GAAlC,EAAuC6R,UAAU,CAAC5R,GAAlD,CAA1B;QACMgc,YAAY,GAAG9N,YAAY,CAAC2E,GAAb,CAAiB/P,YAAjB,CAArB;QAEImZ,eAAe,GAAG,CAAtB;;QACID,YAAJ,EAAkB;MAChBC,eAAe,GAAGD,YAAY,CAACxK,iBAAb,KAAmCxL,KAAK,CAACqQ,sBAA3D;MACA4F,eAAe,GAAG,KAAKlF,eAAL,KACdnW,KAAK,CAACqb,eAAD,EAAkBjW,KAAK,CAACsQ,UAAN,CAAiBjB,IAAnC,EAAyCrP,KAAK,CAACsQ,UAAN,CAAiBV,IAA1D,CADS,GAEdqG,eAFJ;;;SAKGvN,UAAL,CAAgBuN,eAAhB;SACK/E,IAAL,CAAUtJ,KAAV,CAAgB;MAAED,KAAK,EAAEsO;KAAzB,EAA4C,CAA5C;GAlBM;;yBAqBA,GAAR;QACQjW,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QACM6C,SAAS,GAAG,KAAKwF,YAAL,CAAkBxF,SAAlB,EAAlB;;QACI,CAACA,SAAL,EAAgB;aACP,KAAP;;;QAGIwT,eAAe,GAAGxT,SAAS,CAAC4F,WAAV,KAA0B5F,SAAS,CAAC4H,OAAV,EAAlD;WAEOzK,OAAO,CAACxC,KAAR,IACF,CAACwC,OAAO,CAACzD,QADP,IAEF8Z,eAAe,IAAIlW,KAAK,CAACE,IAF9B;GAVM;;oBAeA,GAAR;QACQF,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QACMgO,eAAe,GAAG,KAAKA,eAA7B;QACMxL,MAAM,GAAG,KAAK6F,YAAL,CAAkB9C,cAAlB,EAAf;;QAEI,CAACvF,OAAO,CAAC1D,UAAb,EAAyB;;MAEvB0R,eAAe,CAACrV,KAAhB,CAAsBqF,KAAtB,GAA8B,EAA9B;MACAgQ,eAAe,CAACrV,KAAhB,CAAsBkb,QAAtB,GAAiC,EAAjC;;;QAGI/S,IAAI,GAAGkN,eAAe,CAAC3M,qBAAhB,EAAb;;IAGAlB,KAAK,CAACE,IAAN,GAAaL,OAAO,CAAC1D,UAAR,GACTwE,IAAI,CAAC9C,KADI,GAET8C,IAAI,CAAC7C,MAFT;IAIAkC,KAAK,CAACqQ,sBAAN,GAA+BxP,yBAAyB,CAAChB,OAAO,CAACtC,MAAT,EAAiByC,KAAK,CAACE,IAAvB,CAAxD;IACAF,KAAK,CAAC1D,iBAAN,GAA0BuE,yBAAyB,CAAChB,OAAO,CAACvD,iBAAT,EAA4B0D,KAAK,CAACE,IAAlC,CAAnD;;IAGAmC,MAAM,CAACzL,OAAP,CAAe,UAAAkK,KAAA;MACbA,KAAK,CAACC,MAAN;KADF;GAvBM;;sCA4BA,GAAR;QACQtD,GAAG,GAAG,KAAKoC,OAAL,CAAapC,GAAzB;QACMyK,YAAY,GAAG,KAAKA,YAA1B;QAEMzF,UAAU,GAAGyF,YAAY,CAACzF,UAAb,EAAnB;QACMJ,MAAM,GAAG6F,YAAY,CAAC9C,cAAb,EAAf;;QAEI,CAAC3C,UAAL,EAAiB;;;;QAIXuH,YAAY,GAAG,KAAKA,YAA1B;QACME,YAAY,GAAG,KAAKA,YAA1B;QACMiD,YAAY,GAAG,KAAKY,YAAL,CAAkB6C,QAAlB,EAArB;;QAGIuF,YAAY,GAAG1T,UAAU,CAAC6F,WAAX,EAAnB;QACI8N,gBAAgB,GAAU3T,UAA9B;;QACI,CAAC0K,YAAY,CAACkJ,OAAb,IAAwBlJ,YAAY,CAACmJ,OAAtC,KAAkDpM,YAAtD,EAAoE;;UAE5DyC,YAAY,GAAG3C,YAAY,CAACrH,QAAb,KACjB,CAACqH,YAAY,CAACmC,aAAb,KAA+B,CAAhC,IAAqC9J,MAAM,CAAC/I,MADhD;UAEM4a,YAAY,GAAGhK,YAAY,CAACvH,QAAb,KACjB,CAACuH,YAAY,CAACiC,aAAb,KAA+B,CAAhC,IAAqC9J,MAAM,CAAC/I,MADhD;UAEMid,MAAM,GAAI5J,YAAY,IAAIuH,YAAhB,IAAgC/G,YAAY,CAAC7G,KAAb,GAAqB,CAAtD,IACTqG,YAAY,IAAIuH,YAAhB,IAAgC/G,YAAY,CAAC7G,KAAb,GAAqB,CAD3D;MAGA8P,gBAAgB,GAAGG,MAAM,GACrBvM,YADqB,GAErBE,YAFJ;KATF,MAYO,IAAIzH,UAAU,CAACE,QAAX,KAAwB,CAA5B,EAA+B;MACpCyT,gBAAgB,GAAGpM,YAAnB;;;QAGIwM,yBAAyB,GAAGnU,MAAM,CAAClI,KAAP,CAAa,CAAb,EAAgBic,gBAAgB,CAACzT,QAAjB,KAA8B,CAACyT,gBAAgB,CAACjK,aAAjB,KAAmC,CAApC,IAAyC9J,MAAM,CAAC/I,MAA9F,CAAlC;QACMmd,eAAe,GAAGD,yBAAyB,CAACjU,MAA1B,CAAiC,UAACmU,KAAD,EAAQ5V,KAAR;aAChD4V,KAAK,GAAG5V,KAAK,CAACwJ,OAAN,EAAR,GAA0B7M,GAAjC;KADsB,EAErB,CAFqB,CAAxB;IAIA0Y,YAAY,GAAGC,gBAAgB,CAAC9N,WAAjB,KAAiCmO,eAAhD;IAEApU,MAAM,CAACzL,OAAP,CAAe,UAAAkK,KAAA;UACP4O,WAAW,GAAGyG,YAApB;UACMlH,eAAe,GAAGnO,KAAK,CAACwH,WAAN,EAAxB;UACMmE,SAAS,GAAG3L,KAAK,CAACwJ,OAAN,EAAlB;;UAEI2E,eAAe,KAAKS,WAAxB,EAAqC;QACnC5O,KAAK,CAAC6V,WAAN,CAAkBjH,WAAlB;;;MAEFyG,YAAY,IAAI1J,SAAS,GAAGhP,GAA5B;KARF;GAzCM;;oCAqDA,GAAR;QACQuC,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QACMqI,YAAY,GAAG,KAAKA,YAA1B;QACM/H,YAAY,GAAG+H,YAAY,CAAC/H,YAAb,GAClB0C,MADkB,CACX,UAAA/B,KAAA;aAAS,CAAC,CAACA,KAAF;KADE,CAArB;QAGMwP,UAAU,GAAGtQ,KAAK,CAACsQ,UAAzB;QAEM7N,UAAU,GAAGyF,YAAY,CAACzF,UAAb,EAAnB;QACMC,SAAS,GAAGwF,YAAY,CAACxF,SAAb,EAAlB;;QAEI,CAACD,UAAL,EAAiB;;;;QAIXiT,oBAAoB,GAAGhT,SAAS,CAAC4F,WAAV,KAA0B5F,SAAS,CAAC4H,OAAV,EAA1B,GAAgD7H,UAAU,CAAC6F,WAAX,EAAhD,GAA2EzI,OAAO,CAACpC,GAAhH;;SAGoB,UAAA,EAAAmZ,6BAApB,EAAoBlgB,0BAApB,EAAoBA,IAApB;UAAWoK,KAAK,qBAAX;;UACC,CAACA,KAAL,EAAY;;;;UAINgV,SAAS,GAAGhV,KAAK,CAAC0L,gBAAN,EAAlB;UACMnM,UAAU,GAAGS,KAAK,CAACqL,aAAN,EAAnB;UACM0K,YAAY,GAAGnB,oBAAoB,IAAIrV,UAAU,GAAG,CAAjB,CAAzC;UACMyW,cAAc,GAAGD,YAAY,GAAGf,SAAS,CAACxN,WAAV,EAAtC;MAEAxH,KAAK,CAAC6V,WAAN,CAAkBG,cAAlB;;;QAGEC,mBAAmB,GAAGtU,UAAU,CAAC6F,WAAX,EAA1B;;SAEoB,UAAA,EAAA0O,KAAA7W,YAAY,CAACqE,MAAb,GAAsBC,OAAtB,EAApB,EAAoBzB,cAApB,EAAoBA,IAApB;UAAWlC,KAAK,SAAX;UACG2L,SAAS,GAAG3L,KAAK,CAACwJ,OAAN,EAAlB;UACM2M,eAAe,GAAGF,mBAAmB,GAAGtK,SAAtB,GAAkC5M,OAAO,CAACpC,GAAlE;;UAEIwZ,eAAe,GAAGxK,SAAlB,IAA+B6D,UAAU,CAACjB,IAA9C,EAAoD;;;;;MAKpDvO,KAAK,CAAC6V,WAAN,CAAkBM,eAAlB;MACAF,mBAAmB,GAAGE,eAAtB;;GA5CI;;0BAgDA,GAAR;QACQjX,KAAK,GAAG,KAAKA,KAAnB;QACMkI,YAAY,GAAG,KAAKA,YAA1B;QACMrI,OAAO,GAAG,KAAKA,OAArB;QACMqR,IAAI,GAAG,KAAKA,IAAlB;;QAGMzO,UAAU,GAAGyF,YAAY,CAACzF,UAAb,EAAnB;QACMC,SAAS,GAAGwF,YAAY,CAACxF,SAAb,EAAlB;QACM2N,sBAAsB,GAAGrQ,KAAK,CAACqQ,sBAArC;;QAEI,CAAC5N,UAAL,EAAiB;MACfzC,KAAK,CAACsQ,UAAN,GAAmB;QACjBjB,IAAI,EAAE,CADW;QAEjBO,IAAI,EAAE;OAFR;KADF,MAKO,IAAI,KAAKmB,eAAL,EAAJ,EAA4B;MACjC/Q,KAAK,CAACsQ,UAAN,GAAmB;QACjBjB,IAAI,EAAE5M,UAAU,CAAC6F,WAAX,EADW;QAEjBsH,IAAI,EAAElN,SAAS,CAAC4F,WAAV,KAA0B5F,SAAS,CAAC4H,OAAV,EAA1B,GAAgDtK,KAAK,CAACE;OAF9D;KADK,MAKA,IAAIL,OAAO,CAACzD,QAAZ,EAAsB;UACrBsZ,oBAAoB,GAAGhT,SAAS,CAAC4F,WAAV,KAA0B5F,SAAS,CAAC4H,OAAV,EAA1B,GAAgD7H,UAAU,CAAC6F,WAAX,EAAhD,GAA2EzI,OAAO,CAACpC,GAAhH,CAD2B;;MAI3BuC,KAAK,CAACsQ,UAAN,GAAmB;QACjBjB,IAAI,EAAE5M,UAAU,CAAC+I,iBAAX,KAAiC6E,sBADtB;QAEjBT,IAAI,EAAE8F,oBAAoB,GAAGjT,UAAU,CAAC+I,iBAAX,EAAvB,GAAwD6E;OAFhE;KAJK,MAQA;MACLrQ,KAAK,CAACsQ,UAAN,GAAmB;QACjBjB,IAAI,EAAE5M,UAAU,CAAC+I,iBAAX,KAAiC6E,sBADtB;QAEjBT,IAAI,EAAElN,SAAS,CAAC8I,iBAAV,KAAgC6E;OAFxC;;;QAMIoF,YAAY,GAAGzV,KAAK,CAACE,IAA3B;QACMjD,MAAM,GAAG4C,OAAO,CAAC5C,MAAvB;QAEIia,YAAY,GAAaja,MAA7B;;QACI7F,OAAO,CAAC6F,MAAD,CAAX,EAAqB;MACnBia,YAAY,GAAIja,MAAmB,CAAC6I,GAApB,CAAwB,UAAAhM,GAAA;eAAO+G,yBAAyB,CAAC/G,GAAD,EAAM2b,YAAN,EAAoBzZ,eAAe,CAACiB,MAApC,CAAzB;OAA/B,CAAhB;KADF,MAEO;UACCka,SAAS,GAAGtW,yBAAyB,CAAC5D,MAAD,EAA4BwY,YAA5B,EAA0CzZ,eAAe,CAACiB,MAA1D,CAA3C;MACAia,YAAY,GAAG,CAACC,SAAD,EAAYA,SAAZ,CAAf;;;;QAIIxP,KAAK,GAAGuJ,IAAI,CAACkG,IAAL,CAAUzP,KAAxB;IACAA,KAAK,CAACrM,KAAN,GAAc,CAAC0E,KAAK,CAACsQ,UAAN,CAAiBjB,IAAlB,EAAwBrP,KAAK,CAACsQ,UAAN,CAAiBV,IAAzC,CAAd;IACAjI,KAAK,CAAC1K,MAAN,GAAeia,YAAf;GAlDM;;;8BAsDA,GAAR;QACQlX,KAAK,GAAG,KAAKA,KAAnB;QACMkR,IAAI,GAAG,KAAKA,IAAlB;QACMlH,YAAY,GAAG,KAAKC,eAAL,EAArB;QACMkD,YAAY,GAAG,KAAKY,YAAL,CAAkB6C,QAAlB,EAArB;;QAEI,CAAC5G,YAAD,IAAiBmD,YAAY,CAACkJ,OAA9B,IAAyClJ,YAAY,CAACmJ,OAA1D,EAAmE;;;;QAI/D5G,WAAW,GAAG1F,YAAY,CAACwB,iBAAb,KAAmCxL,KAAK,CAACqQ,sBAA3D;;QAEI,KAAKU,eAAL,EAAJ,EAA4B;MAC1BrB,WAAW,GAAG9U,KAAK,CAAC8U,WAAD,EAAc1P,KAAK,CAACsQ,UAAN,CAAiBjB,IAA/B,EAAqCrP,KAAK,CAACsQ,UAAN,CAAiBV,IAAtD,CAAnB;;;;;SAKGsB,IAAL,CAAUmG,GAAV;IACAnG,IAAI,CAACtJ,KAAL,CAAW;MACTD,KAAK,EAAE+H;KADT,EAEG,CAFH;SAGKwB,IAAL,CAAU0D,EAAV,CAAa,KAAKD,YAAlB;SACKjM,UAAL,CAAgBgH,WAAhB;GAvBM;;wBA0BA,GAAR,UAAuB5B,SAAvB;QACQ9N,KAAK,GAAG,KAAKA,KAAnB;QACMH,OAAO,GAAG,KAAKA,OAArB;QACMqI,YAAY,GAAG,KAAKA,YAA1B;QACM8B,YAAY,GAAG,KAAKA,YAA1B;QACME,YAAY,GAAG,KAAKA,YAA1B;QACMiD,YAAY,GAAG,KAAKY,YAAL,CAAkB6C,QAAlB,EAArB;;QAEI,CAAC/Q,OAAO,CAACxD,QAAb,EAAuB;;;;QAIjBoB,GAAG,GAAGoC,OAAO,CAACpC,GAApB;QACMnB,iBAAiB,GAAG0D,KAAK,CAAC1D,iBAAhC;QACMgb,YAAY,GAAGpP,YAAY,CAAC2H,YAAb,EAArB;;QAEIyH,YAAY,GAAG,CAAnB,EAAsB;;;;QAIlB,CAACtN,YAAD,IAAiB,CAACE,YAAtB,EAAoC;;WAE7BqN,gBAAL,CAAsB;QACpBzJ,SAAS,WADW;QAEpBlO,KAAK,EAAE,CAFa;QAGpB2G,SAAS,EAAE,IAHS;QAIpBqF,UAAU,EAAE;UACV7R,GAAG,EAAE,CADK;UAEVC,GAAG,EAAEsd,YAFK;UAGVhe,MAAM,EAAEge,YAAY,GAAG;;OAP3B;;;;QAaInG,uBAAuB,GAAGjH,YAAY,CAAC5B,WAAb,EAAhC;;QAGIkP,aAAa,GAAiB,CAACrK,YAAY,CAACkJ,OAAd,IAAyB,CAAClJ,YAAY,CAACmJ,OAAvC,GAC9BtM,YAD8B,GAE9BE,YAFJ;;WAGOsN,aAAP,EAAsB;UACd7K,YAAY,GAAG6K,aAAa,CAAC7U,QAAd,EAArB;UACM5C,WAAW,GAAGyX,aAAa,CAACzX,WAAlC;UACI2C,SAAS,GAAGwF,YAAY,CAACxF,SAAb,EAAhB;UACI+U,WAAW,GAAG9K,YAAY,KAAKjK,SAAS,CAACC,QAAV,EAAnC;UACMmN,SAAS,GAAG,CAAC2H,WAAD,IAAgB1X,WAAhB,GACdA,WAAW,CAAC4C,QAAZ,EADc,GAEd2U,YAAY,GAAG,CAFnB;UAGMI,sBAAsB,GAAGxN,YAAY,CAAC5B,WAAb,EAA/B;UACMqP,UAAU,GAAGH,aAAa,CAAClP,WAAd,KAA8BkP,aAAa,CAAClN,OAAd,EAA9B,IAAyDoN,sBAAsB,GAAGvG,uBAAlF,CAAnB;UACMyG,UAAU,GAAG5X,KAAK,CAACpC,QAAN,GAAiBoC,KAAK,CAACE,IAA1C,CAVoB;;UAad2X,uBAAuB,GAAI/H,SAAS,GAAGnD,YAAZ,GAA2B,CAA5D,CAboB;;UAed7C,aAAa,GAAG6N,UAAU,GAAGla,GAAb,GAAmBnB,iBAAnB,IAAwCsb,UAA9D;;UAEIC,uBAAuB,IAAI/N,aAA/B,EAA8C;aACvCyN,gBAAL,CAAsB;UACpBzJ,SAAS,WADW;UAEpBlO,KAAK,EAAE4X,aAAa,CAAC7U,QAAd,EAFa;UAGpByJ,YAAY,EAAEoL,aAHM;UAIpBjR,SAAS,EAAE/G,SAAS,CAACE,IAJD;UAKpBkM,UAAU,EAAE;YACV7R,GAAG,EAAE4S,YAAY,GAAG,CADV;YAEV3S,GAAG,EAAE8V,SAAS,GAAG,CAFP;YAGVxW,MAAM,EAAEwW,SAAS,GAAGnD,YAAZ,GAA2B;;SARvC;OAlBkB;;;UAgChB9M,OAAO,CAACzD,QAAR,IAAoBuQ,YAAY,KAAK2K,YAArC,IAAqDxN,aAAzD,EAAwE;YAChErH,UAAU,GAAGyF,YAAY,CAACzF,UAAb,EAAnB;YACMqV,UAAU,GAAGrV,UAAU,CAACE,QAAX,EAAnB;;YAEImV,UAAU,GAAG,CAAjB,EAAoB;eACbP,gBAAL,CAAsB;YACpBzJ,SAAS,WADW;YAEpBlO,KAAK,EAAE4X,aAAa,CAAC7U,QAAd,EAFa;YAGpByJ,YAAY,EAAEoL,aAHM;YAIpBjR,SAAS,EAAE/G,SAAS,CAACE,IAJD;YAKpBkM,UAAU,EAAE;cACV7R,GAAG,EAAE,CADK;cAEVC,GAAG,EAAE8d,UAAU,GAAG,CAFR;cAGVxe,MAAM,EAAEwe;;WARZ;;OArCgB;;;MAoDpBpV,SAAS,GAAGwF,YAAY,CAACxF,SAAb,EAAZ;MACA+U,WAAW,GAAG9K,YAAY,KAAKjK,SAAS,CAACC,QAAV,EAA/B;;UAEI8U,WAAW,IAAI,CAAC3N,aAApB,EAAmC;;;;MAInC0N,aAAa,GAAGA,aAAa,CAACzX,WAA9B;;;;IAIFyX,aAAa,GAAGtN,YAAhB;;WACOsN,aAAP,EAAsB;UACdO,UAAU,GAAG/X,KAAK,CAACpC,QAAzB;UACMoa,aAAa,GAAGR,aAAa,CAAC7U,QAAd,EAAtB;UACM7C,WAAW,GAAG0X,aAAa,CAAC1X,WAAlC;UACI2C,UAAU,GAAGyF,YAAY,CAACzF,UAAb,EAAjB;UACIwV,YAAY,GAAGD,aAAa,KAAKvV,UAAU,CAACE,QAAX,EAArC;UACM2M,SAAS,GAAG,CAAC2I,YAAD,IAAiBnY,WAAjB,GACdA,WAAW,CAAC6C,QAAZ,EADc,GAEd,CAAC,CAFL;UAGM+U,sBAAsB,GAAGxN,YAAY,CAAC5B,WAAb,EAA/B;UACM4P,SAAS,GAAGV,aAAa,CAAClP,WAAd,MAA+BoP,sBAAsB,GAAGvG,uBAAxD,CAAlB,CAVoB;;UAad0G,uBAAuB,GAAGG,aAAa,GAAG1I,SAAhB,GAA4B,CAA5D,CAboB;;UAedxF,aAAa,GAAGoO,SAAS,GAAGza,GAAZ,GAAkBnB,iBAAlB,IAAuCyb,UAA7D;;UACIF,uBAAuB,IAAI/N,aAA/B,EAA8C;aACvCyN,gBAAL,CAAsB;UACpBzJ,SAAS,WADW;UAEpBlO,KAAK,EAAE4X,aAAa,CAAC7U,QAAd,EAFa;UAGpByJ,YAAY,EAAEoL,aAHM;UAIpBjR,SAAS,EAAE/G,SAAS,CAACC,IAJD;UAKpBmM,UAAU,EAAE;YACV7R,GAAG,EAAEuV,SAAS,GAAG,CADP;YAEVtV,GAAG,EAAEge,aAAa,GAAG,CAFX;YAGV1e,MAAM,EAAE0e,aAAa,GAAG1I,SAAhB,GAA4B;;SARxC;OAjBkB;;;UA+BhBzP,OAAO,CAACzD,QAAR,IAAoB4b,aAAa,KAAK,CAAtC,IAA2ClO,aAA/C,EAA8D;YACtDpH,SAAS,GAAGwF,YAAY,CAACxF,SAAb,EAAlB;YACMnG,SAAS,GAAGmG,SAAS,CAACC,QAAV,EAAlB;;YAEIpG,SAAS,GAAG+a,YAAhB,EAA8B;eACvBC,gBAAL,CAAsB;YACpBzJ,SAAS,WADW;YAEpBlO,KAAK,EAAE4X,aAAa,CAAC7U,QAAd,EAFa;YAGpByJ,YAAY,EAAEoL,aAHM;YAIpBjR,SAAS,EAAE/G,SAAS,CAACC,IAJD;YAKpBmM,UAAU,EAAE;cACV7R,GAAG,EAAEwC,SAAS,GAAG,CADP;cAEVvC,GAAG,EAAEsd,YAFK;cAGVhe,MAAM,EAAEge,YAAY,GAAG/a;;WAR3B;;OApCgB;;;MAmDpBkG,UAAU,GAAGyF,YAAY,CAACzF,UAAb,EAAb;MACAwV,YAAY,GAAGD,aAAa,KAAKvV,UAAU,CAACE,QAAX,EAAjC,CApDoB;;UAuDhBsV,YAAY,IAAI,CAACnO,aAArB,EAAoC;;;;MAIpC0N,aAAa,GAAGA,aAAa,CAAC1X,WAA9B;;GApKI;;0BAwKA,GAAR,UAAyB2L,MAAzB;QAOUqC,4BAAA;QAAWlO,oBAAX;QAAkBwM,kCAAlB;QAAgC7F,4BAAhC;QAA2CqF,8BAA3C;QACF4E,cAAc,GAAG,KAAKxQ,KAAL,CAAWwQ,cAAlC;QACM2H,gBAAgB,GAAG3H,cAAc,CAAC4H,IAAf,CAAoB,UAACpV,EAAD;UAAEjJ;UAAKC;aAASD,GAAG,KAAK6R,UAAU,CAAC7R,GAAnB,IAA0BC,GAAG,KAAK4R,UAAU,CAAC5R,GAA7C;KAApC,CAAzB;QACMqe,UAAU,GAAG,KAAKtR,QAAL,CAAcuR,KAAd,CAAoBpa,MAAM,CAACS,UAA3B,CAAnB;;QAEIwZ,gBAAgB,IAAI,CAACE,UAAzB,EAAqC;;;;;IAKrC7H,cAAc,CAAC5Y,IAAf,CAAoB,CAACgU,UAAU,CAAC7R,GAAZ,EAAiB6R,UAAU,CAAC5R,GAA5B,CAApB;QAEM+S,SAAS,GAAGe,SAAS,GACvBA,SAAS,CAACf,SADa,GAEvB,KAFJ;QAGMjM,KAAK,GAAGsL,YAAY,GACtB,KAAK7D,mBAAL,CAAyB6D,YAAzB,CADsB,GAEtB,IAFJ;SAIKpF,YAAL,CACE9I,MAAM,CAACS,UADT,EAEEmP,SAFF,EAGEf,SAHF,EAIE;MACEnN,KAAK,OADP;MAEEkB,KAAK,OAFP;MAGEyF,SAAS,WAHX;MAIEjL,KAAK,EAAEsQ;KARX;GA1BM;;iBAsCV;GAt0CA;;ACHA;;;;;;;;;;AASA;;;EAAuB/E,SAAA,SAAA,QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAuDrB,CACE3P,OADF,EAEE2I,OAFF;0BAEE,EAAA;MAAAA,YAAA;;;gBAEA2I,WAAA,KAAA,SAJF;;IA1BQ1B,aAAA,GAAoB,EAApB;;IAkiBAA,kBAAA,GAAe,UACrByR,SADqB,EAErBzK,SAFqB,EAGrBf,SAHqB,EAIrBtB,MAJqB;2BAIrB,EAAA;QAAAA,WAAA;;;UAEM/D,QAAQ,GAAGZ,KAAI,CAACY,QAAtB;UAEI8Q,QAAQ,GAAY,IAAxB;;UAGI9Q,QAAJ,EAAc;YACN1H,KAAK,GAAG0H,QAAQ,CAACqG,YAAT,CAAsB6C,QAAtB,EAAd;;YACM5N,6BAAA;YAAEqM,cAAF;YAAQO,cAAR;;YACAvU,GAAG,GAAGqM,QAAQ,CAACG,iBAAT,EAAZ;YACIoG,QAAQ,GAAGD,WAAW,CAAC3S,GAAD,EAAM,CAACgU,IAAD,EAAOA,IAAP,EAAaO,IAAb,CAAN,CAA1B;;YAEI9I,KAAI,CAACjH,OAAL,CAAazD,QAAjB,EAA2B;UACzB6R,QAAQ,IAAI,CAAZ;;;QAEFuK,QAAQ,GAAG,CAAChQ,gBAAA,CAAMiQ,OAAN,KAAA,MAAA,EAAcF,SAAd,EAAyBG,KAAK,CAAC;UACzC7c,IAAI,EAAE0c,SADmC;UAEzC3Y,KAAK,EAAEkH,KAAI,CAACnE,QAAL,EAFkC;UAGzC7B,KAAK,EAAEgG,KAAI,CAACmD,eAAL,EAHkC;UAIzC1D,SAAS,EAAEvG,KAAK,CAACuG,SAJwB;UAKzC8P,OAAO,EAAErW,KAAK,CAACqW,OAL0B;UAMzCpI,QAAQ,UANiC;UAOzCH,SAAS,WAPgC;UAQzCf,SAAS;SAR+B,EASvCtB,MATuC,CAA9B,CAAZ;;;aAYK;QACLtE,SAAS,EAAT,UAAU3L,QAAV;cACM,CAACgd,QAAL,EAAe;YACbhd,QAAQ;;;iBAEH,IAAP;SALG;QAOL4L,SAAS,EAAT,UAAU5L,QAAV;cACMgd,QAAJ,EAAc;YACZhd,QAAQ;;;iBAEH,IAAP;;OAXJ;KAhCM;;;IAiDAsL,gBAAA,GAAa,UAACgH,SAAD;UACbpG,QAAQ,GAAGZ,KAAI,CAACY,QAAtB;UACM1H,KAAK,GAAG0H,QAAQ,CAACqG,YAAT,CAAsB6C,QAAtB,EAAd;UACM/Q,OAAO,GAAGiH,KAAI,CAACjH,OAArB;UAEMxE,GAAG,GAAGyS,SAAS,CAACzS,GAAV,CAAcsM,KAA1B;UACMgR,gBAAgB,GAAGjR,QAAQ,CAACG,iBAAT,EAAzB;;UAEIiG,SAAS,CAACf,SAAV,IAAuB/M,KAAK,CAACqW,OAAjC,EAA0C;YAClCuC,WAAW,GAAG/Y,OAAO,CAAC1D,UAAR,GAChB2R,SAAS,CAACvG,UAAV,CAAqBC,OADL,GAEhBsG,SAAS,CAACvG,UAAV,CAAqBE,OAFzB;YAIM+B,eAAe,GAAGoP,WAAW,GAAG,CAAtC;YAEIC,YAAY,GAAGxd,GAAG,GAAGsd,gBAAzB;YACMpC,MAAM,GAAG/M,eAAe,KAAMnO,GAAG,GAAGsd,gBAA1C;;YACI9Y,OAAO,CAACzD,QAAR,IAAoBma,MAAxB,EAAgC;;cAExB7K,cAAc,GAAGhE,QAAQ,CAACiE,iBAAT,EAAvB;UACAkN,YAAY,GAAG,CAAC5e,IAAI,CAACgB,IAAL,CAAU4d,YAAV,CAAD,IAA4BnN,cAAc,GAAGzR,IAAI,CAACgP,GAAL,CAAS4P,YAAT,CAA7C,CAAf;;;YAGIC,gBAAgB,GAAGD,YAAY,KAAK,CAAjB,GACrB7Y,KAAK,CAACuG,SADe,GAErBsS,YAAY,GAAG,CAAf,GACErZ,SAAS,CAACE,IADZ,GAEEF,SAAS,CAACC,IAJhB;QAMAO,KAAK,CAACsG,KAAN,IAAeuS,YAAf;QACA7Y,KAAK,CAACuG,SAAN,GAAkBuS,gBAAlB;;;MAGFpR,QAAQ,CAACgB,UAAT,CAAoBrN,GAApB,EAAyByS,SAAzB;aACOhH,KAAI,CAACE,YAAL,CAAkB9I,MAAM,CAACI,IAAzB,EAA+BwP,SAA/B,EAA0CA,SAAS,CAACf,SAApD,EACJ3F,SADI,CACM;;QAETM,QAAQ,CAACgB,UAAT,CAAoBiQ,gBAApB,EAAsC7K,SAAtC;OAHG,CAAP;KAlCM;;;QAljBF6F,OAAJ;;QACIpc,QAAQ,CAACL,OAAD,CAAZ,EAAuB;MACrByc,OAAO,GAAGlc,QAAQ,CAACshB,aAAT,CAAuB7hB,OAAvB,CAAV;;UACI,CAACyc,OAAL,EAAc;cACN,IAAIhb,KAAJ,CAAU,6BAAV,CAAN;;KAHJ,MAKO,IAAIzB,OAAO,CAAC8hB,QAAR,IAAoB9hB,OAAO,CAAC+hB,QAAR,KAAqB,CAA7C,EAAgD;MACrDtF,OAAO,GAAGzc,OAAV;KADK,MAEA;YACC,IAAIyB,KAAJ,CAAU,sDAAV,CAAN;;;IAGFmO,KAAI,CAAC6M,OAAL,GAAeA,OAAf;;IAEA7M,KAAI,CAACjH,OAAL,GAAe6Y,KAAK,CAAC,EAAD,EAAK1c,eAAL,EAAsB6D,OAAtB,CAApB;;QAEMqZ,cAAc,GAAGpS,KAAI,CAACjH,OAA5B;QACMnC,QAAQ,GAAGwb,cAAc,CAACxb,QAAhC;;QAEIA,QAAQ,IAAI/B,yBAAhB,EAA2C;MACzCud,cAAc,CAACxb,QAAf,GAA0B/B,yBAAyB,CAAC+B,QAAD,CAAnD;;;IAEFoJ,KAAI,CAAC6J,KAAL;;;;;;;;;;;;;;cAQK,GAAP,UAAYjU,QAAZ;QACQmD,OAAO,GAAG,KAAKA,OAArB;QACM6H,QAAQ,GAAG,KAAKA,QAAtB;QACMQ,YAAY,GAAGR,QAAQ,CAACQ,YAA9B;QACMyE,YAAY,GAAGjF,QAAQ,CAACkF,eAAT,EAArB;QACMhB,UAAU,GAAG1D,YAAY,CAAC2D,QAAb,EAAnB;QACMsC,UAAU,GAAGjG,YAAY,CAAChB,aAAb,EAAnB;QACM3K,SAAS,GAAG2L,YAAY,CAAC2H,YAAb,EAAlB;QACMsJ,YAAY,GAAGtZ,OAAO,CAACxD,QAAR,GACjB,CADiB,GAEjBuP,UAAU,CAAC7R,GAFf;QAGIuV,SAAS,GAAG3C,YAAY,GAAG,CAA/B;;QAEI2C,SAAS,GAAG6J,YAAhB,EAA8B;MAC5B7J,SAAS,GAAG,KAAKzP,OAAL,CAAazD,QAAb,IAAyB+R,UAAU,GAAG,CAAtC,GACRtO,OAAO,CAACxD,QAAR,GACEE,SADF,GAEEqP,UAAU,CAAC5R,GAHL,GAIR,CAAC,CAJL;;;WAOK,KAAK+P,MAAL,CAAYuF,SAAZ,EAAuB5S,QAAvB,CAAP;GArBK;;;;;;;;;cA8BA,GAAP,UAAYA,QAAZ;QACQmD,OAAO,GAAG,KAAKA,OAArB;QACM6H,QAAQ,GAAG,KAAKA,QAAtB;QACMQ,YAAY,GAAGR,QAAQ,CAACQ,YAA9B;QACMyE,YAAY,GAAGjF,QAAQ,CAACkF,eAAT,EAArB;QACMhB,UAAU,GAAG1D,YAAY,CAAC2D,QAAb,EAAnB;QACMsC,UAAU,GAAGjG,YAAY,CAAChB,aAAb,EAAnB;QACM3K,SAAS,GAAG2L,YAAY,CAAC2H,YAAb,EAAlB;QACMuJ,YAAY,GAAGvZ,OAAO,CAACxD,QAAR,GACjBE,SADiB,GAEjBqP,UAAU,CAAC5R,GAFf;QAGI8V,SAAS,GAAGnD,YAAY,GAAG,CAA/B;;QAEImD,SAAS,GAAGsJ,YAAhB,EAA8B;MAC5BtJ,SAAS,GAAGjQ,OAAO,CAACzD,QAAR,IAAoB+R,UAAU,GAAG,CAAjC,GACRtO,OAAO,CAACxD,QAAR,GACE,CADF,GAEEuP,UAAU,CAAC7R,GAHL,GAIR,CAAC,CAJL;;;WAOK,KAAKgQ,MAAL,CAAY+F,SAAZ,EAAuBpT,QAAvB,CAAP;GArBK;;;;;;;;;;gBA+BA,GAAP,UAAckD,KAAd,EAA6BlD,QAA7B;QACQgL,QAAQ,GAAG,KAAKA,QAAtB;QACM5G,KAAK,GAAG4G,QAAQ,CAACQ,YAAT,CAAsB2E,GAAtB,CAA0BjN,KAA1B,CAAd;QACMI,KAAK,GAAG0H,QAAQ,CAACqG,YAAT,CAAsB6C,QAAtB,EAAd;;QAEI,CAAC9P,KAAD,IAAUd,KAAK,CAACnE,IAAN,KAAeqD,UAAU,CAACC,IAAxC,EAA8C;aACrC,IAAP;;;QAGI6P,cAAc,GAAGlO,KAAK,CAAC0K,iBAAN,EAAvB;QACMJ,cAAc,GAAG1D,QAAQ,CAAC2D,iBAAT,EAAvB;QAEI5H,MAAM,GAAG,CAAb;;QACI,KAAK5D,OAAL,CAAazD,QAAjB,EAA2B;UACnBsP,cAAc,GAAGhE,QAAQ,CAACiE,iBAAT,EAAvB,CADyB;;UAGnB0N,iBAAiB,GAAG,CACxBrK,cAAc,GAAGtD,cADO,EAExBsD,cAFwB,EAGxBA,cAAc,GAAGtD,cAHO,CAA1B;UAKM4N,eAAe,GAAGD,iBAAiB,CAAC9W,MAAlB,CAAyB,UAACoQ,OAAD,EAAU4G,OAAV;eACvCtf,IAAI,CAACgP,GAAL,CAASsQ,OAAO,GAAGnO,cAAnB,IAAqCnR,IAAI,CAACgP,GAAL,CAAS0J,OAAO,GAAGvH,cAAnB,CAAtC,GACHmO,OADG,GAEH5G,OAFJ;OADsB,EAIrBnW,QAJqB,CAAxB;MAMAiH,MAAM,GAAG6V,eAAe,GAAGtK,cAA3B;;;QAEIrC,YAAY,GAAG,KAAKhK,QAAL,EAArB;;QAEIyI,cAAc,KAAK4D,cAAc,GAAGvL,MAApC,IAA8CkJ,YAAY,KAAK/M,KAAnE,EAA0E;aACjE,IAAP;;;QAGIuL,SAAS,GAAGrK,KAAK,CAAC6B,QAAN,OAAqB+E,QAAQ,CAACkF,eAAT,EAArB,GACd1O,MAAM,CAACU,IADO,GAEdV,MAAM,CAACM,MAFX;IAIAkJ,QAAQ,CAACqC,MAAT,CACEjJ,KADF,EAEEqK,SAFF,EAGE,IAHF,EAIE1H,MAJF,EAKE/G,QALF;WAOO,IAAP;GA9CK;;;;;;;;kBAsDA,GAAP;WACS,KAAKgL,QAAL,CAAckF,eAAd,EAAP;GADK;;;;;;;;oBASA,GAAP;WACS,KAAK+G,OAAZ;GADK;;;;;;;;yBASA,GAAP;QACQjM,QAAQ,GAAG,KAAKA,QAAtB;QACM5G,KAAK,GAAG4G,QAAQ,CAACuC,eAAT,EAAd;WACOnJ,KAAK,GACR4G,QAAQ,CAACa,mBAAT,CAA6BzH,KAA7B,CADQ,GAER,IAFJ;GAHK;;;;;;;;kBAaA,GAAP,UAAgBlB,KAAhB;QACQ8H,QAAQ,GAAG,KAAKA,QAAtB;QACM5G,KAAK,GAAG4G,QAAQ,CAACQ,YAAT,CAAsB2E,GAAtB,CAA0BjN,KAA1B,CAAd;WACOkB,KAAK,GACR4G,QAAQ,CAACa,mBAAT,CAA6BzH,KAA7B,CADQ,GAER,IAFJ;GAHK;;;;;;;;;sBAaA,GAAP,UAAoB0Y,YAApB;QACQ9R,QAAQ,GAAG,KAAKA,QAAtB;QACMQ,YAAY,GAAGR,QAAQ,CAACQ,YAA9B;QACM7F,MAAM,GAAGmX,YAAY,GACvBtR,YAAY,CAACvD,SAAb,EADuB,GAEvBuD,YAAY,CAAC9C,cAAb,EAFJ;WAIO/C,MAAM,CACVQ,MADI,CACG,UAAA/B,KAAA;aAAS,CAAC,CAACA,KAAF;KADZ,EAEJgF,GAFI,CAEA,UAAAhF,KAAA;aAAS4G,QAAQ,CAACa,mBAAT,CAA6BzH,KAA7B,CAAA;KAFT,CAAP;GAPK;;;;;;;;0BAgBA,GAAP;WACS,KAAK2Y,YAAL,CAAkB,IAAlB,EAAwB5W,MAAxB,CAA+B,UAAA/B,KAAA;UAC9B0N,cAAc,GAAG1N,KAAK,CAACyN,iBAAN,EAAvB;aAEOC,cAAc,GAAG,CAAC,CAAlB,IAAuBA,cAAc,GAAG,CAA/C;KAHK,CAAP;GADK;;;;;;;;uBAYA,GAAP;WACS,KAAK9G,QAAL,CAAcQ,YAAd,CAA2BhB,aAA3B,EAAP;GADK;;;;;;;;;sBAUA,GAAP,UAAoBtH,KAApB;SACO8H,QAAL,CAAc+M,YAAd,CAA2B7U,KAA3B;GADK;;;;;;;;mBASA,GAAP;WACS,KAAK8H,QAAL,CAAcqG,YAAd,CAA2B6C,QAA3B,GAAsC0F,OAA7C;GADK;;;;;;;;qBASA,GAAP;SACO5O,QAAL,CAAcsL,MAAd;WAEO,IAAP;GAHK;;;;;;;;sBAWA,GAAP;SACOtL,QAAL,CAAcuL,OAAd;WAEO,IAAP;GAHK;;;;;;;;mBAWA,GAAP;QACQvL,QAAQ,GAAG,KAAKA,QAAtB;QAEMrF,MAAM,GAAGqF,QAAQ,CAACQ,YAAT,CAAsB9C,cAAtB,GACZvC,MADY,CACL,UAAA/B,KAAA;aAAS,CAAC,CAACA,KAAF;KADJ,EAEZgF,GAFY,CAER,UAAAhF,KAAA;aACI;QACLiT,IAAI,EAAEjT,KAAK,CAACsC,UAAN,GAAmBsW,SADpB;QAEL9Z,KAAK,EAAEkB,KAAK,CAAC6B,QAAN;OAFT;KAHW,CAAf;WASO;MACL/C,KAAK,EAAE8H,QAAQ,CAACkF,eAAT,EADF;MAELvK,MAAM,QAFD;MAGLzE,QAAQ,EAAE8J,QAAQ,CAACG,iBAAT;KAHZ;GAZK;;;;;;;;mBAwBA,GAAP,UAAiBgM,MAAjB;SACOnM,QAAL,CAAciS,OAAd,CAAsB9F,MAAtB;GADK;;;;;;;;;oBAUA,GAAP,UAAkB+F,OAAlB;oBAAA;;QACQC,UAAU,GAAI,GAAgBrV,MAAhB,CAAuBoV,OAAvB,CAApB;IAEAC,UAAU,CAACjjB,OAAX,CAAmB,UAAAkjB,MAAA;MACjBA,MAAM,CAACC,IAAP,CAAYjT,KAAZ;KADF;SAIK8S,OAAL,GAAe,KAAKA,OAAL,CAAapV,MAAb,CAAoBqV,UAApB,CAAf;WACO,IAAP;GARK;;;;;;;;;uBAgBA,GAAP,UAAqBD,OAArB;oBAAA;;QACQI,cAAc,GAAG,KAAKJ,OAA5B;QACMK,cAAc,GAAI,GAAgBzV,MAAhB,CAAuBoV,OAAvB,CAAxB;IAEAK,cAAc,CAACrjB,OAAf,CAAuB,UAAAkjB,MAAA;UACfla,KAAK,GAAGoa,cAAc,CAACtgB,OAAf,CAAuBogB,MAAvB,CAAd;;UAEIla,KAAK,GAAG,CAAC,CAAb,EAAgB;QACdoa,cAAc,CAAC9X,MAAf,CAAsBtC,KAAtB,EAA6B,CAA7B;;;MAGFka,MAAM,CAAClG,OAAP,CAAe9M,KAAf;KAPF;WASO,IAAP;GAbK;;;;;;;;;;;iBAwBA,GAAP;oBAAA;;SACOuQ,GAAL;SAEK3P,QAAL,CAAckM,OAAd;SAEKgG,OAAL,CAAahjB,OAAb,CAAqB,UAAAkjB,MAAA;MACnBA,MAAM,CAAClG,OAAP,CAAe9M,KAAf;KADF;;SAKK,IAAMlK,CAAX,IAAgB,IAAhB,EAAsB;WACNA,CAAb,IAAkB,IAAlB;;GAXE;;;;;;;;gBAoBA,GAAP;QACQ8K,QAAQ,GAAG,KAAKA,QAAtB;IAEAA,QAAQ,CAACQ,YAAT,CAAsBvD,SAAtB,GACG/N,OADH,CACW,UAAAkK,KAAA;aAASA,KAAK,CAACoZ,KAAN,EAAA;KADpB;IAEAxS,QAAQ,CAAC3G,MAAT;WAEO,IAAP;GAPK;;;;;;;;;;;;;;;iBAsBA,GAAP,UAAe7J,OAAf;QACQwQ,QAAQ,GAAG,KAAKA,QAAtB;QACMsI,cAAc,GAAGC,YAAY,CAAC/Y,OAAD,CAAnC;QAEMiP,cAAc,GAAGlM,IAAI,CAACD,GAAL,CAAS0N,QAAQ,CAACQ,YAAT,CAAsB2D,QAAtB,GAAiC9R,GAAjC,GAAuCiW,cAAc,CAAC1W,MAA/D,EAAuE,CAAvE,CAAvB;WACOoO,QAAQ,CAACyI,MAAT,CAAgBhK,cAAhB,EAAgC6J,cAAhC,CAAP;GALK;;;;;;;;;;;;;;;;;gBAsBA,GAAP,UAAc9Y,OAAd;QACQwQ,QAAQ,GAAG,KAAKA,QAAtB;WAEOA,QAAQ,CAACyI,MAAT,CAAgBzI,QAAQ,CAACQ,YAAT,CAAsB2D,QAAtB,GAAiC7R,GAAjC,GAAuC,CAAvD,EAA0D9C,OAA1D,CAAP;GAHK;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBA+BA,GAAP,UAAe0I,KAAf,EAA8B1I,OAA9B;WACS,KAAKwQ,QAAL,CAAc/N,OAAd,CAAsBiG,KAAtB,EAA6B1I,OAA7B,CAAP;GADK;;;;;;;;;;gBAWA,GAAP,UAAc0I,KAAd,EAA6BwE,WAA7B;8BAA6B,EAAA;MAAAA,eAAA;;;WACpB,KAAKsD,QAAL,CAAcvF,MAAd,CAAqBvC,KAArB,EAA4BwE,WAA5B,CAAP;GADK;;eAIC,GAAR;SACO+V,YAAL;SACKC,WAAL;SACKC,YAAL;GAHM;;sBAMA,GAAR;QACQ1G,OAAO,GAAG,KAAKA,OAArB;QACM9T,OAAO,GAAG,KAAKA,OAArB;QACMuC,aAAa,GAAG3K,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAtB;;;IAIAG,OAAO,CAAC8b,OAAO,CAAC7b,QAAT,CAAP,CAA0BlB,OAA1B,CAAkC,UAAA0jB,KAAA;MAChClY,aAAa,CAACmB,WAAd,CAA0B+W,KAA1B;KADF;;QAKMzM,eAAe,GAAGpW,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAxB;IACAmW,eAAe,CAACtK,WAAhB,CAA4BnB,aAA5B;;IAGAuR,OAAO,CAACpQ,WAAR,CAAoBsK,eAApB;;SAGKnG,QAAL,GAAgB,IAAI6S,QAAJ,CAAa,IAAb,EAAmB1M,eAAnB,EAAoCzL,aAApC,EAAmDvC,OAAnD,EAA4D,KAAKmH,YAAjE,CAAhB;GAnBM;;qBAsBA,GAAR;QACQD,QAAQ,GAAG,IAAjB;QACMW,QAAQ,GAAGX,QAAQ,CAACW,QAA1B;QACMqG,YAAY,GAAGrG,QAAQ,CAACqG,YAA9B;;IAGAhH,QAAQ,CAACyT,YAAT,GAAwB;MACtBzT,QAAQ,UADc;MAEtBW,QAAQ,EAAEX,QAAQ,CAACW,QAFG;MAGtBT,SAAS,EAAE8G,YAAY,CAAC9G,SAHF;MAItBD,YAAY,EAAED,QAAQ,CAACC,YAJD;MAKtB0B,UAAU,EAAE3B,QAAQ,CAAC2B,UALC;MAMtBC,UAAU,EAAEjB,QAAQ,CAACiB;KANvB;QASM+L,QAAQ,GAAG,EAAjB;;4BACW1d;UACHmU,SAAS,GAAGtM,WAAW,CAAC7H,GAAD,CAA7B;;MAEA0d,QAAQ,CAACvJ,SAAD,CAAR,GAAsB,UAACxE,CAAD;eAAYoH,YAAY,CAAC0M,IAAb,CAAkBtP,SAAlB,EAA6BxE,CAA7B,EAAgCI,QAAQ,CAACyT,YAAzC,CAAA;OAAlC;;;SAHG,IAAMxjB,GAAX,IAAkB6H,WAAlB;cAAW7H;;;;IAOX+P,QAAQ,CAACW,QAAT,CAAkBgT,kBAAlB,CAAqChG,QAArC;GAvBM;;sBA0BA,GAAR;oBAAA;;QACM,KAAK7U,OAAL,CAAa3C,UAAjB,EAA6B;MAC3BpE,MAAM,CAAC6hB,gBAAP,CAAwB,QAAxB,EAAkC;QAChC7T,KAAI,CAAC/F,MAAL;OADF;;GAFI;;;;;;;;;;EA/iBM6Z,gBAAA,GAAkB,sBAAlB;;;;;;;;;EAQAA,kBAAA,GAAuBpb,SAAvB;;;;;;EAMAob,eAAA,GAAoB1c,MAApB;iBAkoBhB;EAxpBuB2c,UAAvB;;;;"}