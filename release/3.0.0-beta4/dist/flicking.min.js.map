{"version":3,"file":"flicking.min.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/Viewport.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/Flicking.ts"],"sourcesContent":["export function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\n\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n","import { FlickingOptions, EventType, Direction, AxesEventType, StateType } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  snap: 1,\n  freeScroll: false,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NONE: \"\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","import { OriginalStyle } from \"../types\";\nimport { DEFAULT_PANEL_CSS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression } from \"../utils\";\n\nclass Panel {\n  private prevPanel: Panel | null;\n  private nextPanel: Panel | null;\n\n  private element: HTMLElement;\n  private state: {\n    index: number;\n    horizontal: boolean,\n    position: number;\n    anchorExpression: string;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    clonedPanels: Panel[];\n    cachedBbox: ClientRect | null;\n  };\n  private original?: Panel;\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    options: {\n      horizontal: boolean,\n      anchorExpression: string,\n      classPrefix?: string,\n    },\n  ) {\n    this.element = element;\n\n    this.state = {\n      index,\n      horizontal: options.horizontal,\n      position: 0,\n      anchorExpression: options.anchorExpression,\n      relativeAnchorPosition: 0,\n      size: 0,\n      clonedPanels: [],\n      isClone: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: element.getAttribute(\"class\") || null,\n        style: element.getAttribute(\"style\") || null,\n      },\n      cachedBbox: null,\n    };\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n    this.resize();\n  }\n\n  public resize(): void {\n    const state = this.state;\n\n    // Removed cached bbox, as we're resizing\n    state.cachedBbox = null;\n\n    const bbox = this.getBbox();\n\n    state.size = state.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    if (!state.isClone) {\n      state.clonedPanels.forEach(panel => panel.resize());\n    }\n  }\n\n  public destroy(): void {\n    const el = this.element;\n    const originalStyle = this.state.originalStyle;\n\n    originalStyle.className\n      ? el.setAttribute(\"class\", originalStyle.className)\n      : el.removeAttribute(\"class\");\n    originalStyle.style\n      ? el.setAttribute(\"style\", originalStyle.style)\n      : el.removeAttribute(\"style\");\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getPrevPanel(): Panel | null {\n    return this.prevPanel;\n  }\n\n  public getNextPanel(): Panel | null {\n    return this.nextPanel;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    return this.state.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...state.clonedPanels];\n  }\n\n  public setPosition(pos: number) {\n    const state = this.state;\n    const elementStyle = this.element.style;\n\n    state.position = pos;\n    state.horizontal\n      ? elementStyle.left = `${pos}px`\n      : elementStyle.top = `${pos}px`;\n    state.relativeAnchorPosition = parseArithmeticExpression(state.anchorExpression, state.size);\n  }\n\n  public setPrevPanel(panel: Panel | null): void {\n    this.prevPanel = panel;\n  }\n\n  public setNextPanel(panel: Panel | null): void {\n    this.nextPanel = panel;\n  }\n\n  public clone(cloneIndex: number): Panel {\n    const state = this.state;\n\n    const cloneElement = this.element.cloneNode(true) as HTMLElement;\n    const clonedPanel = new Panel(cloneElement, state.index, {\n      anchorExpression: state.anchorExpression,\n      horizontal: state.horizontal,\n    });\n\n    clonedPanel.original = this;\n    clonedPanel.state.isClone = true;\n    clonedPanel.state.cloneIndex = cloneIndex;\n    // Can't calc size as it didn't appended to other element yet\n    // So manually set size for it\n    clonedPanel.state.size = state.size;\n    state.clonedPanels.push(clonedPanel);\n\n    return clonedPanel;\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const removedPanels = this.state.clonedPanels.splice(start);\n\n    for (const panel of removedPanels) {\n      const element = panel.getElement();\n      element.parentNode!.removeChild(element);\n    }\n  }\n}\n\nexport default Panel;\n","import Panel from \"./Panel\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray } from \"../utils\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS } from \"../consts\";\nimport Axes, { PanInput } from \"@egjs/axes\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus } from \"../types\";\n\nexport default class Viewport {\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private panels: Panel[];\n  private clonedPanels: Panel[] = [];\n\n  private axesHandlers: {[key: string]: any};\n\n  private state: {\n    index: number;\n    size: number;\n    position: number;\n    hangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n  };\n  private options: FlickingOptions;\n\n  constructor(\n    viewportElement: HTMLElement,\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n\n    this.state = {\n      index: options.defaultIndex,\n      size: 0,\n      position: 0,\n      hangerPosition: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n    };\n    this.options = options;\n\n    this.build();\n  }\n\n  public moveTo(panel: FlickingPanel, axesEvent: any, duration: number = this.options.duration): void {\n    const state = this.state;\n    const freeScroll = this.options.freeScroll;\n    let targetPos = panel.anchorPosition - state.hangerPosition;\n\n    targetPos = this.canSetBoundMode()\n      ? clamp(targetPos, state.scrollArea.prev, state.scrollArea.next)\n      : targetPos;\n\n    state.index = panel.index;\n    // freeScroll only occurs in release events\n    (axesEvent && axesEvent.setTo)\n      ? axesEvent.setTo({ flick: freeScroll ? axesEvent.destPos.flick : targetPos }, duration)\n      : this.axes.setTo({ flick: targetPos }, duration);\n  }\n\n  public moveCamera(pos: number): void {\n    const state = this.state;\n\n    const transform = state.translate.name;\n    const moveVector = this.options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n\n    // Update position\n    state.position = pos;\n  }\n\n  public resize(): void {\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n\n    // Clone panels in circular mode\n    if (this.options.circular) {\n      this.clonePanels();\n      this.relocatePanels();\n    }\n\n    this.chainPanels();\n    this.updateCameraPosition();\n  }\n\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n    const scrollArea = state.scrollArea;\n    const currentHangerPosition = state.position + state.hangerPosition;\n\n    if (this.isOutOfBound()) {\n      return state.position < scrollArea.prev\n        ? panels[0]\n        : panels[panels.length - 1];\n    }\n\n    const allPanels = [...panels, ...clonedPanels];\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel;\n\n    for (const panel of allPanels) {\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(currentHangerPosition, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - currentHangerPosition),\n          Math.abs(nextPosition - currentHangerPosition),\n        );\n\n      if (distance > minimumDistance) {\n        break;\n      }\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel!;\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    for (const panel of [...this.panels, ...this.clonedPanels]) {\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    const state = this.state;\n\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = state.position + state.hangerPosition;\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const distance = Math.abs(state.position + state.hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.hangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.hangerPosition\n        : anchorPosition > state.position + state.hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.hangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.hangerPosition + scrollAreaSize;\n    }\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public updateAdaptiveSize(): void {\n    const options = this.options;\n    const horizontal = options.horizontal;\n    let sizeToApply: number;\n\n    if (options.adaptive) {\n      const currentPanel = this.getCurrentPanel();\n      const panelBbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panels.reduce((maximum, panel) => {\n        const panelBbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const viewportElement = this.viewportElement;\n    const wrapper = viewportElement.parentElement;\n\n    wrapper!.removeChild(viewportElement);\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    this.panels.forEach(panel => {\n      wrapper!.appendChild(panel.getElement());\n      panel.destroy();\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const cameraElement = this.cameraElement;\n\n    // Replace all panels inside camera element\n    cameraElement.innerHTML = panels.map(panel => panel.html).join(\"\");\n    this.viewportElement.appendChild(cameraElement);\n\n    // Resotre index & resize\n    this.state.index = status.index;\n    this.moveCamera(status.position);\n\n    this.panels = [];\n    this.clonedPanels = [];\n\n    this.createPanels();\n    this.resize();\n  }\n\n  public getPanelCount(): number {\n    return this.panels.length;\n  }\n\n  public getPanel(index: number): Panel | null {\n    if (!isBetween(index, 0, this.panels.length - 1)) {\n      return null;\n    }\n\n    return this.panels[index];\n  }\n\n  public getCurrentPanel(): Panel {\n    return this.panels[this.state.index];\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPrevIndex(): number {\n    const state = this.state;\n    let index = state.index - 1;\n\n    if (index < 0) {\n      index = this.options.circular\n        ? this.panels.length - 1\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getNextIndex(): number {\n    const state = this.state;\n    let index = state.index + 1;\n\n    if (index >= this.panels.length) {\n      index = this.options.circular\n        ? 0\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.hangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n  public getAllPanels(includeClone?: boolean): Panel[] {\n    const panels = this.panels;\n\n    return includeClone ? panels.concat(this.clonedPanels) : panels;\n  }\n  public connectAxesHandler(handler: {[key: string]: (event: { [key: string]: any; }) => any}): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handler;\n    axes.on(handler);\n    this.resume();\n  }\n\n  public pause(): void {\n    this.axes.off();\n  }\n\n  public resume(): void {\n    this.axes.on(this.axesHandlers);\n  }\n\n  private build(): void {\n    this.applyCSSValue();\n    this.setAxesInstance();\n    this.createPanels();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const classPrefix = options.classPrefix;\n\n    // Set default css values for each element\n    viewportElement.className = `${classPrefix}-viewport`;\n    cameraElement.className = `${classPrefix}-camera`;\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = this.makeNewPanInput();\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private createPanels(): void {\n    const state = this.state;\n    const options = this.options;\n\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n    if (!panelElements || !panelElements.length) {\n      throw new Error(\"There're no panel elements.\");\n    }\n\n    // Initialize panels\n    this.panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, {\n        horizontal: options.horizontal,\n        classPrefix: options.classPrefix,\n        anchorExpression: options.anchor,\n      }),\n    );\n\n    // Clamp default index\n    state.index = clamp(state.index, 0, this.panels.length - 1);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n\n    const viewportSize = state.size;\n    const lastPanel = panels[panels.length - 1];\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() + this.options.gap;\n    const visibleAreaSize = viewportSize + panels[0].getRelativeAnchorPosition();\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const lastClonedPanel = clonedPanels[clonedPanels.length - 1];\n    const cloneCount = Math.ceil(visibleAreaSize / sumOriginalPanelSize);\n    const prevCloneCount = lastClonedPanel ? lastClonedPanel.getCloneIndex() + 1 : 0;\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        panels.forEach(origPanel => {\n          const clonedPanel = origPanel.clone(cloneIndex);\n          this.appendPanelElement(clonedPanel.getElement());\n\n          clonedPanels.push(clonedPanel);\n        });\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panels.forEach(panel => {\n        panel.removeClonedPanelsAfter(cloneCount);\n      });\n      this.clonedPanels.splice(cloneCount * panels.length);\n    }\n  }\n\n  private relocatePanels(): void {\n    const state = this.state;\n    const options = this.options;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n    const scrollArea = state.scrollArea;\n    const maximumNextVisiblePosition = scrollArea.next + state.size;\n    const minimumPrevVisiblePosition = scrollArea.prev;\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      const origPanel = panel.getIdenticalPanels()[0];\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (panelPosition <= maximumNextVisiblePosition) {\n        // It's visible in current scrollArea\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private chainPanels(): void {\n    const allPanels = [...this.panels, ...this.clonedPanels];\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanels.length - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.setPrevPanel(prevPanel);\n      panel.setNextPanel(nextPanel);\n    });\n\n    if (this.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanels.length - 1];\n\n      firstPanel.setPrevPanel(lastPanel);\n      lastPanel.setNextPanel(firstPanel);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n\n    const defaultIndex = clamp(this.options.defaultIndex, 0, this.panels.length -  1);\n    const defaultPanel = this.panels[defaultIndex];\n    let defaultPosition = defaultPanel.getAnchorPosition() - state.hangerPosition;\n\n    defaultPosition = this.canSetBoundMode()\n      ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n      : defaultPosition;\n\n    state.index = defaultIndex;\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private isOutOfBound(): boolean {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n\n    return !this.options.circular\n      && (state.position < scrollArea.prev || state.position > scrollArea.next);\n  }\n\n  private canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const panels = this.panels;\n\n    const lastPanel = panels[panels.length - 1];\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n      viewportElement.style.minWidth = \"\";\n    }\n\n    const bbox = viewportElement.getBoundingClientRect();\n\n    // update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.hangerPosition = parseArithmeticExpression(options.hanger, state.size);\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panels = this.panels;\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = 0;\n    panels.forEach(panel => {\n      panel.resize();\n\n      const panelPos = nextPanelPos;\n      const panelSize = panel.getSize();\n\n      panel.setPosition(panelPos);\n      nextPanelPos += panelSize + gap;\n    });\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panels = this.panels;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const hangerPos = state.hangerPosition;\n\n    if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - hangerPos,\n        next: sumOriginalPanelSize + firstPanel.getRelativeAnchorPosition() - hangerPos,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - hangerPos,\n        next: lastPanel.getAnchorPosition() - hangerPos,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    axes.axis.flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    axes.axis.flick.bounce = parsedBounce;\n  }\n\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const panels = this.panels;\n    const axes = this.axes;\n\n    let newPosition = panels[state.index].getAnchorPosition() - state.hangerPosition;\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    this.moveCamera(newPosition);\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    this.pause();\n    axes.setTo({\n      flick: newPosition,\n    }, 0);\n    this.resume();\n  }\n\n  private makeNewPanInput(): PanInput {\n    const options = this.options;\n\n    return new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n  }\n\n  private appendPanelElement(element: HTMLElement): void {\n    this.cameraElement.appendChild(element);\n  }\n}\n","import { ValueOf, Direction, StateType, FlickingContext, FlickingPanel } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: FlickingPanel | null = null;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n  }\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","import State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n  }\n\n  public onHold(e: any, { triggerEvent, transitTo }: FlickingContext): void {\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext, SelectEvent } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // Which means at least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't be handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo, castToReadonlyPanel }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const clickedElement = releaseEvent.inputEvent.srcEvent.target;\n    const clickedPanel = viewport.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        selectedIndex: clickedPanel.getIndex(),\n        selectedPanel: castToReadonlyPanel(clickedPanel),\n      } as SelectEvent);\n    }\n  }\n}\n\nexport default HoldingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext, StateType, ValueOf } from \"../types\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onEnter(prevState: State): void {\n    super.onEnter(prevState);\n    this.delta = 0;\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, moveToPanel, castToReadonlyPanel, transitTo, stopCamera } = context;\n    const delta = this.delta;\n    const options = flicking.options;\n    const isNext = delta > 0;\n    const swipeDistance = Math.abs(delta);\n    const swipeAngle = e.inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(e.inputEvent.deltaY / e.inputEvent.deltaX) / Math.PI)\n      : 90;\n    const overThreshold = (swipeDistance >= options.threshold)\n      && (options.horizontal\n        ? swipeAngle <= options.thresholdAngle\n        : swipeAngle > options.thresholdAngle);\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (!overThreshold && this.targetPanel) {\n      // Interrupted while animating\n      viewport.moveTo(this.targetPanel, e);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n    const halfGap = options.gap / 2;\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n    * |  Prev  |     Next     |\n    * |--------|--------------|\n    * [][      |<-Anchor    ][] <- Panel + Gap\n    */\n    let minimumDistanceToChange = isNext\n      ? currentPanel.getSize() - currentPanel.getRelativeAnchorPosition() + halfGap\n      : currentPanel.getRelativeAnchorPosition() + halfGap;\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    const flick = Math.abs(e.delta.flick);\n    const freeScroll = options.freeScroll;\n    const snap = freeScroll ? Infinity : options.snap;\n    const durationOption = options.duration;\n    let duration: number | undefined;\n    let panelToMove = castToReadonlyPanel(freeScroll ? viewport.findNearestPanel() : currentPanel);\n\n    if (freeScroll || overThreshold) {\n      let count = 0;\n\n      if (freeScroll || minimumDistanceToChange <= flick) {\n        const position = panelToMove.position;\n\n        while (Math.abs(panelToMove.position - position) < flick && count < snap) {\n          const nextPanel = isNext ? panelToMove.next() : panelToMove.prev();\n\n          if (!nextPanel) {\n            break;\n          }\n          panelToMove = nextPanel;\n          ++count;\n        }\n        if (freeScroll) {\n          duration = e.duration;\n        } else if (count > 1) {\n          duration = Math.min(durationOption * count, Math.max(e.duration, durationOption));\n        }\n      }\n      if (!freeScroll && count <= 1) {\n        if (swipeDistance <= minimumDistanceToChange) {\n          let adjacentPanel = isNext\n            ? currentPanel.getNextPanel()\n            : currentPanel.getPrevPanel();\n\n          if (options.circular) {\n            const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n            const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n              > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n            if (lapped) {\n              adjacentPanel = isNext\n                ? firstClonedPanel.getNextPanel()\n                : firstClonedPanel.getPrevPanel();\n            }\n          }\n          panelToMove = castToReadonlyPanel((adjacentPanel != null) ? adjacentPanel : currentPanel);\n        } else {\n          panelToMove = castToReadonlyPanel(viewport.findNearestPanel());\n        }\n      }\n    } else if (options.circular) {\n      // Restore case\n      const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n      const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n      if (!isNext && lapped) {\n        panelToMove = castToReadonlyPanel(firstClonedPanel);\n      }\n    }\n\n    const eventType = (!overThreshold || panelToMove.position === currentPanel.getPosition())\n      ? (freeScroll ? EVENTS.NONE : EVENTS.RESTORE)\n      : EVENTS.CHANGE;\n\n    moveToPanel(panelToMove, eventType, e, duration)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.ANIMATING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n        stopCamera(e);\n      });\n  }\n}\n\nexport default DraggingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { triggerEvent, transitTo }: FlickingContext): void {\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted);\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n}\n\nexport default AnimatingState;\n","import State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","import State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","import Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\nimport Panel from \"./components/Panel\";\nimport StateMachine from \"./components/StateMachine\";\n\nimport { merge, getProgress } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE } from \"./consts\";\nimport { FlickingOptions, FlickingEvent, Direction, EventType, ChangeEvent, FlickingPanel, TriggerCallback, FlickingContext, FlickingStatus, Plugin } from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"9+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n * @throws {Error} An Error occur when given base element doesn't exist or it hasn't proper DOM structure to be initialized. <ko>주어진 기본 요소가 존재하지 않거나 초기화 할 적절한 DOM 구조가없는 경우 오류가 발생한다.</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event types\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private stateMachine: StateMachine;\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n  private plugins: Plugin[] = [];\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix for class names of the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation where acceleration is manually enabled by user. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for infinite scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되여 무한 스크롤이 가능하다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to destination panel(unit: pixel). A panel element must be dragged beyond the threshold to move to the destination panel.<ko>목적 패널로의 이동 임계값 (단위: 픽셀). 패널 요소를 임계값 이상으로 끌어다 놓아야만이 목적 패널로 이동한다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] The easing function to apply to a panel moving animation. The default function is easeOutCubic.<ko>패널 이동 애니메이션에 적용할 `easing`함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing the module. A zero-based integer.<ko>모듈 초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput Reference})<br>- \"touch\": A touch input device.<br>- \"mouse\": A mouse.<ko>입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput 참고})<br>- \"touch\": 터치 입력 장치.<br>- \"mouse\": 마우스.</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold value that determines whether user input is horizontal or vertical. (0 ~ 90)<ko>사용자의 입력이 가로 방향인지 세로 방향인지 판단하는 기준 각도 (0 ~ 90)</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {Boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element<ko>뷰포트 요소의 z-index 값</ko>\n   * @param {boolean} [options.bound=false] Prevents view going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Position of hanger in viewport, which hangs panel anchors.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space between each panels.<br>Should be given in number(px).<ko>패널간에 부여할 간격의 크기를 나타내는 숫자(px)</ko>\n   * @param {number} [options.snap=1] The number of panels you're going to roll over to when you snap<ko>한 번 스냅 할 때 최대 몇 개의 패널까지 넘길 건지 나타내는 숫자</ko>\n   * @param {boolean} [options.freeScroll=false] If true, panels can scroll freely when flicked.<ko>활성화 했을 때 플릭한 경우에 패널들을 자유롭게 스크롤할 수 있다.</ko>\n   */\n  constructor(\n    element: HTMLElement | string,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (typeof element === \"string\") {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n\n    this.build(options);\n  }\n  /**\n   * Move to the previous panel. If `horizontal=true`is left panel. If `horizontal=false`is upper panel.\n   * @ko 이전 패널로 이동한다. `horizontal=true`이면 좌측 패널. `horizontal=false`이면 상측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public prev(duration?: number): this {\n    return this.moveTo(this.viewport.getPrevIndex(), duration);\n  }\n\n  /**\n   * Move to the next panel. If `horizontal=true`is right panel. If `horizontal=false`is lower panel.\n   * @ko 다음 패널로 이동한다. `horizontal=true`이면 우측 패널. `horizontal=false`이면 하측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public next(duration?: number): this {\n    return this.moveTo(this.viewport.getNextIndex(), duration);\n  }\n\n  /**\n   * Moves to the panel in the order specified in `index`. If `index` is equal to selected panel's index, no action is taken.\n   * @ko `index`에 지정한 순서의 패널로 이동한다. `index`값이 현재 선택된 패널의 인덱스와 동일하다면, 아무 동작도 하지 않는다.\n   * @param index The index number of the panel to be moved.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getPanel(index);\n    const state = this.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n    const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n    const anchorPosition = panel.getAnchorPosition();\n\n    if (hangerPosition === anchorPosition) {\n      return this;\n    }\n    const panelIndex = panel.getIndex();\n    const currentIndex = viewport.getIndex();\n    const nearestPanel = this.castToReadonlyPanel(viewport.findNearestIdenticalPanel(panel));\n\n    this.moveToPanel(nearestPanel, panelIndex === currentIndex ? EVENTS.NONE : EVENTS.CHANGE, null, duration);\n    return this;\n  }\n\n  /**\n   * Returns the index number of the selected panel.\n   * @ko 현재 선택된 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the current panel element.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getIndex();\n  }\n\n  /**\n   * Returns the index number of the previous panel.\n   * @ko 현재 선택된 패널의 이전 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the previous panel.<br>When `circular` option is `false`, return -1 if selected panel is first panel.<ko>이전 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 첫번째 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getPrevIndex(): number {\n    return this.viewport.getPrevIndex();\n  }\n\n  /**\n   * Returns the index number of the next panel.\n   * @ko 현재 선택된 패널의 다음 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the next panel.<br>When `circular` option is `false`, return -1 if selected panel is last panel.<ko>다음 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 마지막 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getNextIndex(): number {\n    return this.viewport.getNextIndex();\n  }\n\n  /**\n   * Returns the selected panel object\n   * @ko 현재 선택된 패널의 오브젝트를 반환한다.\n   * @return Selected panel object.<ko>선택된 패널 오브젝트</ko>\n   */\n  public getCurrentPanel(): FlickingPanel {\n    return this.castToReadonlyPanel(this.viewport.getCurrentPanel());\n  }\n\n  /**\n   * Returns the panel object of given index\n   * @ko 주어진 인덱스에 해당하는 패널의 오브젝트를 반환한다.\n   * @return panel object of given index, `null` if it doesn't exists.<ko>주어진 인덱스에 해당하는 패널의 오브젝트, 해당 패널이 존재하지 않을 시 `null`.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const panel = this.viewport.getPanel(index);\n    return panel\n      ? this.castToReadonlyPanel(panel)\n      : null;\n  }\n  /**\n   * Returns all panel objects in flicking.\n   * @ko 플리킹 안에 있는 모든 패널 오브젝트들을 반환한다.\n   * @param - Check whether to include clone or not <ko>복사본을 포함할 건지 안 할 건지 확인한다</ko>\n   * @return All panel objects <ko>플리킹 안에 있는 모든 패널 오브젝트들</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    return this.viewport.getAllPanels(includeClone).map(panel => this.castToReadonlyPanel(panel));\n  }\n  /**\n   * Returns the panel objects shown in the flicking area.\n   * @ko 플리킹 영역에서 보여지는 패널 오브젝트들을 반환한다.\n   * @return The panel objects shown in the flicking area. <ko>플리킹 영역에서 보여지는 패널 오브젝트들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.getAllPanels(true).filter(({outsetProgress}) => {\n      return outsetProgress > -1 && outsetProgress < 1;\n    });\n  }\n  /**\n   * Returns the total length of original panels\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.getPanelCount();\n  }\n\n  /**\n   * Checks whether the animated panel is playing.\n   * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n   * @return Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n   */\n  public isPlaying(): boolean {\n    return this.stateMachine.getState().playing;\n  }\n\n  /**\n   * The input from the input device is not blocked so that the panel can be moved by the input device.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return  An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * The input from the input device is blocked so that the panel is not moved by the input device.\n   * @ko 패널이 입력 장치에 의해 움직이지 않도록 입력 장치로부터의 입력을 막는다.\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n /**\n  * Get current flicking status. If the returned value is specified as a [setStatus()]{@link eg.Flicking#setStatus} method argument, it can be returned to its value status.\n  * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메서드 인자로 지정하면 그 값 상태로 되돌릴 수 있다.\n  * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n  */\n  public getStatus(): Readonly<FlickingStatus> {\n    const panels = this.viewport.getAllPanels().map(panel => {\n      return {\n        html: panel.getElement().outerHTML,\n        index: panel.getIndex(),\n      };\n    });\n\n    return {\n      index: this.getIndex(),\n      panels,\n      position: this.viewport.getCameraPosition(),\n    };\n  }\n\n /**\n  * Restore to the state of the `status`.\n  * @ko `status`의 상태로 복원한다.\n  * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n  */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add <ko>추가할 플러그인(들)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n  /**\n   * Remove plugins from Flicking\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove <ko>제거 플러그인(들)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      index > -1 && currentPlugins.splice(index, 1);\n\n      plugin.destroy(this);\n    });\n    return this;\n  }\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    this.plugins.forEach(plugin => {\n      plugin.destroy(this);\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * The horizontal or vertical length of the panel is updated according to the base element. If `horizontal=true` is horizontal. If `horizontal=false` is vertical.\n   * @ko 패널의 가로 혹은 세로 길이를 기준요소에 맞춰 갱신한다. `horizontal=true`이면 가로, `horizontal=false`이면 세로.\n   * @return An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n  public resize(): this {\n    this.viewport.resize();\n\n    return this;\n  }\n\n  private build(options: Partial<FlickingOptions>): void {\n    this.setInitialState(options);\n    this.initViewport();\n    this.listenInput();\n    this.listenResize();\n  }\n\n  private setInitialState(options: Partial<FlickingOptions>): void {\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Set internal state machine\n    this.stateMachine = new StateMachine();\n  }\n\n  private initViewport(): void {\n    const wrapper = this.wrapper;\n    const options = this.options;\n    const children = wrapper.children;\n    if (!children || !children.length) {\n      // FIXME: INFINITE FLICKING 구현시 삭제할 것\n      throw new Error(\"Given base element doesn't have proper DOM structure to be initialized.\");\n    }\n\n    const cameraElement = document.createElement(\"div\");\n\n    // Make all panels to be a child of camera element\n    // wrapper <- viewport <- camera <- panels[1...n]\n    let firstChild = wrapper.firstChild;\n    while (firstChild) {\n      cameraElement.appendChild(firstChild);\n      firstChild = wrapper.firstChild;\n    }\n\n    // Clipping area for camera element\n    const viewportElement = document.createElement(\"div\");\n    viewportElement.appendChild(cameraElement);\n\n    // Add viewport element to wrapper\n    wrapper.appendChild(viewportElement);\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(viewportElement, cameraElement, options);\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const stateMachine = flicking.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: flicking.stopCamera,\n      moveToPanel: flicking.moveToPanel,\n      castToReadonlyPanel: flicking.castToReadonlyPanel,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", () => {\n        this.resize();\n      });\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = this.stateMachine.getState();\n    const currentPanel = viewport.getCurrentPanel();\n    const {prev, next} = viewport.getScrollArea();\n    const pos = viewport.getCameraPosition();\n    let progress = getProgress(pos, [prev, prev, next]);\n\n    if (this.options.circular) {\n        progress %= 1;\n    }\n    const canceled = !super.trigger(eventName, merge({\n      type: eventName,\n      index: currentPanel.getIndex(),\n      panel: this.castToReadonlyPanel(currentPanel),\n      direction: state.direction,\n      holding: state.holding,\n      progress,\n      axesEvent,\n      isTrusted,\n    }, params));\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = this.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNext = inputOffset < 0;\n      const prevPos = viewport.getCameraPosition();\n\n      let cameraChange = pos - prevPos;\n      const looped = isNext === (pos < prevPos);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = -Math.sign(cameraChange) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.delta += cameraChange;\n      state.direction = currentDirection;\n    }\n\n    const previousPosition = viewport.getCameraPosition();\n\n    viewport.moveCamera(pos);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted).onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition);\n      });\n  }\n\n  private stopCamera = (axesEvent: any): void => {\n    const viewport = this.viewport;\n\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: viewport.getCameraPosition() }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  private moveToPanel = (panel: FlickingPanel, eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | EventType[\"NONE\"], axesEvent: any, duration: number = this.options.duration): TriggerCallback => {\n    const viewport = this.viewport;\n    const stateMachine = this.stateMachine;\n    const currentPanel = viewport.getCurrentPanel();\n\n    const estimatedPosition = panel.anchorPosition - viewport.getHangerPosition();\n    const currentPosition = viewport.getCameraPosition();\n\n    const isTrusted = axesEvent !== null;\n    const direction = estimatedPosition > currentPosition\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.index,\n        panel,\n        direction,\n        prevIndex: currentPanel.getIndex(),\n        prevPanel: this.castToReadonlyPanel(currentPanel),\n      } as ChangeEvent);\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(callback: () => void): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      const state = stateMachine.getState();\n\n      state.targetPanel = panel;\n      state.direction = direction;\n      viewport.moveTo(panel, axesEvent, duration);\n    });\n\n    // Move end event can't be triggered automatically when duration is 0\n    // as Axes won't trigger animationEnd or finish event\n    // so manually trigger finish event\n    if (duration <= 0) {\n      stateMachine.fire(AXES_EVENTS.FINISH, null, this.eventContext);\n    }\n\n    return eventResult;\n  }\n\n  private castToReadonlyPanel = (panel: Panel, position = panel.getPosition()): FlickingPanel => {\n    const flicking = this;\n    const isCircular = this.options.circular;\n    const viewport = this.viewport;\n    const size = panel.getSize();\n    const relativeAnchorPosition = panel.getRelativeAnchorPosition();\n    const cameraPosition = viewport.getCameraPosition();\n    const realtiveHangerPosition = viewport.getHangerPosition();\n    const cameraDist = cameraPosition + realtiveHangerPosition;\n    const nearestPanel = this.viewport.findNearestPanel();\n    const isOnNext = nearestPanel.getAnchorPosition() > cameraDist || !nearestPanel.getNextPanel();\n    // if isOnNext is true, find the previous panel of the nearest panel.\n    const prevPanel = (isOnNext ? nearestPanel.getPrevPanel() : nearestPanel) || nearestPanel;\n    const nextPanel = (isOnNext ? nearestPanel : nearestPanel.getNextPanel()) || nearestPanel;\n    const scrollSize = viewport.getScrollAreaSize();\n    const viewportSize = viewport.getSize();\n    let prevAnchorPosition = prevPanel.getAnchorPosition();\n    let nextAnchorPosition = nextPanel.getAnchorPosition();\n\n    if (prevAnchorPosition > nextAnchorPosition) {\n      // last to first or first to last\n      if (cameraDist > prevAnchorPosition) {\n        nextAnchorPosition += scrollSize;\n      } else {\n        prevAnchorPosition -= scrollSize;\n      }\n    }\n    const range = [\n      prevAnchorPosition,\n      prevAnchorPosition,\n      nextAnchorPosition,\n    ];\n    const outsetRange = [\n      -size,\n      realtiveHangerPosition - relativeAnchorPosition,\n      viewportSize,\n    ];\n\n    // single\n    const panelCount = this.getPanelCount();\n    const prevCloneIndex = prevPanel.getCloneIndex();\n    const relativeIndex = (isCircular ? Math.floor(position / scrollSize) * panelCount : 0) + panel.getIndex();\n    const progress = relativeIndex - getProgress(cameraDist, range) - (prevPanel.getIndex() + (prevCloneIndex + 1) * panelCount);\n\n    // outset\n    const relativePanelPosition = position - cameraPosition;\n    const outsetProgress = getProgress(relativePanelPosition, outsetRange);\n\n    // visibleRatio\n    const rightRelativePanelPosition = relativePanelPosition + size;\n    const visibleSize = Math.min(viewportSize, rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    const visibleRatio = visibleSize >= 0 ? visibleSize / size : 0;\n\n    return {\n      element: panel.getElement(),\n      index: panel.getIndex(),\n      position,\n      progress,\n      outsetProgress,\n      visibleRatio,\n      anchorPosition: position + panel.getRelativeAnchorPosition(),\n      size: panel.getSize(),\n      focus(this: FlickingPanel, duration?: number): void {\n        const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n        const anchorPosition = panel.getAnchorPosition();\n        if (hangerPosition === anchorPosition) {\n          return;\n        }\n\n        const currentPosition = viewport.getCurrentPanel().getPosition();\n        flicking.moveToPanel(this, currentPosition === position ? EVENTS.NONE : EVENTS.CHANGE, null, duration);\n      },\n      update(this: FlickingPanel, updateFunction: (element: HTMLElement) => any): void {\n        panel.getIdenticalPanels()\n          .forEach(eachPanel => updateFunction(eachPanel.getElement()));\n      },\n      prev(this: FlickingPanel): FlickingPanel | null {\n        const originalPrevPanel = panel.getPrevPanel();\n        if (originalPrevPanel == null) {\n          return null;\n        }\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        let newPosition = originalPrevPanel.getPosition();\n\n        while (position  < newPosition) {\n            newPosition -= scrollAreaSize;\n        }\n        return flicking.castToReadonlyPanel(originalPrevPanel, newPosition);\n      },\n      next(this: FlickingPanel): FlickingPanel | null {\n        const originalNextPanel = panel.getNextPanel();\n        if (originalNextPanel == null) {\n          return null;\n        }\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        let newPosition = originalNextPanel.getPosition();\n\n        while (position  > newPosition) {\n          newPosition += scrollAreaSize;\n        }\n        return flicking.castToReadonlyPanel(originalNextPanel, newPosition);\n      },\n    };\n  }\n}\n\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","document","documentElement","style","transformName","prefixedTransform","Error","el","createElement","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","element","cssObj","property","val","min","max","Math","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","snap","freeScroll","DEFAULT_VIEWPORT_CSS","position","width","height","willChange","DEFAULT_CAMERA_CSS","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NONE","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","DIRECTION","PREV","NEXT","TRANSFORM","index","options","className","state","anchorExpression","relativeAnchorPosition","size","clonedPanels","isClone","cloneIndex","originalStyle","getAttribute","cachedBbox","classList","add","indexOf","replace","applyCSS","this","resize","bbox","getBbox","panel","setAttribute","removeAttribute","prevPanel","nextPanel","getBoundingClientRect","original","getIdenticalPanels","elementStyle","left","top","parseArithmeticExpression","clonedPanel","Panel","cloneNode","push","start","removedPanels_1","splice","getElement","parentNode","viewportElement","cameraElement","hangerPosition","scrollArea","prev","next","translate","build","axesEvent","targetPos","anchorPosition","canSetBoundMode","setTo","flick","destPos","axes","moveCoord","map","coord","round","join","updateSize","updateOriginalPanelPositions","updateAdaptiveSize","updateScrollArea","clonePanels","relocatePanels","chainPanels","updateCameraPosition","panels","currentHangerPosition","isOutOfBound","nearestPanel","minimumDistance","Infinity","allPanels_1","prevPosition","getPosition","nextPosition","getSize","distance","isBetween","abs","_a","contains","nearest","shortestDistance","identical","getAnchorPosition","scrollAreaSize","panInput","enable","disable","sizeToApply","panelBbox","getCurrentPanel","reduce","maximum","viewportStyle","minHeight","minWidth","wrapper","destroy","appendChild","status","innerHTML","html","moveCamera","createPanels","includeClone","concat","handler","axesHandlers","on","resume","off","applyCSSValue","setAxesInstance","moveToDefaultPanel","Axes","easing","interruptable","makeNewPanInput","connect","iterable","panelElements","children","slice","call","viewportSize","lastPanel","sumOriginalPanelSize","visibleAreaSize","getRelativeAnchorPosition","lastClonedPanel","cloneCount","ceil","prevCloneCount","getCloneIndex","origPanel","clone","_this","appendPanelElement","removeClonedPanelsAfter","maximumNextVisiblePosition","firstPanel","clonedPanels_1","clonedPanelPos","setPosition","lastReplacePosition","_b","reverse","panelPosition","replacePosition","allPanels","setPrevPanel","setNextPanel","defaultPosition","summedPanelSize","nextPanelPos","panelPos","panelSize","hangerPos","arr","parsedBounce","constructor","Array","parsedVal","axis","newPosition","pause","PanInput","scale","prevState","delta","direction","targetPanel","nextState","e","context","tslib_1","triggerEvent","transitTo","onSuccess","onStopped","onChange","State","flicking","offset","inputEvent","offsetX","offsetY","viewport","getCameraPosition","releaseEvent","castToReadonlyPanel","clickedElement","srcEvent","clickedPanel","findPanelOf","cameraPosition","clickedPanelPosition","selectedIndex","getIndex","selectedPanel","_super","onEnter","moveToPanel","stopCamera","isNext","swipeDistance","swipeAngle","deltaX","atan","deltaY","PI","overThreshold","moveTo","currentPanel","getHangerPosition","halfGap","minimumDistanceToChange","durationOption","panelToMove","findNearestPanel","count","adjacentPanel","getNextPanel","getPrevPanel","firstClonedPanel","lapped","isTrusted","IdleState","nextStateType","currentState","type","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","eventType","onHold","onRelease","onAnimationEnd","onFinish","eventName","params","stateMachine","getState","progress","getProgress","canceled","trigger","merge","holding","callback","prevPos","cameraChange","looped","getScrollAreaSize","currentDirection","previousPosition","eventResult","estimatedPosition","currentPosition","prevIndex","fire","eventContext","isCircular","realtiveHangerPosition","cameraDist","isOnNext","scrollSize","prevAnchorPosition","nextAnchorPosition","outsetRange","panelCount","getPanelCount","prevCloneIndex","floor","relativePanelPosition","outsetProgress","rightRelativePanelPosition","visibleSize","visibleRatio","focus","update","updateFunction","eachPanel","originalPrevPanel","originalNextPanel","querySelector","nodeName","nodeType","getPrevIndex","getNextIndex","getPanel","panelIndex","currentIndex","findNearestIdenticalPanel","getAllPanels","filter","playing","outerHTML","restore","plugins","newPlugins","plugin","init","currentPlugins","setInitialState","initViewport","listenInput","listenResize","StateMachine","firstChild","Viewport","handlers","connectAxesHandler","addEventListener","Flicking","Component"],"mappings":"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"}