{"version":3,"file":"flicking.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/Viewport.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/Flicking.ts"],"sourcesContent":["export function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\n\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n","import { FlickingOptions, EventType, Direction, AxesEventType, StateType } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  snap: 1,\n  freeScroll: false,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NONE: \"\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","import { OriginalStyle } from \"../types\";\nimport { DEFAULT_PANEL_CSS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression } from \"../utils\";\n\nclass Panel {\n  private prevPanel: Panel | null;\n  private nextPanel: Panel | null;\n\n  private element: HTMLElement;\n  private state: {\n    index: number;\n    horizontal: boolean,\n    position: number;\n    anchorExpression: string;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    clonedPanels: Panel[];\n    cachedBbox: ClientRect | null;\n  };\n  private original?: Panel;\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    options: {\n      horizontal: boolean,\n      anchorExpression: string,\n      classPrefix?: string,\n    },\n  ) {\n    this.element = element;\n\n    this.state = {\n      index,\n      horizontal: options.horizontal,\n      position: 0,\n      anchorExpression: options.anchorExpression,\n      relativeAnchorPosition: 0,\n      size: 0,\n      clonedPanels: [],\n      isClone: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: element.getAttribute(\"class\") || null,\n        style: element.getAttribute(\"style\") || null,\n      },\n      cachedBbox: null,\n    };\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n    this.resize();\n  }\n\n  public resize(): void {\n    const state = this.state;\n\n    // Removed cached bbox, as we're resizing\n    state.cachedBbox = null;\n\n    const bbox = this.getBbox();\n\n    state.size = state.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    if (!state.isClone) {\n      state.clonedPanels.forEach(panel => panel.resize());\n    }\n  }\n\n  public destroy(): void {\n    const el = this.element;\n    const originalStyle = this.state.originalStyle;\n\n    originalStyle.className\n      ? el.setAttribute(\"class\", originalStyle.className)\n      : el.removeAttribute(\"class\");\n    originalStyle.style\n      ? el.setAttribute(\"style\", originalStyle.style)\n      : el.removeAttribute(\"style\");\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getPrevPanel(): Panel | null {\n    return this.prevPanel;\n  }\n\n  public getNextPanel(): Panel | null {\n    return this.nextPanel;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    return this.state.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...state.clonedPanels];\n  }\n\n  public setPosition(pos: number) {\n    const state = this.state;\n    const elementStyle = this.element.style;\n\n    state.position = pos;\n    state.horizontal\n      ? elementStyle.left = `${pos}px`\n      : elementStyle.top = `${pos}px`;\n    state.relativeAnchorPosition = parseArithmeticExpression(state.anchorExpression, state.size);\n  }\n\n  public setPrevPanel(panel: Panel | null): void {\n    this.prevPanel = panel;\n  }\n\n  public setNextPanel(panel: Panel | null): void {\n    this.nextPanel = panel;\n  }\n\n  public clone(cloneIndex: number): Panel {\n    const state = this.state;\n\n    const cloneElement = this.element.cloneNode(true) as HTMLElement;\n    const clonedPanel = new Panel(cloneElement, state.index, {\n      anchorExpression: state.anchorExpression,\n      horizontal: state.horizontal,\n    });\n\n    clonedPanel.original = this;\n    clonedPanel.state.isClone = true;\n    clonedPanel.state.cloneIndex = cloneIndex;\n    // Can't calc size as it didn't appended to other element yet\n    // So manually set size for it\n    clonedPanel.state.size = state.size;\n    state.clonedPanels.push(clonedPanel);\n\n    return clonedPanel;\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const removedPanels = this.state.clonedPanels.splice(start);\n\n    for (const panel of removedPanels) {\n      const element = panel.getElement();\n      element.parentNode!.removeChild(element);\n    }\n  }\n}\n\nexport default Panel;\n","import Panel from \"./Panel\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray } from \"../utils\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS } from \"../consts\";\nimport Axes, { PanInput } from \"@egjs/axes\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus } from \"../types\";\n\nexport default class Viewport {\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private panels: Panel[];\n  private clonedPanels: Panel[] = [];\n\n  private axesHandlers: {[key: string]: any};\n\n  private state: {\n    index: number;\n    size: number;\n    position: number;\n    hangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n  };\n  private options: FlickingOptions;\n\n  constructor(\n    viewportElement: HTMLElement,\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n\n    this.state = {\n      index: options.defaultIndex,\n      size: 0,\n      position: 0,\n      hangerPosition: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n    };\n    this.options = options;\n\n    this.build();\n  }\n\n  public moveTo(panel: FlickingPanel, axesEvent: any, duration: number = this.options.duration): void {\n    const state = this.state;\n    const freeScroll = this.options.freeScroll;\n    let targetPos = panel.anchorPosition - state.hangerPosition;\n\n    targetPos = this.canSetBoundMode()\n      ? clamp(targetPos, state.scrollArea.prev, state.scrollArea.next)\n      : targetPos;\n\n    state.index = panel.index;\n    // freeScroll only occurs in release events\n    (axesEvent && axesEvent.setTo)\n      ? axesEvent.setTo({ flick: freeScroll ? axesEvent.destPos.flick : targetPos }, duration)\n      : this.axes.setTo({ flick: targetPos }, duration);\n  }\n\n  public moveCamera(pos: number): void {\n    const state = this.state;\n\n    const transform = state.translate.name;\n    const moveVector = this.options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n\n    // Update position\n    state.position = pos;\n  }\n\n  public resize(): void {\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n\n    // Clone panels in circular mode\n    if (this.options.circular) {\n      this.clonePanels();\n      this.relocatePanels();\n    }\n\n    this.chainPanels();\n    this.updateCameraPosition();\n  }\n\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n    const scrollArea = state.scrollArea;\n    const currentHangerPosition = state.position + state.hangerPosition;\n\n    if (this.isOutOfBound()) {\n      return state.position < scrollArea.prev\n        ? panels[0]\n        : panels[panels.length - 1];\n    }\n\n    const allPanels = [...panels, ...clonedPanels];\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel;\n\n    for (const panel of allPanels) {\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(currentHangerPosition, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - currentHangerPosition),\n          Math.abs(nextPosition - currentHangerPosition),\n        );\n\n      if (distance > minimumDistance) {\n        break;\n      }\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel!;\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    for (const panel of [...this.panels, ...this.clonedPanels]) {\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    const state = this.state;\n\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = state.position + state.hangerPosition;\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const distance = Math.abs(state.position + state.hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.hangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.hangerPosition\n        : anchorPosition > state.position + state.hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.hangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.hangerPosition + scrollAreaSize;\n    }\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public updateAdaptiveSize(): void {\n    const options = this.options;\n    const horizontal = options.horizontal;\n    let sizeToApply: number;\n\n    if (options.adaptive) {\n      const currentPanel = this.getCurrentPanel();\n      const panelBbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panels.reduce((maximum, panel) => {\n        const panelBbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const viewportElement = this.viewportElement;\n    const wrapper = viewportElement.parentElement;\n\n    wrapper!.removeChild(viewportElement);\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    this.panels.forEach(panel => {\n      wrapper!.appendChild(panel.getElement());\n      panel.destroy();\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const cameraElement = this.cameraElement;\n\n    // Replace all panels inside camera element\n    cameraElement.innerHTML = panels.map(panel => panel.html).join(\"\");\n    this.viewportElement.appendChild(cameraElement);\n\n    // Resotre index & resize\n    this.state.index = status.index;\n    this.moveCamera(status.position);\n\n    this.panels = [];\n    this.clonedPanels = [];\n\n    this.createPanels();\n    this.resize();\n  }\n\n  public getPanelCount(): number {\n    return this.panels.length;\n  }\n\n  public getPanel(index: number): Panel | null {\n    if (!isBetween(index, 0, this.panels.length - 1)) {\n      return null;\n    }\n\n    return this.panels[index];\n  }\n\n  public getCurrentPanel(): Panel {\n    return this.panels[this.state.index];\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPrevIndex(): number {\n    const state = this.state;\n    let index = state.index - 1;\n\n    if (index < 0) {\n      index = this.options.circular\n        ? this.panels.length - 1\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getNextIndex(): number {\n    const state = this.state;\n    let index = state.index + 1;\n\n    if (index >= this.panels.length) {\n      index = this.options.circular\n        ? 0\n        : -1;\n    }\n\n    return index;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.hangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n  public getAllPanels(includeClone?: boolean): Panel[] {\n    const panels = this.panels;\n\n    return includeClone ? panels.concat(this.clonedPanels) : panels;\n  }\n  public connectAxesHandler(handler: {[key: string]: (event: { [key: string]: any; }) => any}): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handler;\n    axes.on(handler);\n    this.resume();\n  }\n\n  public pause(): void {\n    this.axes.off();\n  }\n\n  public resume(): void {\n    this.axes.on(this.axesHandlers);\n  }\n\n  private build(): void {\n    this.applyCSSValue();\n    this.setAxesInstance();\n    this.createPanels();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const classPrefix = options.classPrefix;\n\n    // Set default css values for each element\n    viewportElement.className = `${classPrefix}-viewport`;\n    cameraElement.className = `${classPrefix}-camera`;\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = this.makeNewPanInput();\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private createPanels(): void {\n    const state = this.state;\n    const options = this.options;\n\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n    if (!panelElements || !panelElements.length) {\n      throw new Error(\"There're no panel elements.\");\n    }\n\n    // Initialize panels\n    this.panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, {\n        horizontal: options.horizontal,\n        classPrefix: options.classPrefix,\n        anchorExpression: options.anchor,\n      }),\n    );\n\n    // Clamp default index\n    state.index = clamp(state.index, 0, this.panels.length - 1);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n\n    const viewportSize = state.size;\n    const lastPanel = panels[panels.length - 1];\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() + this.options.gap;\n    const visibleAreaSize = viewportSize + panels[0].getRelativeAnchorPosition();\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const lastClonedPanel = clonedPanels[clonedPanels.length - 1];\n    const cloneCount = Math.ceil(visibleAreaSize / sumOriginalPanelSize);\n    const prevCloneCount = lastClonedPanel ? lastClonedPanel.getCloneIndex() + 1 : 0;\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        panels.forEach(origPanel => {\n          const clonedPanel = origPanel.clone(cloneIndex);\n          this.appendPanelElement(clonedPanel.getElement());\n\n          clonedPanels.push(clonedPanel);\n        });\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panels.forEach(panel => {\n        panel.removeClonedPanelsAfter(cloneCount);\n      });\n      this.clonedPanels.splice(cloneCount * panels.length);\n    }\n  }\n\n  private relocatePanels(): void {\n    const state = this.state;\n    const options = this.options;\n    const panels = this.panels;\n    const clonedPanels = this.clonedPanels;\n    const scrollArea = state.scrollArea;\n    const maximumNextVisiblePosition = scrollArea.next + state.size;\n    const minimumPrevVisiblePosition = scrollArea.prev;\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      const origPanel = panel.getIdenticalPanels()[0];\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (panelPosition <= maximumNextVisiblePosition) {\n        // It's visible in current scrollArea\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private chainPanels(): void {\n    const allPanels = [...this.panels, ...this.clonedPanels];\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanels.length - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.setPrevPanel(prevPanel);\n      panel.setNextPanel(nextPanel);\n    });\n\n    if (this.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanels.length - 1];\n\n      firstPanel.setPrevPanel(lastPanel);\n      lastPanel.setNextPanel(firstPanel);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n\n    const defaultIndex = clamp(this.options.defaultIndex, 0, this.panels.length -  1);\n    const defaultPanel = this.panels[defaultIndex];\n    let defaultPosition = defaultPanel.getAnchorPosition() - state.hangerPosition;\n\n    defaultPosition = this.canSetBoundMode()\n      ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n      : defaultPosition;\n\n    state.index = defaultIndex;\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private isOutOfBound(): boolean {\n    const state = this.state;\n    const scrollArea = state.scrollArea;\n\n    return !this.options.circular\n      && (state.position < scrollArea.prev || state.position > scrollArea.next);\n  }\n\n  private canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const panels = this.panels;\n\n    const lastPanel = panels[panels.length - 1];\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n      viewportElement.style.minWidth = \"\";\n    }\n\n    const bbox = viewportElement.getBoundingClientRect();\n\n    // update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.hangerPosition = parseArithmeticExpression(options.hanger, state.size);\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panels = this.panels;\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = 0;\n    panels.forEach(panel => {\n      panel.resize();\n\n      const panelPos = nextPanelPos;\n      const panelSize = panel.getSize();\n\n      panel.setPosition(panelPos);\n      nextPanelPos += panelSize + gap;\n    });\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panels = this.panels;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const hangerPos = state.hangerPosition;\n\n    if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - hangerPos,\n        next: sumOriginalPanelSize + firstPanel.getRelativeAnchorPosition() - hangerPos,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - hangerPos,\n        next: lastPanel.getAnchorPosition() - hangerPos,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    axes.axis.flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    axes.axis.flick.bounce = parsedBounce;\n  }\n\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const panels = this.panels;\n    const axes = this.axes;\n\n    let newPosition = panels[state.index].getAnchorPosition() - state.hangerPosition;\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    this.moveCamera(newPosition);\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    this.pause();\n    axes.setTo({\n      flick: newPosition,\n    }, 0);\n    this.resume();\n  }\n\n  private makeNewPanInput(): PanInput {\n    const options = this.options;\n\n    return new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n  }\n\n  private appendPanelElement(element: HTMLElement): void {\n    this.cameraElement.appendChild(element);\n  }\n}\n","import { ValueOf, Direction, StateType, FlickingContext, FlickingPanel } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: FlickingPanel | null = null;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n  }\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","import State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n  }\n\n  public onHold(e: any, { triggerEvent, transitTo }: FlickingContext): void {\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext, SelectEvent } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // Which means at least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't be handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo, castToReadonlyPanel }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const clickedElement = releaseEvent.inputEvent.srcEvent.target;\n    const clickedPanel = viewport.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        selectedIndex: clickedPanel.getIndex(),\n        selectedPanel: castToReadonlyPanel(clickedPanel),\n      } as SelectEvent);\n    }\n  }\n}\n\nexport default HoldingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext, StateType, ValueOf } from \"../types\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onEnter(prevState: State): void {\n    super.onEnter(prevState);\n    this.delta = 0;\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, moveToPanel, castToReadonlyPanel, transitTo, stopCamera } = context;\n    const delta = this.delta;\n    const options = flicking.options;\n    const isNext = delta > 0;\n    const swipeDistance = Math.abs(delta);\n    const swipeAngle = e.inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(e.inputEvent.deltaY / e.inputEvent.deltaX) / Math.PI)\n      : 90;\n    const overThreshold = (swipeDistance >= options.threshold)\n      && (options.horizontal\n        ? swipeAngle <= options.thresholdAngle\n        : swipeAngle > options.thresholdAngle);\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (!overThreshold && this.targetPanel) {\n      // Interrupted while animating\n      viewport.moveTo(this.targetPanel, e);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n    const halfGap = options.gap / 2;\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n    * |  Prev  |     Next     |\n    * |--------|--------------|\n    * [][      |<-Anchor    ][] <- Panel + Gap\n    */\n    let minimumDistanceToChange = isNext\n      ? currentPanel.getSize() - currentPanel.getRelativeAnchorPosition() + halfGap\n      : currentPanel.getRelativeAnchorPosition() + halfGap;\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    const flick = Math.abs(e.delta.flick);\n    const freeScroll = options.freeScroll;\n    const snap = freeScroll ? Infinity : options.snap;\n    const durationOption = options.duration;\n    let duration: number | undefined;\n    let panelToMove = castToReadonlyPanel(freeScroll ? viewport.findNearestPanel() : currentPanel);\n\n    if (freeScroll || overThreshold) {\n      let count = 0;\n\n      if (freeScroll || minimumDistanceToChange <= flick) {\n        const position = panelToMove.position;\n\n        while (Math.abs(panelToMove.position - position) < flick && count < snap) {\n          const nextPanel = isNext ? panelToMove.next() : panelToMove.prev();\n\n          if (!nextPanel) {\n            break;\n          }\n          panelToMove = nextPanel;\n          ++count;\n        }\n        if (freeScroll) {\n          duration = e.duration;\n        } else if (count > 1) {\n          duration = Math.min(durationOption * count, Math.max(e.duration, durationOption));\n        }\n      }\n      if (!freeScroll && count <= 1) {\n        if (swipeDistance <= minimumDistanceToChange) {\n          let adjacentPanel = isNext\n            ? currentPanel.getNextPanel()\n            : currentPanel.getPrevPanel();\n\n          if (options.circular) {\n            const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n            const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n              > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n            if (lapped) {\n              adjacentPanel = isNext\n                ? firstClonedPanel.getNextPanel()\n                : firstClonedPanel.getPrevPanel();\n            }\n          }\n          panelToMove = castToReadonlyPanel((adjacentPanel != null) ? adjacentPanel : currentPanel);\n        } else {\n          panelToMove = castToReadonlyPanel(viewport.findNearestPanel());\n        }\n      }\n    } else if (options.circular) {\n      // Restore case\n      const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n      const lapped = Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n      if (!isNext && lapped) {\n        panelToMove = castToReadonlyPanel(firstClonedPanel);\n      }\n    }\n\n    const eventType = (!overThreshold || panelToMove.position === currentPanel.getPosition())\n      ? (freeScroll ? EVENTS.NONE : EVENTS.RESTORE)\n      : EVENTS.CHANGE;\n\n    moveToPanel(panelToMove, eventType, e, duration)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.ANIMATING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n        stopCamera(e);\n      });\n  }\n}\n\nexport default DraggingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { triggerEvent, transitTo }: FlickingContext): void {\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted);\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n}\n\nexport default AnimatingState;\n","import State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","import State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","import Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\nimport Panel from \"./components/Panel\";\nimport StateMachine from \"./components/StateMachine\";\n\nimport { merge, getProgress } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE } from \"./consts\";\nimport { FlickingOptions, FlickingEvent, Direction, EventType, ChangeEvent, FlickingPanel, TriggerCallback, FlickingContext, FlickingStatus, Plugin } from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"9+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n * @throws {Error} An Error occur when given base element doesn't exist or it hasn't proper DOM structure to be initialized. <ko>주어진 기본 요소가 존재하지 않거나 초기화 할 적절한 DOM 구조가없는 경우 오류가 발생한다.</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event types\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private stateMachine: StateMachine;\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n  private plugins: Plugin[] = [];\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix for class names of the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation where acceleration is manually enabled by user. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for infinite scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되여 무한 스크롤이 가능하다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to destination panel(unit: pixel). A panel element must be dragged beyond the threshold to move to the destination panel.<ko>목적 패널로의 이동 임계값 (단위: 픽셀). 패널 요소를 임계값 이상으로 끌어다 놓아야만이 목적 패널로 이동한다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] The easing function to apply to a panel moving animation. The default function is easeOutCubic.<ko>패널 이동 애니메이션에 적용할 `easing`함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing the module. A zero-based integer.<ko>모듈 초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput Reference})<br>- \"touch\": A touch input device.<br>- \"mouse\": A mouse.<ko>입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput 참고})<br>- \"touch\": 터치 입력 장치.<br>- \"mouse\": 마우스.</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold value that determines whether user input is horizontal or vertical. (0 ~ 90)<ko>사용자의 입력이 가로 방향인지 세로 방향인지 판단하는 기준 각도 (0 ~ 90)</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {Boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element<ko>뷰포트 요소의 z-index 값</ko>\n   * @param {boolean} [options.bound=false] Prevents view going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Position of hanger in viewport, which hangs panel anchors.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space between each panels.<br>Should be given in number(px).<ko>패널간에 부여할 간격의 크기를 나타내는 숫자(px)</ko>\n   * @param {number} [options.snap=1] The number of panels you're going to roll over to when you snap<ko>한 번 스냅 할 때 최대 몇 개의 패널까지 넘길 건지 나타내는 숫자</ko>\n   * @param {boolean} [options.freeScroll=false] If true, panels can scroll freely when flicked.<ko>활성화 했을 때 플릭한 경우에 패널들을 자유롭게 스크롤할 수 있다.</ko>\n   */\n  constructor(\n    element: HTMLElement | string,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (typeof element === \"string\") {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n\n    this.build(options);\n  }\n  /**\n   * Move to the previous panel. If `horizontal=true`is left panel. If `horizontal=false`is upper panel.\n   * @ko 이전 패널로 이동한다. `horizontal=true`이면 좌측 패널. `horizontal=false`이면 상측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public prev(duration?: number): this {\n    return this.moveTo(this.viewport.getPrevIndex(), duration);\n  }\n\n  /**\n   * Move to the next panel. If `horizontal=true`is right panel. If `horizontal=false`is lower panel.\n   * @ko 다음 패널로 이동한다. `horizontal=true`이면 우측 패널. `horizontal=false`이면 하측 패널.\n   * @param [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public next(duration?: number): this {\n    return this.moveTo(this.viewport.getNextIndex(), duration);\n  }\n\n  /**\n   * Moves to the panel in the order specified in `index`. If `index` is equal to selected panel's index, no action is taken.\n   * @ko `index`에 지정한 순서의 패널로 이동한다. `index`값이 현재 선택된 패널의 인덱스와 동일하다면, 아무 동작도 하지 않는다.\n   * @param index The index number of the panel to be moved.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.getPanel(index);\n    const state = this.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n    const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n    const anchorPosition = panel.getAnchorPosition();\n\n    if (hangerPosition === anchorPosition) {\n      return this;\n    }\n    const panelIndex = panel.getIndex();\n    const currentIndex = viewport.getIndex();\n    const nearestPanel = this.castToReadonlyPanel(viewport.findNearestIdenticalPanel(panel));\n\n    this.moveToPanel(nearestPanel, panelIndex === currentIndex ? EVENTS.NONE : EVENTS.CHANGE, null, duration);\n    return this;\n  }\n\n  /**\n   * Returns the index number of the selected panel.\n   * @ko 현재 선택된 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the current panel element.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getIndex();\n  }\n\n  /**\n   * Returns the index number of the previous panel.\n   * @ko 현재 선택된 패널의 이전 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the previous panel.<br>When `circular` option is `false`, return -1 if selected panel is first panel.<ko>이전 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 첫번째 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getPrevIndex(): number {\n    return this.viewport.getPrevIndex();\n  }\n\n  /**\n   * Returns the index number of the next panel.\n   * @ko 현재 선택된 패널의 다음 패널의 인덱스 번호를 반환한다.\n   * @return Zero-based index number of the next panel.<br>When `circular` option is `false`, return -1 if selected panel is last panel.<ko>다음 패널 요소의 인덱스 번호. 0부터 시작하는 정수.<br>`circular`옵션이 `false`일 때 현재 선택된 패널이 마지막 패널이라면 `-1`을 반환한다.</ko>\n   */\n  public getNextIndex(): number {\n    return this.viewport.getNextIndex();\n  }\n\n  /**\n   * Returns the selected panel object\n   * @ko 현재 선택된 패널의 오브젝트를 반환한다.\n   * @return Selected panel object.<ko>선택된 패널 오브젝트</ko>\n   */\n  public getCurrentPanel(): FlickingPanel {\n    return this.castToReadonlyPanel(this.viewport.getCurrentPanel());\n  }\n\n  /**\n   * Returns the panel object of given index\n   * @ko 주어진 인덱스에 해당하는 패널의 오브젝트를 반환한다.\n   * @return panel object of given index, `null` if it doesn't exists.<ko>주어진 인덱스에 해당하는 패널의 오브젝트, 해당 패널이 존재하지 않을 시 `null`.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const panel = this.viewport.getPanel(index);\n    return panel\n      ? this.castToReadonlyPanel(panel)\n      : null;\n  }\n  /**\n   * Returns all panel objects in flicking.\n   * @ko 플리킹 안에 있는 모든 패널 오브젝트들을 반환한다.\n   * @param - Check whether to include clone or not <ko>복사본을 포함할 건지 안 할 건지 확인한다</ko>\n   * @return All panel objects <ko>플리킹 안에 있는 모든 패널 오브젝트들</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    return this.viewport.getAllPanels(includeClone).map(panel => this.castToReadonlyPanel(panel));\n  }\n  /**\n   * Returns the panel objects shown in the flicking area.\n   * @ko 플리킹 영역에서 보여지는 패널 오브젝트들을 반환한다.\n   * @return The panel objects shown in the flicking area. <ko>플리킹 영역에서 보여지는 패널 오브젝트들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.getAllPanels(true).filter(({outsetProgress}) => {\n      return outsetProgress > -1 && outsetProgress < 1;\n    });\n  }\n  /**\n   * Returns the total length of original panels\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.getPanelCount();\n  }\n\n  /**\n   * Checks whether the animated panel is playing.\n   * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n   * @return Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n   */\n  public isPlaying(): boolean {\n    return this.stateMachine.getState().playing;\n  }\n\n  /**\n   * The input from the input device is not blocked so that the panel can be moved by the input device.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return  An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * The input from the input device is blocked so that the panel is not moved by the input device.\n   * @ko 패널이 입력 장치에 의해 움직이지 않도록 입력 장치로부터의 입력을 막는다.\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n /**\n  * Get current flicking status. If the returned value is specified as a [setStatus()]{@link eg.Flicking#setStatus} method argument, it can be returned to its value status.\n  * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메서드 인자로 지정하면 그 값 상태로 되돌릴 수 있다.\n  * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n  */\n  public getStatus(): Readonly<FlickingStatus> {\n    const panels = this.viewport.getAllPanels().map(panel => {\n      return {\n        html: panel.getElement().outerHTML,\n        index: panel.getIndex(),\n      };\n    });\n\n    return {\n      index: this.getIndex(),\n      panels,\n      position: this.viewport.getCameraPosition(),\n    };\n  }\n\n /**\n  * Restore to the state of the `status`.\n  * @ko `status`의 상태로 복원한다.\n  * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n  */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add <ko>추가할 플러그인(들)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n  /**\n   * Remove plugins from Flicking\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove <ko>제거 플러그인(들)</ko>\n   * @return An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      index > -1 && currentPlugins.splice(index, 1);\n\n      plugin.destroy(this);\n    });\n    return this;\n  }\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    this.plugins.forEach(plugin => {\n      plugin.destroy(this);\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * The horizontal or vertical length of the panel is updated according to the base element. If `horizontal=true` is horizontal. If `horizontal=false` is vertical.\n   * @ko 패널의 가로 혹은 세로 길이를 기준요소에 맞춰 갱신한다. `horizontal=true`이면 가로, `horizontal=false`이면 세로.\n   * @return An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   */\n  public resize(): this {\n    this.viewport.resize();\n\n    return this;\n  }\n\n  private build(options: Partial<FlickingOptions>): void {\n    this.setInitialState(options);\n    this.initViewport();\n    this.listenInput();\n    this.listenResize();\n  }\n\n  private setInitialState(options: Partial<FlickingOptions>): void {\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Set internal state machine\n    this.stateMachine = new StateMachine();\n  }\n\n  private initViewport(): void {\n    const wrapper = this.wrapper;\n    const options = this.options;\n    const children = wrapper.children;\n    if (!children || !children.length) {\n      // FIXME: INFINITE FLICKING 구현시 삭제할 것\n      throw new Error(\"Given base element doesn't have proper DOM structure to be initialized.\");\n    }\n\n    const cameraElement = document.createElement(\"div\");\n\n    // Make all panels to be a child of camera element\n    // wrapper <- viewport <- camera <- panels[1...n]\n    let firstChild = wrapper.firstChild;\n    while (firstChild) {\n      cameraElement.appendChild(firstChild);\n      firstChild = wrapper.firstChild;\n    }\n\n    // Clipping area for camera element\n    const viewportElement = document.createElement(\"div\");\n    viewportElement.appendChild(cameraElement);\n\n    // Add viewport element to wrapper\n    wrapper.appendChild(viewportElement);\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(viewportElement, cameraElement, options);\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const stateMachine = flicking.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: flicking.stopCamera,\n      moveToPanel: flicking.moveToPanel,\n      castToReadonlyPanel: flicking.castToReadonlyPanel,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", () => {\n        this.resize();\n      });\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = this.stateMachine.getState();\n    const currentPanel = viewport.getCurrentPanel();\n    const {prev, next} = viewport.getScrollArea();\n    const pos = viewport.getCameraPosition();\n    let progress = getProgress(pos, [prev, prev, next]);\n\n    if (this.options.circular) {\n        progress %= 1;\n    }\n    const canceled = !super.trigger(eventName, merge({\n      type: eventName,\n      index: currentPanel.getIndex(),\n      panel: this.castToReadonlyPanel(currentPanel),\n      direction: state.direction,\n      holding: state.holding,\n      progress,\n      axesEvent,\n      isTrusted,\n    }, params));\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = this.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNext = inputOffset < 0;\n      const prevPos = viewport.getCameraPosition();\n\n      let cameraChange = pos - prevPos;\n      const looped = isNext === (pos < prevPos);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = -Math.sign(cameraChange) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.delta += cameraChange;\n      state.direction = currentDirection;\n    }\n\n    const previousPosition = viewport.getCameraPosition();\n\n    viewport.moveCamera(pos);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted).onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition);\n      });\n  }\n\n  private stopCamera = (axesEvent: any): void => {\n    const viewport = this.viewport;\n\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: viewport.getCameraPosition() }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  private moveToPanel = (panel: FlickingPanel, eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | EventType[\"NONE\"], axesEvent: any, duration: number = this.options.duration): TriggerCallback => {\n    const viewport = this.viewport;\n    const stateMachine = this.stateMachine;\n    const currentPanel = viewport.getCurrentPanel();\n\n    const estimatedPosition = panel.anchorPosition - viewport.getHangerPosition();\n    const currentPosition = viewport.getCameraPosition();\n\n    const isTrusted = axesEvent !== null;\n    const direction = estimatedPosition > currentPosition\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.index,\n        panel,\n        direction,\n        prevIndex: currentPanel.getIndex(),\n        prevPanel: this.castToReadonlyPanel(currentPanel),\n      } as ChangeEvent);\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(callback: () => void): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      const state = stateMachine.getState();\n\n      state.targetPanel = panel;\n      state.direction = direction;\n      viewport.moveTo(panel, axesEvent, duration);\n    });\n\n    // Move end event can't be triggered automatically when duration is 0\n    // as Axes won't trigger animationEnd or finish event\n    // so manually trigger finish event\n    if (duration <= 0) {\n      stateMachine.fire(AXES_EVENTS.FINISH, null, this.eventContext);\n    }\n\n    return eventResult;\n  }\n\n  private castToReadonlyPanel = (panel: Panel, position = panel.getPosition()): FlickingPanel => {\n    const flicking = this;\n    const isCircular = this.options.circular;\n    const viewport = this.viewport;\n    const size = panel.getSize();\n    const relativeAnchorPosition = panel.getRelativeAnchorPosition();\n    const cameraPosition = viewport.getCameraPosition();\n    const realtiveHangerPosition = viewport.getHangerPosition();\n    const cameraDist = cameraPosition + realtiveHangerPosition;\n    const nearestPanel = this.viewport.findNearestPanel();\n    const isOnNext = nearestPanel.getAnchorPosition() > cameraDist || !nearestPanel.getNextPanel();\n    // if isOnNext is true, find the previous panel of the nearest panel.\n    const prevPanel = (isOnNext ? nearestPanel.getPrevPanel() : nearestPanel) || nearestPanel;\n    const nextPanel = (isOnNext ? nearestPanel : nearestPanel.getNextPanel()) || nearestPanel;\n    const scrollSize = viewport.getScrollAreaSize();\n    const viewportSize = viewport.getSize();\n    let prevAnchorPosition = prevPanel.getAnchorPosition();\n    let nextAnchorPosition = nextPanel.getAnchorPosition();\n\n    if (prevAnchorPosition > nextAnchorPosition) {\n      // last to first or first to last\n      if (cameraDist > prevAnchorPosition) {\n        nextAnchorPosition += scrollSize;\n      } else {\n        prevAnchorPosition -= scrollSize;\n      }\n    }\n    const range = [\n      prevAnchorPosition,\n      prevAnchorPosition,\n      nextAnchorPosition,\n    ];\n    const outsetRange = [\n      -size,\n      realtiveHangerPosition - relativeAnchorPosition,\n      viewportSize,\n    ];\n\n    // single\n    const panelCount = this.getPanelCount();\n    const prevCloneIndex = prevPanel.getCloneIndex();\n    const relativeIndex = (isCircular ? Math.floor(position / scrollSize) * panelCount : 0) + panel.getIndex();\n    const progress = relativeIndex - getProgress(cameraDist, range) - (prevPanel.getIndex() + (prevCloneIndex + 1) * panelCount);\n\n    // outset\n    const relativePanelPosition = position - cameraPosition;\n    const outsetProgress = getProgress(relativePanelPosition, outsetRange);\n\n    // visibleRatio\n    const rightRelativePanelPosition = relativePanelPosition + size;\n    const visibleSize = Math.min(viewportSize, rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    const visibleRatio = visibleSize >= 0 ? visibleSize / size : 0;\n\n    return {\n      element: panel.getElement(),\n      index: panel.getIndex(),\n      position,\n      progress,\n      outsetProgress,\n      visibleRatio,\n      anchorPosition: position + panel.getRelativeAnchorPosition(),\n      size: panel.getSize(),\n      focus(this: FlickingPanel, duration?: number): void {\n        const hangerPosition = viewport.getCameraPosition() + viewport.getHangerPosition();\n        const anchorPosition = panel.getAnchorPosition();\n        if (hangerPosition === anchorPosition) {\n          return;\n        }\n\n        const currentPosition = viewport.getCurrentPanel().getPosition();\n        flicking.moveToPanel(this, currentPosition === position ? EVENTS.NONE : EVENTS.CHANGE, null, duration);\n      },\n      update(this: FlickingPanel, updateFunction: (element: HTMLElement) => any): void {\n        panel.getIdenticalPanels()\n          .forEach(eachPanel => updateFunction(eachPanel.getElement()));\n      },\n      prev(this: FlickingPanel): FlickingPanel | null {\n        const originalPrevPanel = panel.getPrevPanel();\n        if (originalPrevPanel == null) {\n          return null;\n        }\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        let newPosition = originalPrevPanel.getPosition();\n\n        while (position  < newPosition) {\n            newPosition -= scrollAreaSize;\n        }\n        return flicking.castToReadonlyPanel(originalPrevPanel, newPosition);\n      },\n      next(this: FlickingPanel): FlickingPanel | null {\n        const originalNextPanel = panel.getNextPanel();\n        if (originalNextPanel == null) {\n          return null;\n        }\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        let newPosition = originalNextPanel.getPosition();\n\n        while (position  > newPosition) {\n          newPosition += scrollAreaSize;\n        }\n        return flicking.castToReadonlyPanel(originalNextPanel, newPosition);\n      },\n    };\n  }\n}\n\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","document","documentElement","style","transformName","prefixedTransform","Error","el","createElement","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","element","className","classList","add","indexOf","replace","cssObj","property","val","min","max","Math","iterable","slice","call","arr","constructor","Array","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","snap","freeScroll","DEFAULT_VIEWPORT_CSS","position","width","height","willChange","DEFAULT_CAMERA_CSS","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NONE","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","IDLE","HOLDING","DRAGGING","ANIMATING","DISABLED","DIRECTION","PREV","NEXT","TRANSFORM","index","options","state","anchorExpression","relativeAnchorPosition","size","clonedPanels","isClone","cloneIndex","originalStyle","getAttribute","cachedBbox","addClass","applyCSS","resize","bbox","getBbox","panel","setAttribute","removeAttribute","prevPanel","nextPanel","getBoundingClientRect","original","getIdenticalPanels","elementStyle","left","top","parseArithmeticExpression","cloneElement","cloneNode","clonedPanel","Panel","push","start","removedPanels","splice","removedPanels_1","getElement","parentNode","viewportElement","cameraElement","hangerPosition","scrollArea","prev","next","translate","build","axesEvent","targetPos","anchorPosition","canSetBoundMode","setTo","flick","destPos","axes","moveVector","moveCoord","map","coord","round","join","updateSize","updateOriginalPanelPositions","updateAdaptiveSize","updateScrollArea","clonePanels","relocatePanels","chainPanels","updateCameraPosition","panels","currentHangerPosition","isOutOfBound","allPanels","minimumDistance","Infinity","nearestPanel","allPanels_1","prevPosition","getPosition","nextPosition","getSize","distance","isBetween","abs","_a","panelElement","contains","nearest","shortestDistance","identicals","identical","getAnchorPosition","scrollAreaSize","panInput","enable","disable","sizeToApply","currentPanel","getCurrentPanel","panelBbox","maximumPanelSize","reduce","maximum","viewportStyle","minHeight","minWidth","wrapper","destroy","appendChild","status","innerHTML","html","moveCamera","createPanels","includeClone","concat","handler","axesHandlers","on","resume","off","applyCSSValue","setAxesInstance","moveToDefaultPanel","Axes","easing","interruptable","makeNewPanInput","connect","panelElements","children","toArray","viewportSize","lastPanel","sumOriginalPanelSize","visibleAreaSize","getRelativeAnchorPosition","lastClonedPanel","cloneCount","ceil","prevCloneCount","getCloneIndex","origPanel","clone","_this","appendPanelElement","removeClonedPanelsAfter","maximumNextVisiblePosition","minimumPrevVisiblePosition","firstPanel","clonedPanels_1","cloneBasePos","clonedPanelPos","setPosition","lastReplacePosition","_b","reverse","panelPosition","panelSize","replacePosition","setPrevPanel","setNextPanel","defaultPanel","defaultPosition","summedPanelSize","nextPanelPos","panelPos","hangerPos","parsedBounce","isArray","parsedVal","axis","newPosition","pause","PanInput","scale","prevState","delta","direction","targetPanel","nextState","e","context","tslib_1","triggerEvent","transitTo","onSuccess","onStopped","onChange","State","flicking","offset","inputEvent","offsetX","offsetY","viewport","getCameraPosition","releaseEvent","castToReadonlyPanel","clickedElement","srcEvent","clickedPanel","findPanelOf","cameraPosition","clickedPanelPosition","selectedIndex","getIndex","selectedPanel","_super","onEnter","moveToPanel","stopCamera","isNext","swipeDistance","swipeAngle","deltaX","atan","deltaY","PI","overThreshold","moveTo","getHangerPosition","halfGap","minimumDistanceToChange","durationOption","panelToMove","findNearestPanel","count","adjacentPanel","getNextPanel","getPrevPanel","firstClonedPanel","lapped","eventType","isTrusted","IdleState","nextStateType","currentState","type","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onHold","onRelease","onAnimationEnd","onFinish","eventName","params","stateMachine","getState","progress","getProgress","canceled","trigger","merge","holding","callback","inputOffset","prevPos","cameraChange","looped","getScrollAreaSize","currentDirection","previousPosition","estimatedPosition","currentPosition","eventResult","prevIndex","fire","eventContext","isCircular","realtiveHangerPosition","cameraDist","isOnNext","scrollSize","prevAnchorPosition","nextAnchorPosition","outsetRange","panelCount","getPanelCount","prevCloneIndex","relativeIndex","floor","relativePanelPosition","outsetProgress","rightRelativePanelPosition","visibleSize","visibleRatio","focus","update","updateFunction","eachPanel","originalPrevPanel","originalNextPanel","querySelector","nodeName","nodeType","getPrevIndex","getNextIndex","getPanel","panelIndex","currentIndex","findNearestIdenticalPanel","getAllPanels","filter","playing","outerHTML","restore","plugins","newPlugins","plugin","init","currentPlugins","removedPlugins","setInitialState","initViewport","listenInput","listenResize","StateMachine","firstChild","Viewport","handlers","connectAxesHandler","addEventListener","Flicking","Component"],"mappings":"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"}