{"version":3,"file":"flicking.pkgd.js","sources":["../src/const/error.ts","../src/const/external.ts","../src/utils.ts","../src/core/FlickingError.ts","../src/core/Viewport.ts","../src/core/AutoResizer.ts","../src/core/panel/provider/VanillaElementProvider.ts","../src/core/panel/provider/VirtualElementProvider.ts","../src/core/VirtualManager.ts","../src/const/axes.ts","../src/control/states/State.ts","../src/control/states/IdleState.ts","../src/control/states/HoldingState.ts","../src/control/states/DraggingState.ts","../src/control/states/AnimatingState.ts","../src/control/states/DisabledState.ts","../src/control/StateMachine.ts","../src/control/AxesController.ts","../src/control/Control.ts","../src/core/AnchorPoint.ts","../src/control/SnapControl.ts","../src/control/FreeControl.ts","../src/control/StrictControl.ts","../src/control/index.ts","../src/camera/mode/CameraMode.ts","../src/camera/mode/LinearCameraMode.ts","../src/camera/mode/CircularCameraMode.ts","../src/camera/mode/BoundCameraMode.ts","../src/camera/Camera.ts","../src/camera/index.ts","../src/renderer/Renderer.ts","../src/renderer/VanillaRenderer.ts","../src/renderer/ExternalRenderer.ts","../src/core/panel/Panel.ts","../src/renderer/strategy/NormalRenderingStrategy.ts","../src/core/panel/VirtualPanel.ts","../src/renderer/strategy/VirtualRenderingStrategy.ts","../src/renderer/index.ts","../src/Flicking.ts","../src/core/index.ts","../src/cfc/withFlickingMethods.ts","../src/cfc/sync.ts","../src/cfc/getRenderingPanels.ts","../src/cfc/getDefaultCameraTransform.ts","../src/index.umd.ts"],"sourcesContent":["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\n/**\n * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.\n * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.\n * @name ERROR_CODE\n * @constant\n * @type object\n * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>\n * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>\n * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>\n * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>\n * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>\n * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>\n * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>\n * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>\n * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>\n * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>\n * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>\n * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)\n * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>\n * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>\n * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>\n * @property {number} NOT_ALLOWED_IN_VIRTUAL When the non-allowed method is called while the virtual option is enabled<ko>virtual 옵션이 활성화된 상태에서 사용 불가능한 메소드가 호출되었을 경우</ko>\n */\nexport const CODE = {\n  WRONG_TYPE: 0,\n  ELEMENT_NOT_FOUND: 1,\n  VAL_MUST_NOT_NULL: 2,\n  NOT_ATTACHED_TO_FLICKING: 3,\n  WRONG_OPTION: 4,\n  INDEX_OUT_OF_RANGE: 5,\n  POSITION_NOT_REACHABLE: 6,\n  TRANSFORM_NOT_SUPPORTED: 7,\n  STOP_CALLED_BY_USER: 8,\n  ANIMATION_INTERRUPTED: 9,\n  ANIMATION_ALREADY_PLAYING: 10,\n  NOT_ALLOWED_IN_FRAMEWORK: 11,\n  NOT_INITIALIZED: 12,\n  NO_ACTIVE: 13,\n  NOT_ALLOWED_IN_VIRTUAL: 14\n} as const;\n\nexport const MESSAGE = {\n  WRONG_TYPE: (wrongVal: any, correctTypes: string[]) => `${wrongVal}(${typeof wrongVal}) is not a ${correctTypes.map(type => `\"${type}\"`).join(\" or \")}.`,\n  ELEMENT_NOT_FOUND: (selector: string) => `Element with selector \"${selector}\" not found.`,\n  VAL_MUST_NOT_NULL: (val: any, name: string) => `${name} should be provided. Given: ${val}`,\n  NOT_ATTACHED_TO_FLICKING: \"This module is not attached to the Flicking instance. \\\"init()\\\" should be called first.\",\n  WRONG_OPTION: (optionName: string, val: any) => `Option \"${optionName}\" is not in correct format, given: ${val}`,\n  INDEX_OUT_OF_RANGE: (val: number, min: number, max: number) => `Index \"${val}\" is out of range: should be between ${min} and ${max}.`,\n  POSITION_NOT_REACHABLE: (position: number) => `Position \"${position}\" is not reachable.`,\n  TRANSFORM_NOT_SUPPORTED: \"Browser does not support CSS transform.\",\n  STOP_CALLED_BY_USER: \"Event stop() is called by user.\",\n  ANIMATION_INTERRUPTED: \"Animation is interrupted by user input.\",\n  ANIMATION_ALREADY_PLAYING: \"Animation is already playing.\",\n  NOT_ALLOWED_IN_FRAMEWORK: \"This behavior is not allowed in the frameworks like React, Vue, or Angular.\",\n  NOT_INITIALIZED: \"Flicking is not initialized yet, call init() first.\",\n  NO_ACTIVE: \"There's no active panel that Flicking has selected. This may be due to the absence of any panels.\",\n  NOT_ALLOWED_IN_VIRTUAL: \"This behavior is not allowed when the virtual option is enabled\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nexport { CODE as ERROR_CODE } from \"./error\";\n\n/**\n * Event type object with event name strings of {@link Flicking}\n * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체\n * @type {object}\n * @property {\"holdStart\"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>\n * @property {\"holdEnd\"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>\n * @property {\"moveStart\"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>\n * @property {\"move\"} MOVE move event<ko>move 이벤트</ko>\n * @property {\"moveEnd\"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>\n * @property {\"willChange\"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>\n * @property {\"changed\"} CHANGED changed event<ko>changed 이벤트</ko>\n * @property {\"willRestore\"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>\n * @property {\"restored\"} RESTORED restored event<ko>restored 이벤트</ko>\n * @property {\"select\"} SELECT select event<ko>select 이벤트</ko>\n * @property {\"needPanel\"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>\n * @property {\"panelChange\"} PANEL_CHANGE panelChange event<ko>panelChange 이벤트</ko>\n * @example\n * ```ts\n * import { EVENTS } from \"@egjs/flicking\";\n * EVENTS.MOVE_START; // \"moveStart\"\n * ```\n */\nexport const EVENTS = {\n  READY: \"ready\",\n  BEFORE_RESIZE: \"beforeResize\",\n  AFTER_RESIZE: \"afterResize\",\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  WILL_CHANGE: \"willChange\",\n  CHANGED: \"changed\",\n  WILL_RESTORE: \"willRestore\",\n  RESTORED: \"restored\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n  REACH_EDGE: \"reachEdge\",\n  PANEL_CHANGE: \"panelChange\"\n} as const;\n\n/**\n * An object with all possible predefined literal string for the {@link Flicking#align align} option\n * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체\n * @type {object}\n * @property {\"prev\"} PREV left/top align<ko>좌/상 정렬</ko>\n * @property {\"center\"} CENTER center align<ko>중앙 정렬</ko>\n * @property {\"next\"} NEXT right/bottom align<ko>우/하 정렬</ko>\n */\nexport const ALIGN = {\n  PREV: \"prev\",\n  CENTER: \"center\",\n  NEXT: \"next\"\n} as const;\n\n/**\n * An object of directions\n * @ko 방향을 나타내는 값들을 담고 있는 객체\n * @type {object}\n * @property {\"PREV\"} PREV \"left\" when {@link Flicking#horizontal horizontal} is true, and \"top\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>\n * @property {\"NEXT\"} NEXT \"right\" when {@link Flicking#horizontal horizontal} is true, and \"bottom\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>\n * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>\n */\nexport const DIRECTION = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n  NONE: null\n} as const;\n\n/**\n * An object with all possible {@link Flicking#moveType moveType}s\n * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체\n * @type {object}\n * @property {\"snap\"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"freeScroll\"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"strict\"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link StrictControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n */\nexport const MOVE_TYPE = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n  STRICT: \"strict\"\n} as const;\n\nexport const CLASS = {\n  VERTICAL: \"vertical\",\n  HIDDEN: \"flicking-hidden\",\n  DEFAULT_VIRTUAL: \"flicking-panel\"\n};\n\n/**\n * An object with all possible {@link Flicking#circularFallback circularFallback}s\n * @ko Flicking의 {@link Flicking#circularFallback circularFallback}에 설정 가능한 값들을 담고 있는 객체\n * @type {object}\n * @property {string} LINEAR \"linear\"\n * @property {string} BOUND \"bound\"\n */\nexport const CIRCULAR_FALLBACK = {\n  LINEAR: \"linear\",\n  BOUND: \"bound\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking, { FlickingOptions } from \"./Flicking\";\nimport FlickingError from \"./core/FlickingError\";\nimport * as ERROR from \"./const/error\";\nimport { ALIGN, DIRECTION } from \"./const/external\";\nimport { LiteralUnion, Merged, ValueOf } from \"./type/internal\";\nimport { ElementLike } from \"./type/external\";\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const merge = <From extends object, To extends object>(target: From, ...sources: To[]): Merged<From, To> => {\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      target[key] = source[key] as unknown;\n    });\n  });\n\n  return target as Merged<From, To>;\n};\n\nexport const getElement = (el: HTMLElement | string | null, parent?: HTMLElement): HTMLElement => {\n  let targetEl: HTMLElement | null = null;\n\n  if (isString(el)) {\n    const parentEl = parent ? parent : document;\n    const queryResult = parentEl.querySelector(el);\n    if (!queryResult) {\n      throw new FlickingError(ERROR.MESSAGE.ELEMENT_NOT_FOUND(el), ERROR.CODE.ELEMENT_NOT_FOUND);\n    }\n    targetEl = queryResult as HTMLElement;\n  } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n    targetEl = el;\n  }\n\n  if (!targetEl) {\n    throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n  }\n\n  return targetEl;\n};\n\nexport const checkExistence = (value: any, nameOnErrMsg: string) => {\n  if (value == null) {\n    throw new FlickingError(ERROR.MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), ERROR.CODE.VAL_MUST_NOT_NULL);\n  }\n};\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\n\nexport const getFlickingAttached = (val: Flicking | null): Flicking => {\n  if (!val) {\n    throw new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING, ERROR.CODE.NOT_ATTACHED_TO_FLICKING);\n  }\n\n  return val;\n};\n\nexport const toArray = <T>(iterable: ArrayLike<T>): T[] => [].slice.call(iterable) as T[];\n\nexport const parseAlign = (align: LiteralUnion<ValueOf<typeof ALIGN>> | number, size: number): number => {\n  let alignPoint: number | null;\n  if (isString(align)) {\n    switch (align) {\n      case ALIGN.PREV:\n        alignPoint = 0;\n        break;\n      case ALIGN.CENTER:\n        alignPoint = 0.5 * size;\n        break;\n      case ALIGN.NEXT:\n        alignPoint = size;\n        break;\n      default:\n        alignPoint = parseArithmeticSize(align, size);\n        if (alignPoint == null) {\n          throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"align\", align), ERROR.CODE.WRONG_OPTION);\n        }\n    }\n  } else {\n    alignPoint = align as number;\n  }\n\n  return alignPoint;\n};\n\nexport const parseBounce = (bounce: FlickingOptions[\"bounce\"], size: number): number[] => {\n  let parsedBounce: Array<number | null>;\n\n  if (Array.isArray(bounce)) {\n    parsedBounce = (bounce as string[]).map(val => parseArithmeticSize(val, size));\n  } else {\n    const parsedVal = parseArithmeticSize(bounce, size);\n\n    parsedBounce = [parsedVal, parsedVal];\n  }\n\n  return parsedBounce.map(val => {\n    if (val == null) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"bounce\", bounce), ERROR.CODE.WRONG_OPTION);\n    }\n    return val;\n  });\n};\n\nexport const parseArithmeticSize = (cssValue: number | string, base: number): number | null => {\n  const parsed = parseArithmeticExpression(cssValue);\n\n  if (parsed == null) return null;\n\n  return parsed.percentage * base + parsed.absolute;\n};\n\nexport const parseArithmeticExpression = (cssValue: number | string): { percentage: number; absolute: number } | null => {\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return { percentage: 0, absolute: cssValue };\n  }\n\n  const parsed = {\n    percentage: 0,\n    absolute: 0\n  };\n  let idx = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n    const parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return null;\n    }\n\n    const signMultiplier = sign === \"+\" ? 1 : -1;\n\n    if (unit === \"%\") {\n      parsed.percentage += signMultiplier * (parsedValue / 100);\n    } else {\n      parsed.absolute += signMultiplier * parsedValue;\n    }\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return null;\n  }\n\n  return parsed;\n};\n\nexport const parseCSSSizeValue = (val: string | number): string => isString(val) ? val : `${val}px`;\n\nexport const parsePanelAlign = (align: FlickingOptions[\"align\"]) => typeof align === \"object\"\n  ? (align as { panel: string | number }).panel\n  : align;\n\nexport const getDirection = (start: number, end: number): ValueOf<typeof DIRECTION> => {\n  if (start === end) return DIRECTION.NONE;\n  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;\n};\n\nexport const parseElement = (element: ElementLike | ElementLike[]): HTMLElement[] => {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n      elements.push(el);\n    } else {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n    }\n  });\n\n  return elements;\n};\n\nexport const getMinusCompensatedIndex = (idx: number, max: number) => idx < 0 ? clamp(idx + max, 0, max) : clamp(idx, 0, max);\n\nexport const includes = <T>(array: T[], target: any): target is T => {\n  for (const val of array) {\n    if (val === target) return true;\n  }\n  return false;\n};\n\nexport const isString = (val: any): val is string => typeof val === \"string\";\n\nexport const circulatePosition = (pos: number, min: number, max: number) => {\n  const size = max - min;\n\n  if (pos < min) {\n    const offset = (min - pos) % size;\n    pos = max - offset;\n  } else if (pos > max) {\n    const offset = (pos - max) % size;\n    pos = min + offset;\n  }\n\n  return pos;\n};\n\nexport const find = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (const val of array) {\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findRight = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (let idx = array.length - 1; idx >= 0; idx--) {\n    const val = array[idx];\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findIndex = <T>(array: T[], checker: (val: T) => boolean): number => {\n  for (let idx = 0; idx < array.length; idx++) {\n    if (checker(array[idx])) {\n      return idx;\n    }\n  }\n\n  return -1;\n};\n\nexport const getProgress = (pos: number, prev: number, next: number) => (pos - prev) / (next - prev);\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nexport const getStyle = (el: HTMLElement): CSSStyleDeclaration => window.getComputedStyle(el) || (el as any).currentStyle as CSSStyleDeclaration;\n\nexport const setSize = (el: HTMLElement, { width, height }: Partial<{\n  width: number | string;\n  height: number | string;\n}>) => {\n  if (width != null) {\n    if (isString(width)) {\n      el.style.width = width;\n    } else {\n      el.style.width = `${width}px`;\n    }\n  }\n  if (height != null) {\n    if (isString(height)) {\n      el.style.height = height;\n    } else {\n      el.style.height = `${height}px`;\n    }\n  }\n};\n\nexport const isBetween = (val: number, min: number, max: number) => val >= min && val <= max;\n\nexport const circulateIndex = (index: number, max: number): number => {\n  if (index >= max) {\n    return index % max;\n  } else if (index < 0) {\n    return getMinusCompensatedIndex((index + 1) % max - 1, max);\n  } else {\n    return index;\n  }\n};\n\nexport const range = (end: number): number[] => {\n  const arr = new Array(end);\n\n  for (let i = 0; i < end; i++) {\n    arr[i] = i;\n  }\n\n  return arr;\n};\n\nexport const setPrototypeOf = Object.setPrototypeOf || ((obj, proto) => {\n  obj.__proto__ = proto;\n  return obj;\n});\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { setPrototypeOf } from \"../utils\";\n\n/**\n * Special type of known error that {@link Flicking} throws.\n * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러\n * @property {number} code Error code<ko>에러 코드</ko>\n * @property {string} message Error message<ko>에러 메시지</ko>\n * @see {@link Constants.ERROR_CODE ERROR_CODE}\n * @example\n * ```ts\n * import Flicking, { FlickingError, ERROR_CODES } from \"@egjs/flicking\";\n * try {\n *   const flicking = new Flicking(\".flicking-viewport\")\n * } catch (e) {\n *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {\n *     console.error(\"Element not found\")\n *   }\n * }\n * ```\n */\nclass FlickingError extends Error {\n  public code: number;\n\n  /**\n   * @param message Error message<ko>에러 메시지</ko>\n   * @param code Error code<ko>에러 코드</ko>\n   */\n  public constructor(message: string, code: number) {\n    super(message);\n\n    setPrototypeOf(this, FlickingError.prototype);\n    this.name = \"FlickingError\";\n    this.code = code;\n  }\n}\n\nexport default FlickingError;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getStyle, isString } from \"../utils\";\n\n/**\n * A component that manages viewport size\n * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n */\nclass Viewport {\n  private _el: HTMLElement;\n  private _width: number;\n  private _height: number;\n  private _isBorderBoxSizing: boolean;\n  private _padding: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  };\n\n  /**\n   * A viewport(root) element\n   * @ko 뷰포트(root) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  /**\n   * Viewport width, without paddings\n   * @ko 뷰포트 너비\n   * @type {number}\n   * @readonly\n   */\n  public get width() { return this._width - this._padding.left - this._padding.right; }\n  /**\n   * Viewport height, without paddings\n   * @ko 뷰포트 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height - this._padding.top - this._padding.bottom; }\n  /**\n   * Viewport paddings\n   * @ko 뷰포트 CSS padding 값\n   * @type {object}\n   * @property {number} left CSS `padding-left`\n   * @property {number} right CSS `padding-right`\n   * @property {number} top CSS `padding-top`\n   * @property {number} bottom CSS `padding-bottom`\n   * @readonly\n   */\n  public get padding() { return this._padding; }\n\n  /**\n   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>\n   */\n  public constructor(el: HTMLElement) {\n    this._el = el;\n    this._width = 0;\n    this._height = 0;\n    this._padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this._isBorderBoxSizing = false;\n  }\n\n  /**\n   * Change viewport's size.\n   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property\n   * @ko 뷰포트 크기를 변경합니다.\n   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   */\n  public setSize({\n    width,\n    height\n  }: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    const el = this._el;\n    const padding = this._padding;\n    const isBorderBoxSizing = this._isBorderBoxSizing;\n\n    if (width != null) {\n      if (isString(width)) {\n        el.style.width = width;\n      } else {\n        const newWidth = isBorderBoxSizing\n          ? width + padding.left + padding.right\n          : width;\n        el.style.width = `${newWidth}px`;\n      }\n    }\n    if (height != null) {\n      if (isString(height)) {\n        el.style.height = height;\n      } else {\n        const newHeight = isBorderBoxSizing\n          ? height + padding.top + padding.bottom\n          : height;\n        el.style.height = `${newHeight}px`;\n      }\n    }\n    this.resize();\n  }\n\n  /**\n   * Update width/height to the current viewport element's size\n   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다\n   */\n  public resize() {\n    const el = this._el;\n    const elStyle = getStyle(el);\n\n    this._width = el.clientWidth;\n    this._height = el.clientHeight;\n    this._padding = {\n      left: elStyle.paddingLeft ? parseFloat(elStyle.paddingLeft) : 0,\n      right: elStyle.paddingRight ? parseFloat(elStyle.paddingRight) : 0,\n      top: elStyle.paddingTop ? parseFloat(elStyle.paddingTop) : 0,\n      bottom: elStyle.paddingBottom ? parseFloat(elStyle.paddingBottom) : 0\n    };\n    this._isBorderBoxSizing = elStyle.boxSizing === \"border-box\";\n  }\n}\n\nexport default Viewport;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../Flicking\";\n\nclass AutoResizer {\n  private _flicking: Flicking;\n  private _enabled: boolean;\n  private _resizeObserver: ResizeObserver | null;\n  private _resizeTimer: number;\n  private _maxResizeDebounceTimer: number;\n\n  public get enabled() { return this._enabled; }\n\n  public constructor(flicking: Flicking) {\n    this._flicking = flicking;\n    this._enabled = false;\n    this._resizeObserver = null;\n    this._resizeTimer = -1;\n    this._maxResizeDebounceTimer = -1;\n  }\n\n  public enable(): this {\n    const flicking = this._flicking;\n    const viewport = flicking.viewport;\n\n    if (this._enabled) {\n      this.disable();\n    }\n\n    if (flicking.useResizeObserver && !!window.ResizeObserver) {\n      const viewportSizeNot0 = viewport.width !== 0 || viewport.height !== 0;\n\n      const resizeObserver = viewportSizeNot0\n        ? new ResizeObserver(this._skipFirstResize)\n        : new ResizeObserver(this._onResize);\n\n      resizeObserver.observe(flicking.viewport.element);\n\n      this._resizeObserver = resizeObserver;\n    } else {\n      window.addEventListener(\"resize\", this._onResize);\n    }\n\n    this._enabled = true;\n\n    return this;\n  }\n\n  public disable(): this {\n    if (!this._enabled) return this;\n\n    const resizeObserver = this._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      this._resizeObserver = null;\n    } else {\n      window.removeEventListener(\"resize\", this._onResize);\n    }\n\n    this._enabled = false;\n\n    return this;\n  }\n\n  private _onResize = () => {\n    const flicking = this._flicking;\n    const resizeDebounce = flicking.resizeDebounce;\n    const maxResizeDebounce = flicking.maxResizeDebounce;\n\n    if (resizeDebounce <= 0) {\n      void flicking.resize();\n    } else {\n      if (this._maxResizeDebounceTimer <= 0) {\n        if (maxResizeDebounce > 0 && maxResizeDebounce >= resizeDebounce) {\n          this._maxResizeDebounceTimer = window.setTimeout(this._doScheduledResize, maxResizeDebounce);\n        }\n      }\n\n      if (this._resizeTimer > 0) {\n        clearTimeout(this._resizeTimer);\n        this._resizeTimer = 0;\n      }\n\n      this._resizeTimer = window.setTimeout(this._doScheduledResize, resizeDebounce);\n    }\n  };\n\n  private _doScheduledResize = () => {\n    clearTimeout(this._resizeTimer);\n    clearTimeout(this._maxResizeDebounceTimer);\n\n    this._maxResizeDebounceTimer = -1;\n    this._resizeTimer = -1;\n\n    void this._flicking.resize();\n  };\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  private _skipFirstResize = (() => {\n    let isFirstResize = true;\n\n    return (() => {\n      if (isFirstResize) {\n        isFirstResize = false;\n        return;\n      }\n      this._onResize();\n    });\n  })();\n}\n\nexport default AutoResizer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../../Flicking\";\n\nimport ElementProvider from \"./ElementProvider\";\n\n/**\n * @internal\n */\nclass VanillaElementProvider implements ElementProvider {\n  private _element: HTMLElement;\n  private _rendered: boolean;\n\n  public get element() { return this._element; }\n  public get rendered() { return this._rendered; }\n\n  public constructor(element: HTMLElement) {\n    this._element = element;\n    this._rendered = true;\n  }\n\n  public show(flicking: Flicking): void {\n    const el = this.element;\n    const cameraEl = flicking.camera.element;\n\n    if (el.parentElement !== cameraEl) {\n      cameraEl.appendChild(el);\n      this._rendered = true;\n    }\n  }\n\n  public hide(flicking: Flicking): void {\n    const el = this.element;\n    const cameraEl = flicking.camera.element;\n\n    if (el.parentElement === cameraEl) {\n      cameraEl.removeChild(el);\n      this._rendered = false;\n    }\n  }\n}\n\nexport default VanillaElementProvider;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Flicking from \"../../../Flicking\";\nimport VirtualPanel from \"../VirtualPanel\";\n\nimport ElementProvider from \"./ElementProvider\";\n\n/**\n * @internal\n */\nclass VirtualElementProvider implements ElementProvider {\n  private _flicking: Flicking;\n  private _panel: VirtualPanel;\n\n  public get element() { return this._virtualElement.nativeElement; }\n  public get rendered() { return this._virtualElement.visible; }\n\n  private get _virtualElement() {\n    const flicking = this._flicking;\n    const elIndex = this._panel.elementIndex;\n    const virtualElements = flicking.virtual.elements;\n\n    return virtualElements[elIndex];\n  }\n\n  public constructor(flicking: Flicking) {\n    this._flicking = flicking;\n  }\n\n  public init(panel: VirtualPanel) {\n    this._panel = panel;\n  }\n\n  public show(): void {\n    // DO_NOTHING\n    // Actual element visibility is controlled by VirtualManager\n  }\n\n  public hide(): void {\n    // DO_NOTHING\n    // Actual element visibility is controlled by VirtualManager\n  }\n}\n\nexport default VirtualElementProvider;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../Flicking\";\nimport { range } from \"../utils\";\nimport { CLASS } from \"../const/external\";\n\nimport VirtualPanel from \"./panel/VirtualPanel\";\n\nexport interface VirtualOptions {\n  renderPanel: (panel: VirtualPanel, index: number) => string;\n  initialPanelCount: number;\n  cache?: boolean;\n  panelClass?: string;\n}\n\n/**\n * A manager class to add / remove virtual panels\n */\nclass VirtualManager {\n  private _flicking: Flicking;\n\n  private _renderPanel: (panel: VirtualPanel, index: number) => string;\n  private _initialPanelCount: number;\n  private _cache: boolean;\n  private _panelClass: string;\n\n  private _elements: Array<{ nativeElement: HTMLElement; visible: boolean }>;\n\n  public get elements() { return this._elements; }\n\n  // Options\n  /**\n   * A rendering function for the panel element's innerHTML\n   * @ko 패널 엘리먼트의 innerHTML을 렌더링하는 함수\n   * @type {function}\n   * @param {VirtualPanel} panel Instance of the panel<ko>패널 인스턴스</ko>\n   * @param {number} index Index of the panel<ko>패널 인덱스</ko>\n   * @default \"() => {}\"\n   */\n  public get renderPanel() { return this._renderPanel; }\n  /**\n   * Initial panel count to render\n   * @ko 최초로 렌더링할 패널의 개수\n   * @readonly\n   * @type {number}\n   * @default -1\n   */\n  public get initialPanelCount() { return this._initialPanelCount; }\n  /**\n   * Whether to cache rendered panel's innerHTML\n   * @ko 렌더링된 패널의 innerHTML 정보를 캐시할지 여부\n   * @type {boolean}\n   * @default false\n   */\n  public get cache() { return this._cache; }\n  /**\n   * The class name that will be applied to rendered panel elements\n   * @ko 렌더링되는 패널 엘리먼트에 적용될 클래스 이름\n   * @type {string}\n   * @default \"flicking-panel\"\n   */\n  public get panelClass() { return this._panelClass; }\n\n  public set renderPanel(val: VirtualOptions[\"renderPanel\"]) {\n    this._renderPanel = val;\n    this._flicking.renderer.panels.forEach((panel: VirtualPanel) => panel.uncacheRenderResult());\n  }\n\n  public set cache(val: NonNullable<VirtualOptions[\"cache\"]>) { this._cache = val; }\n  public set panelClass(val: NonNullable<VirtualOptions[\"panelClass\"]>) { this._panelClass = val; }\n\n  public constructor(flicking: Flicking, options: VirtualOptions | null) {\n    this._flicking = flicking;\n\n    this._renderPanel = options?.renderPanel ?? (() => \"\");\n    this._initialPanelCount = options?.initialPanelCount ?? -1;\n    this._cache = options?.cache ?? false;\n    this._panelClass = options?.panelClass ?? CLASS.DEFAULT_VIRTUAL;\n\n    this._elements = [];\n  }\n\n  public init() {\n    const flicking = this._flicking;\n\n    if (!flicking.virtualEnabled) return;\n\n    if (!flicking.externalRenderer && !flicking.renderExternal) {\n      this._initVirtualElements();\n    }\n\n    const virtualElements = flicking.camera.children;\n    this._elements = virtualElements.map(el => ({ nativeElement: el, visible: true }));\n  }\n\n  public show(index: number) {\n    const el = this._elements[index];\n    const nativeEl = el.nativeElement;\n\n    el.visible = true;\n\n    if (nativeEl.style.display) {\n      nativeEl.style.display = \"\";\n    }\n  }\n\n  public hide(index: number) {\n    const el = this._elements[index];\n    const nativeEl = el.nativeElement;\n\n    el.visible = false;\n    nativeEl.style.display = \"none\";\n  }\n\n  /**\n   * Add new virtual panels at the end of the list\n   * @ko 새로운 가상 패널들을 리스트의 끝에 추가합니다\n   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>\n   */\n  public append(count: number = 1): VirtualPanel[] {\n    const flicking = this._flicking;\n\n    return this.insert(flicking.panels.length, count);\n  }\n\n  /**\n   * Add new virtual panels at the start of the list\n   * @ko 새로운 가상 패널들을 리스트의 시작에 추가합니다\n   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>\n   */\n  public prepend(count: number = 1): VirtualPanel[] {\n    return this.insert(0, count);\n  }\n\n  /**\n   * Add new virtual panels at the given index\n   * @ko 새로운 가상 패널들을 주어진 인덱스에 추가합니다\n   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>\n   */\n  public insert(index: number, count: number = 1): VirtualPanel[] {\n    if (count <= 0) return [];\n\n    const flicking = this._flicking;\n\n    return flicking.renderer.batchInsert({ index, elements: range(count), hasDOMInElements: false }) as VirtualPanel[];\n  }\n\n  /**\n   * Remove panels at the given index\n   * @ko 주어진 인덱스에서 패널들을 삭제합니다\n   * @param {number} count The number of panels to remove<ko>삭제할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The panels removed<ko>삭제된 패널들</ko>\n   */\n  public remove(index: number, count: number): VirtualPanel[] {\n    if (count <= 0) return [];\n\n    const flicking = this._flicking;\n\n    return flicking.renderer.batchRemove({ index, deleteCount: count, hasDOMInElements: false }) as VirtualPanel[];\n  }\n\n  private _initVirtualElements() {\n    const flicking = this._flicking;\n    const cameraElement = flicking.camera.element;\n    const panelsPerView = flicking.panelsPerView;\n    const fragment = document.createDocumentFragment();\n\n    const newElements = range(panelsPerView + 1).map(idx => {\n      const panelEl = document.createElement(\"div\");\n      panelEl.className = this._panelClass;\n      panelEl.dataset.elementIndex = idx.toString();\n      return panelEl;\n    });\n\n    newElements.forEach(el => {\n      fragment.appendChild(el);\n    });\n\n    cameraElement.appendChild(fragment);\n  }\n}\n\nexport default VirtualManager;\n","/**\n * All possible @egjs/axes event keys\n * @internal\n */\nexport const EVENT = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\"\n} as const;\n\n/**\n * An Axis key that Flicking uses\n * @internal\n */\nexport const POSITION_KEY = \"flick\";\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { OnAnimationEnd, OnChange, OnFinish, OnHold, OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../../Flicking\";\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\nimport { circulatePosition, getDirection } from \"../../utils\";\n\nexport enum STATE_TYPE {\n  IDLE,\n  HOLDING,\n  DRAGGING,\n  ANIMATING,\n  DISABLED\n}\n\n/**\n * A component that shows the current status of the user input or the animation\n * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트\n * @internal\n */\nabstract class State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly holding: boolean;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly animating: boolean;\n\n  protected _delta: number = 0;\n  protected _targetPanel: Panel | null = null;\n\n  /**\n   * A sum of delta values of change events from the last hold event of Axes\n   * @ko 이전 hold이벤트부터 change에 의해 발생한 이동 delta값의 합산\n   * @type {number}\n   * @readonly\n   */\n  public get delta() { return this._delta; }\n\n  /**\n   * A panel to set as {@link Control#activePanel} after the animation is finished\n   * @ko 애니메이션 종료시 {@link Control#activePanel}로 설정할 패널\n   * @type {number}\n   * @readonly\n   */\n  public get targetPanel() { return this._targetPanel; }\n\n  public set targetPanel(val: Panel | null) { this._targetPanel = val; }\n\n  /**\n   * An callback which is called when state has changed to this state\n   * @ko 현재 상태로 돌입했을때 호출되는 콜백 함수\n   * @param {State} prevState An previous state<ko>이전 상태값</ko>\n   * @return {void}\n   */\n  public onEnter(prevState: State): void {\n    this._delta = prevState._delta;\n    this._targetPanel = prevState._targetPanel;\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onHold(ctx: {\n    flicking: Flicking;\n    axesEvent: OnHold;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onChange(ctx: {\n    flicking: Flicking;\n    axesEvent: OnChange;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onRelease(ctx: {\n    flicking: Flicking;\n    axesEvent: OnRelease;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onAnimationEnd(ctx: {\n    flicking: Flicking;\n    axesEvent: OnAnimationEnd;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onFinish(ctx: {\n    flicking: Flicking;\n    axesEvent: OnFinish;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  protected _moveToChangedPosition(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const delta = axesEvent.delta[AXES.POSITION_KEY];\n\n    if (!delta) {\n      return;\n    }\n\n    this._delta += delta;\n\n    const camera = flicking.camera;\n    const prevPosition = camera.position;\n    const position = axesEvent.pos[AXES.POSITION_KEY];\n    const newPosition = flicking.circularEnabled\n      ? circulatePosition(position, camera.range.min, camera.range.max)\n      : position;\n\n    camera.lookAt(newPosition);\n\n    const moveEvent = new ComponentEvent(EVENTS.MOVE, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, axesEvent.delta[AXES.POSITION_KEY]),\n      axesEvent\n    });\n\n    flicking.trigger(moveEvent);\n\n    if (moveEvent.isCanceled()) {\n      // Return to previous position\n      camera.lookAt(prevPosition);\n      transitTo(STATE_TYPE.DISABLED);\n    }\n  }\n}\n\nexport default State;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A default state when there's no user input and no animation's playing\n * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태\n * @internal\n */\nclass IdleState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  public onEnter() {\n    this._delta = 0;\n    this._targetPanel = null;\n  }\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    // Shouldn't do any action until any panels on flicking area\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (flicking.renderer.panelCount <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, {\n      axesEvent\n    });\n\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.HOLDING);\n    }\n  }\n\n  // By methods call\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const controller = flicking.control.controller;\n    const animatingContext = controller.animatingContext;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);\n    }\n  }\n}\n\nexport default IdleState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's holding the Flicking area, but not moved a single pixel yet\n * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태\n * @internal\n */\nclass HoldingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  private _releaseEvent: OnRelease | null = null;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const inputEvent = axesEvent.inputEvent as { offsetX: number; offsetY: number };\n\n    const offset = flicking.horizontal\n      ? inputEvent.offsetX\n      : inputEvent.offsetY;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, -offset),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);\n    }\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, { axesEvent }));\n\n    if (axesEvent.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      axesEvent.setTo({ flick: flicking.camera.position }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this._releaseEvent = axesEvent;\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]): void {\n    const { flicking, transitTo } = ctx;\n\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this._releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this._releaseEvent;\n\n    // Static click\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */\n    const srcEvent = releaseEvent.inputEvent.srcEvent;\n\n    let clickedElement: HTMLElement;\n    if (srcEvent.type === \"touchend\") {\n      const touchEvent = srcEvent as TouchEvent;\n      const touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY) as HTMLElement;\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    /* eslint-enable */\n\n    const panels = flicking.renderer.panels;\n    let clickedPanel: Panel | null = null;\n\n    for (const panel of panels) {\n      if (panel.contains(clickedElement)) {\n        clickedPanel = panel;\n        break;\n      }\n    }\n\n    if (clickedPanel) {\n      const cameraPosition = flicking.camera.position;\n      const clickedPanelPosition = clickedPanel.position;\n\n      flicking.trigger(new ComponentEvent(EVENTS.SELECT, {\n        index: clickedPanel.index,\n        panel: clickedPanel,\n        // Direction to the clicked panel\n        direction: getDirection(cameraPosition, clickedPanelPosition)\n      }));\n    }\n  }\n}\n\nexport default HoldingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's dragging the Flicking area\n * @ko 사용자가 드래깅중인 상태\n * @internal\n */\nclass DraggingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, {\n      axesEvent\n    }));\n\n    if (flicking.renderer.panelCount <= 0) {\n      // There're no panels\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    transitTo(STATE_TYPE.ANIMATING);\n\n    const control = flicking.control;\n    const position = axesEvent.destPos[AXES.POSITION_KEY];\n    const duration = Math.max(axesEvent.duration, flicking.duration);\n\n    void control.moveToPosition(position, duration, axesEvent);\n  }\n}\n\nexport default DraggingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking's animating by user input or method call\n * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태\n * @internal\n */\nclass AnimatingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    this._delta = 0;\n    flicking.control.updateInput();\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, { axesEvent });\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.DRAGGING);\n    }\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]) {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const control = flicking.control;\n    const controller = control.controller;\n    const animatingContext = controller.animatingContext;\n\n    transitTo(STATE_TYPE.IDLE);\n\n    flicking.trigger(new ComponentEvent(EVENTS.MOVE_END, {\n      isTrusted: axesEvent.isTrusted,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    }));\n\n    control.setActive(this._targetPanel!, control.activePanel, axesEvent.isTrusted);\n  }\n}\n\nexport default AnimatingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking is stopped by event's `stop` method\n * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태\n * @internal\n */\nclass DisabledState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onAnimationEnd(ctx: Parameters<State[\"onAnimationEnd\"]>[0]): void {\n    const { transitTo } = ctx;\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // Can stop Axes's change event\n    axesEvent.stop();\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // This is needed when stopped hold start event\n    if (axesEvent.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { AxesEvents } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport * as AXES from \"../const/axes\";\n\nimport IdleState from \"./states/IdleState\";\nimport HoldingState from \"./states/HoldingState\";\nimport DraggingState from \"./states/DraggingState\";\nimport AnimatingState from \"./states/AnimatingState\";\nimport DisabledState from \"./states/DisabledState\";\nimport State, { STATE_TYPE } from \"./states/State\";\n\n/**\n * @internal\n */\nclass StateMachine {\n  private _state: State;\n\n  public get state(): State { return this._state; }\n\n  public constructor() {\n    this._state = new IdleState();\n  }\n\n  public fire(eventType: keyof AxesEvents, externalCtx: {\n    flicking: Flicking;\n    axesEvent: any;\n  }) {\n    const currentState = this._state;\n    const ctx = { ...externalCtx, transitTo: this.transitTo };\n\n    switch (eventType) {\n      case AXES.EVENT.HOLD:\n        currentState.onHold(ctx);\n        break;\n      case AXES.EVENT.CHANGE:\n        currentState.onChange(ctx);\n        break;\n      case AXES.EVENT.RELEASE:\n        currentState.onRelease(ctx);\n        break;\n      case AXES.EVENT.ANIMATION_END:\n        currentState.onAnimationEnd(ctx);\n        break;\n      case AXES.EVENT.FINISH:\n        currentState.onFinish(ctx);\n        break;\n    }\n  }\n\n  public transitTo = (nextStateType: STATE_TYPE): State => {\n    let nextState: State;\n\n    switch (nextStateType) {\n      case STATE_TYPE.IDLE:\n        nextState = new IdleState();\n        break;\n      case STATE_TYPE.HOLDING:\n        nextState = new HoldingState();\n        break;\n      case STATE_TYPE.DRAGGING:\n        nextState = new DraggingState();\n        break;\n      case STATE_TYPE.ANIMATING:\n        nextState = new AnimatingState();\n        break;\n      case STATE_TYPE.DISABLED:\n        nextState = new DisabledState();\n        break;\n    }\n\n    nextState.onEnter(this._state);\n\n    this._state = nextState;\n\n    return this._state;\n  };\n}\n\nexport default StateMachine;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Axes, { PanInput, AxesEvents, OnRelease } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\nimport { circulatePosition, getFlickingAttached, parseBounce } from \"../utils\";\nimport { ControlParams } from \"../type/external\";\n\nimport StateMachine from \"./StateMachine\";\n\n/**\n * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n * @internal\n */\nclass AxesController {\n  private _flicking: Flicking | null;\n  private _axes: Axes | null;\n  private _panInput: PanInput | null;\n  private _stateMachine: StateMachine;\n\n  private _animatingContext: { start: number; end: number; offset: number };\n  private _dragged: boolean;\n\n  /**\n   * An {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes}의 인스턴스\n   * @type {Axes}\n   * @see https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html\n   * @readonly\n   */\n  public get axes() { return this._axes; }\n  /**\n   * @internal\n   */\n  public get stateMachine() { return this._stateMachine; }\n  /**\n   * A activated {@link State} that shows the current status of the user input or the animation\n   * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다\n   * @type {State}\n   */\n  public get state() { return this._stateMachine.state; }\n  /**\n   * A context of the current animation playing\n   * @ko 현재 재생중인 애니메이션 정보\n   * @type {object}\n   * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>\n   * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>\n   * @property {number} offset camera offset<ko>카메라 오프셋</ko>\n   * @readonly\n   */\n  public get animatingContext() { return this._animatingContext; }\n  /**\n   * A current control parameters of the Axes instance\n   * @ko 활성화된 현재 Axes 패러미터들\n   * @type {ControlParams}\n   */\n  public get controlParams(): ControlParams {\n    const axes = this._axes;\n\n    if (!axes) {\n      return {\n        range: { min: 0, max: 0 },\n        position: 0,\n        circular: false\n      };\n    }\n\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    return {\n      range: { min: axis.range![0], max: axis.range![1] },\n      circular: (axis.circular as boolean[])[0],\n      position: this.position\n    };\n  }\n\n  /**\n   * A Boolean indicating whether the user input is enabled\n   * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get enabled() { return this._panInput?.isEnable() ?? false; }\n  /**\n   * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._axes?.get([AXES.POSITION_KEY])[AXES.POSITION_KEY] ?? 0; }\n  /**\n   * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 이동 범위 값\n   * @type {number[]}\n   * @readonly\n   */\n  public get range() { return this._axes?.axis[AXES.POSITION_KEY].range ?? [0, 0]; }\n  /**\n   * Actual bounce size(px)\n   * @ko 적용된 bounce 크기(px 단위)\n   * @type {number[]}\n   * @readonly\n   */\n  public get bounce() { return this._axes?.axis[AXES.POSITION_KEY].bounce as number[] | undefined; }\n\n  /** */\n  public constructor() {\n    this._resetInternalValues();\n    this._stateMachine = new StateMachine();\n  }\n\n  /**\n   * Initialize AxesController\n   * @ko AxesController를 초기화합니다\n   * @param {Flicking} flicking An instance of Flicking\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    this._axes = new Axes({\n      [AXES.POSITION_KEY]: {\n        range: [0, 0],\n        circular: false,\n        bounce: [0, 0]\n      }\n    }, {\n      deceleration: flicking.deceleration,\n      interruptable: flicking.interruptable,\n      easing: flicking.easing\n    });\n    this._panInput = new PanInput(flicking.viewport.element, {\n      inputType: flicking.inputType,\n      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,\n      scale: flicking.horizontal ? [-1, 0] : [0, -1],\n      releaseOnScroll: true\n    });\n\n    const axes = this._axes;\n\n    axes.connect(flicking.horizontal ? [AXES.POSITION_KEY, \"\"] : [\"\", AXES.POSITION_KEY], this._panInput);\n\n    for (const key in AXES.EVENT) {\n      const eventType = AXES.EVENT[key] as keyof AxesEvents;\n\n      axes.on(eventType, (e: AxesEvents[typeof eventType]) => {\n        this._stateMachine.fire(eventType, {\n          flicking,\n          axesEvent: e\n        });\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Destroy AxesController and return to initial state\n   * @ko AxesController를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    if (this._axes) {\n      this.removePreventClickHandler();\n      this._axes.destroy();\n    }\n\n    this._panInput?.destroy();\n\n    this._resetInternalValues();\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._panInput?.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._panInput?.disable();\n\n    return this;\n  }\n\n  /**\n   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before\n   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public update(controlParams: ControlParams): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const axes = this._axes!;\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    axis.circular = [controlParams.circular, controlParams.circular];\n    axis.range = [controlParams.range.min, controlParams.range.max];\n    axis.bounce = parseBounce(flicking.bounce, camera.size);\n\n    axes.axm.set({ [AXES.POSITION_KEY]: controlParams.position });\n\n    return this;\n  }\n\n  /**\n   * Attach a handler to the camera element to prevent click events during animation\n   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 부착합니다\n   * @return {this}\n   */\n  public addPreventClickHandler(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.on(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.on(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.addEventListener(\"click\", this._preventClickWhenDragged, true);\n\n    return this;\n  }\n\n  /**\n   * Detach a handler to the camera element to prevent click events during animation\n   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 탈착합니다\n   * @return {this}\n   */\n  public removePreventClickHandler(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.off(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.off(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.removeEventListener(\"click\", this._preventClickWhenDragged, true);\n\n    return this;\n  }\n\n  /**\n   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다\n   * @param {number} position A position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public animateTo(position: number, duration: number, axesEvent?: OnRelease): Promise<void> {\n    const axes = this._axes;\n    const state = this._stateMachine.state;\n\n    if (!axes) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING, ERROR.CODE.NOT_ATTACHED_TO_FLICKING));\n    }\n\n    const startPos = axes.get([AXES.POSITION_KEY])[AXES.POSITION_KEY];\n\n    if (startPos === position) {\n      const flicking = getFlickingAttached(this._flicking);\n\n      flicking.camera.lookAt(position);\n\n      if (state.targetPanel) {\n        flicking.control.setActive(state.targetPanel, flicking.control.activePanel, axesEvent?.isTrusted ?? false);\n      }\n      return Promise.resolve();\n    }\n\n    this._animatingContext = {\n      start: startPos,\n      end: position,\n      offset: 0\n    };\n\n    const animate = () => {\n      const resetContext = () => {\n        this._animatingContext = { start: 0, end: 0, offset: 0 };\n      };\n\n      axes.once(AXES.EVENT.FINISH, resetContext);\n\n      if (axesEvent) {\n        axesEvent.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      } else {\n        axes.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      }\n    };\n\n    if (duration === 0) {\n      const flicking = getFlickingAttached(this._flicking);\n      const camera = flicking.camera;\n\n      animate();\n\n      const newPos = flicking.circularEnabled\n        ? circulatePosition(position, camera.range.min, camera.range.max)\n        : position;\n\n      axes.axm.set({ [AXES.POSITION_KEY]: newPos });\n\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve, reject) => {\n        const animationFinishHandler = () => {\n          axes.off(AXES.EVENT.HOLD, interruptionHandler);\n          resolve();\n        };\n\n        const interruptionHandler = () => {\n          axes.off(AXES.EVENT.FINISH, animationFinishHandler);\n          reject(new FlickingError(ERROR.MESSAGE.ANIMATION_INTERRUPTED, ERROR.CODE.ANIMATION_INTERRUPTED));\n        };\n\n        axes.once(AXES.EVENT.FINISH, animationFinishHandler);\n        axes.once(AXES.EVENT.HOLD, interruptionHandler);\n\n        animate();\n      });\n    }\n  }\n\n  private _resetInternalValues() {\n    this._flicking = null;\n    this._axes = null;\n    this._panInput = null;\n    this._animatingContext = { start: 0, end: 0, offset: 0 };\n    this._dragged = false;\n  }\n\n  private _onAxesHold = () => {\n    this._dragged = false;\n  };\n\n  private _onAxesChange = () => {\n    this._dragged = true;\n  };\n\n  private _preventClickWhenDragged = (e: MouseEvent) => {\n    if (this._dragged) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    this._dragged = false;\n  };\n}\n\nexport default AxesController;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AxesController from \"../control/AxesController\";\nimport { DIRECTION, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getDirection, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\n/**\n * A component that manages inputs and animation of Flicking\n * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트\n */\nabstract class Control {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _controller: AxesController;\n  protected _activePanel: Panel | null;\n\n  /**\n   * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n   * @type {AxesController}\n   * @readonly\n   */\n  public get controller() { return this._controller; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get activeIndex() { return this._activePanel?.index ?? -1; }\n  /**\n   * An active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel | null}\n   * @readonly\n   */\n  public get activePanel() { return this._activePanel; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._controller.state.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._controller.state.holding; }\n\n  /** */\n  public constructor() {\n    this._flicking = null;\n    this._controller = new AxesController();\n    this._activePanel = null;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @method\n   * @abstract\n   * @memberof Control\n   * @instance\n   * @name moveToPosition\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public abstract moveToPosition(position: number, duration: number, axesEvent?: OnRelease): Promise<void>;\n\n  /**\n   * Initialize Control\n   * @ko Control을 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._controller.init(flicking);\n\n    return this;\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._controller.destroy();\n\n    this._flicking = null;\n    this._activePanel = null;\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._controller.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._controller.disable();\n\n    return this;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public updatePosition(_progressInPanel: number): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      camera.lookAt(camera.clampToReachablePosition(activePanel.position));\n    }\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n\n    this._controller.update(camera.controlParams);\n\n    return this;\n  }\n\n  /**\n   * Reset {@link Control#activePanel activePanel} to `null`\n   * @ko {@link Control#activePanel activePanel}을 `null`로 초기화합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetActive(): this {\n    this._activePanel = null;\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given panel\n   * @ko {@link Camera}를 해당 패널 위로 이동합니다\n   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPanel(panel: Panel, {\n    duration,\n    direction = DIRECTION.NONE,\n    axesEvent\n  }: {\n    duration: number;\n    direction?: ValueOf<typeof DIRECTION>;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n\n    let position = panel.position;\n    const nearestAnchor = camera.findNearestAnchor(position);\n\n    if (panel.removed || !nearestAnchor) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(panel.position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n    if (!camera.canReach(panel)) {\n      // Override position & panel if that panel is not reachable\n      position = nearestAnchor.position;\n      panel = nearestAnchor.panel;\n    } else if (flicking.circularEnabled) {\n      // Circular mode is enabled, find nearest distance to panel\n      const camPos = this._controller.position; // Actual position of the Axes\n      const camRangeDiff = camera.rangeDiff;\n      const possiblePositions = [position, position + camRangeDiff, position - camRangeDiff]\n        .filter(pos => {\n          if (direction === DIRECTION.NONE) return true;\n\n          return direction === DIRECTION.PREV\n            ? pos <= camPos\n            : pos >= camPos;\n        });\n\n      position = possiblePositions.reduce((nearestPosition, pos) => {\n        if (Math.abs(camPos - pos) < Math.abs(camPos - nearestPosition)) {\n          return pos;\n        } else {\n          return nearestPosition;\n        }\n      }, Infinity);\n    }\n\n    this._triggerIndexChangeEvent(panel, panel.position, axesEvent);\n\n    return this._animateToPosition({ position, duration, newActivePanel: panel, axesEvent });\n  }\n\n  /**\n   * @internal\n   */\n  public setActive(newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) {\n    const flicking = getFlickingAttached(this._flicking);\n\n    this._activePanel = newActivePanel;\n\n    flicking.camera.updateAdaptiveHeight();\n\n    if (newActivePanel !== prevActivePanel) {\n      flicking.trigger(new ComponentEvent(EVENTS.CHANGED, {\n        index: newActivePanel.index,\n        panel: newActivePanel,\n        prevIndex: prevActivePanel?.index ?? -1,\n        prevPanel: prevActivePanel,\n        isTrusted,\n        direction: prevActivePanel ? getDirection(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE\n      }));\n    } else {\n      flicking.trigger(new ComponentEvent(EVENTS.RESTORED, {\n        isTrusted\n      }));\n    }\n  }\n\n  protected _triggerIndexChangeEvent(panel: Panel, position: number, axesEvent?: OnRelease): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    const event = new ComponentEvent(triggeringEvent, {\n      index: panel.index,\n      panel,\n      isTrusted: axesEvent?.isTrusted || false,\n      direction: getDirection(activePanel?.position ?? camera.position, position)\n    });\n    flicking.trigger(event);\n\n    if (event.isCanceled()) {\n      throw new FlickingError(ERROR.MESSAGE.STOP_CALLED_BY_USER, ERROR.CODE.STOP_CALLED_BY_USER);\n    }\n  }\n\n  protected async _animateToPosition({\n    position,\n    duration,\n    newActivePanel,\n    axesEvent\n  }: {\n    position: number;\n    duration: number;\n    newActivePanel: Panel;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking);\n    const animate = () => this._controller.animateTo(position, duration, axesEvent);\n    const state = this._controller.state;\n\n    state.targetPanel = newActivePanel;\n\n    if (duration <= 0) {\n      return animate();\n    } else {\n      return animate().then(async () => {\n        await flicking.renderer.render();\n      }).catch(err => {\n        if (axesEvent && err instanceof FlickingError && err.code === ERROR.CODE.ANIMATION_INTERRUPTED) return;\n        throw err;\n      });\n    }\n  }\n}\n\nexport default Control;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"./panel/Panel\";\n\n/**\n * A data component that has actual position where the camera should be stopped at\n * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트\n */\nclass AnchorPoint {\n  private _index: number;\n  private _pos: number;\n  private _panel: Panel;\n\n  /**\n   * Index of AnchorPoint\n   * @ko AnchorPoint의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of AnchorPoint\n   * @ko AnchorPoint의 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos; }\n  /**\n   * A {@link Panel} instance AnchorPoint is referencing to\n   * @ko AnchorPoint가 참조하고 있는 {@link Panel}\n   * @type {Panel}\n   * @readonly\n   */\n  public get panel() { return this._panel; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 객체</ko>\n   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>\n   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>\n   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>\n   */\n  public constructor({\n    index,\n    position,\n    panel\n  }: {\n    index: number;\n    position: number;\n    panel: Panel;\n  }) {\n    this._index = index;\n    this._pos = position;\n    this._panel = panel;\n  }\n}\n\nexport default AnchorPoint;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { circulateIndex, clamp, getFlickingAttached } from \"../utils\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link SnapControl}\n * @ko {@link SnapControl} 생성시 사용되는 옵션\n * @interface\n * @property {number} count Maximum number of panels can go after release<ko>입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수</ko>\n */\nexport interface SnapControlOptions {\n  count: number;\n}\n\n/**\n * A {@link Control} that uses a release momentum to choose destination panel\n * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}\n */\nclass SnapControl extends Control {\n  private _count: SnapControlOptions[\"count\"];\n\n  /**\n   * Maximum number of panels can go after release\n   * @ko 입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수\n   * @type {number}\n   * @default Infinity\n   */\n  public get count() { return this._count; }\n\n  public set count(val: SnapControlOptions[\"count\"]) { this._count = val; }\n\n  /** */\n  public constructor({\n    count = Infinity\n  }: Partial<SnapControlOptions> = {}) {\n    super();\n\n    this._count = count;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activeAnchor = camera.findActiveAnchor();\n    const anchorAtCamera = camera.findNearestAnchor(camera.position);\n    const state = flicking.control.controller.state;\n\n    if (!activeAnchor || !anchorAtCamera) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const snapThreshold = this._calcSnapThreshold(position, activeAnchor);\n\n    const posDelta = flicking.animating\n      ? state.delta\n      : position - camera.position;\n    const absPosDelta = Math.abs(posDelta);\n    const snapDelta = axesEvent && axesEvent.delta[AXES.POSITION_KEY] !== 0\n      ? Math.abs(axesEvent.delta[AXES.POSITION_KEY])\n      : absPosDelta;\n    let targetAnchor: AnchorPoint;\n\n    if (snapDelta >= snapThreshold && snapDelta > 0) {\n      // Move to anchor at position\n      targetAnchor = this._findSnappedAnchor(position, anchorAtCamera);\n    } else if (absPosDelta >= flicking.threshold && absPosDelta > 0) {\n      // Move to the adjacent panel\n      targetAnchor = this._findAdjacentAnchor(posDelta, anchorAtCamera);\n    } else {\n      // Restore to active panel\n      targetAnchor = anchorAtCamera;\n    }\n\n    this._triggerIndexChangeEvent(targetAnchor.panel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: camera.clampToReachablePosition(targetAnchor.position),\n      duration,\n      newActivePanel: targetAnchor.panel,\n      axesEvent\n    });\n  }\n\n  private _findSnappedAnchor(position: number, anchorAtCamera: AnchorPoint): AnchorPoint {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const count = this._count;\n\n    const currentPos = camera.position;\n\n    const clampedPosition = camera.clampToReachablePosition(position);\n    const anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtCamera || !anchorAtPosition) {\n      throw new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE);\n    }\n\n    if (!isFinite(count)) {\n      return anchorAtPosition;\n    }\n\n    const panelCount = flicking.panelCount;\n    const anchors = camera.anchorPoints;\n\n    let loopCount = Math.sign(position - currentPos) * Math.floor(Math.abs(position - currentPos) / camera.rangeDiff);\n    if ((position > currentPos && anchorAtPosition.index < anchorAtCamera.index)\n      || (anchorAtPosition.position > anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index)) {\n      loopCount += 1;\n    } else if ((position < currentPos && anchorAtPosition.index > anchorAtCamera.index)\n      || (anchorAtPosition.position < anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index)) {\n      loopCount -= 1;\n    }\n\n    const circularIndexOffset = loopCount * panelCount;\n    const anchorAtPositionIndex = anchorAtPosition.index + circularIndexOffset;\n\n    if (Math.abs(anchorAtPositionIndex - anchorAtCamera.index) <= count) {\n      const anchor = anchors[anchorAtPosition.index];\n\n      return new AnchorPoint({\n        index: anchor.index,\n        position: anchor.position + loopCount * camera.rangeDiff,\n        panel: anchor.panel\n      });\n    }\n\n    if (flicking.circularEnabled) {\n      const targetAnchor = anchors[circulateIndex(anchorAtCamera.index + Math.sign(position - currentPos) * count, panelCount)];\n      let loop = Math.floor(count / panelCount);\n\n      if (position > currentPos && targetAnchor.index < anchorAtCamera.index) {\n        loop += 1;\n      } else if (position < currentPos && targetAnchor.index > anchorAtCamera.index) {\n        loop -= 1;\n      }\n\n      return new AnchorPoint({\n        index: targetAnchor.index,\n        position: targetAnchor.position + loop * camera.rangeDiff,\n        panel: targetAnchor.panel\n      });\n    } else {\n      return anchors[clamp(anchorAtCamera.index + Math.sign(position - currentPos) * count, 0, anchors.length - 1)];\n    }\n  }\n\n  private _findAdjacentAnchor(posDelta: number, anchorAtCamera: AnchorPoint): AnchorPoint {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const adjacentAnchor = (posDelta > 0 ? camera.getNextAnchor(anchorAtCamera) : camera.getPrevAnchor(anchorAtCamera)) ?? anchorAtCamera;\n\n    return adjacentAnchor;\n  }\n\n  private _calcSnapThreshold(position: number, activeAnchor: AnchorPoint): number {\n    const isNextDirection = position > activeAnchor.position;\n    const panel = activeAnchor.panel;\n    const panelSize = panel.size;\n    const alignPos = panel.alignPosition;\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |<------>|<------------>|\n     * [        |<-Anchor      ]\n     */\n    return isNextDirection\n      ? panelSize - alignPos + panel.margin.next\n      : alignPos + panel.margin.prev;\n  }\n}\n\nexport default SnapControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached } from \"../utils\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link FreeControl}\n * @ko {@link FreeControl} 생성시 사용되는 옵션\n * @interface\n * @property {boolean} stopAtEdge Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n * <ko>스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다</ko>\n */\nexport interface FreeControlOptions {\n  stopAtEdge: boolean;\n}\n\n/**\n * A {@link Control} that can be scrolled freely without alignment\n * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}\n */\nclass FreeControl extends Control {\n  private _stopAtEdge: FreeControlOptions[\"stopAtEdge\"];\n\n  /**\n   * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n   * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get stopAtEdge() { return this._stopAtEdge; }\n\n  public set stopAtEdge(val: FreeControlOptions[\"stopAtEdge\"]) { this._stopAtEdge = val; }\n\n  /** */\n  public constructor({\n    stopAtEdge = true\n  }: Partial<FreeControlOptions> = {}) {\n    super();\n\n    this._stopAtEdge = stopAtEdge;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public updatePosition(progressInPanel: number): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      const panelRange = activePanel.range;\n      const newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      camera.lookAt(camera.clampToReachablePosition(newPosition));\n    }\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking);\n\n    const camera = flicking.camera;\n    const targetPos = camera.clampToReachablePosition(position);\n\n    const anchorAtPosition = camera.findAnchorIncludePosition(targetPos);\n\n    if (!anchorAtPosition) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const targetPanel = anchorAtPosition.panel;\n\n    // Trigger only change event\n    if (targetPanel !== this._activePanel) {\n      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n    }\n\n    return this._animateToPosition({ position: this._stopAtEdge ? targetPos : position, duration, newActivePanel: targetPanel, axesEvent });\n  }\n}\n\nexport default FreeControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport Panel from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { clamp, getFlickingAttached, getMinusCompensatedIndex, isBetween } from \"../utils\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n/**\n * An options for the {@link StrictControl}\n * @ko {@link StrictControl} 생성시 사용되는 옵션\n * @interface\n * @property {number} count Maximum number of panels that can be moved at a time<ko>최대로 움직일 수 있는 패널의 개수</ko>\n */\nexport interface StrictControlOptions {\n  count: number;\n}\n\n/**\n * A {@link Control} that allow you to select the maximum number of panels to move at a time\n * @ko 한번에 최대로 이동할 패널의 개수를 선택 가능한 {@link Control}\n */\nclass StrictControl extends Control {\n  private _count: number;\n  private _indexRange: { min: number; max: number };\n\n  /**\n   * Maximum number of panels that can be moved at a time\n   * @ko 최대로 움직일 수 있는 패널의 개수\n   * @type {number}\n   * @default 1\n   */\n  public get count() { return this._count; }\n\n  public set count(val: StrictControlOptions[\"count\"]) { this._count = val; }\n\n  /** */\n  public constructor({\n    count = 1\n  }: Partial<StrictControlOptions> = {}) {\n    super();\n\n    this._count = count;\n    this._resetIndexRange();\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy() {\n    super.destroy();\n\n    this._resetIndexRange();\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const renderer = flicking.renderer;\n    const controller = this._controller;\n    const controlParams = camera.controlParams;\n    const count = this._count;\n\n    const activePanel = controller.state.animating\n      ? camera.findNearestAnchor(camera.position)?.panel\n      : this._activePanel;\n\n    if (!activePanel) {\n      controller.update(controlParams);\n      this._resetIndexRange();\n      return this;\n    }\n\n    const cameraRange = controlParams.range;\n    const currentPos = activePanel.position;\n    const currentIndex = activePanel.index;\n    const panelCount = renderer.panelCount;\n\n    let prevPanelIndex = currentIndex - count;\n    let nextPanelIndex = currentIndex + count;\n\n    if (prevPanelIndex < 0) {\n      prevPanelIndex = flicking.circularEnabled\n        ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount)\n        : clamp(prevPanelIndex, 0, panelCount - 1);\n    }\n    if (nextPanelIndex >= panelCount) {\n      nextPanelIndex = flicking.circularEnabled\n        ? nextPanelIndex % panelCount\n        : clamp(nextPanelIndex, 0, panelCount - 1);\n    }\n\n    const prevPanel = renderer.panels[prevPanelIndex];\n    const nextPanel = renderer.panels[nextPanelIndex];\n\n    let prevPos = Math.max(prevPanel.position, cameraRange.min);\n    let nextPos = Math.min(nextPanel.position, cameraRange.max);\n\n    if (prevPos > currentPos) {\n      prevPos -= camera.rangeDiff;\n    }\n    if (nextPos < currentPos) {\n      nextPos += camera.rangeDiff;\n    }\n\n    controlParams.range = {\n      min: prevPos,\n      max: nextPos\n    };\n\n    if (controlParams.circular) {\n      if (controlParams.position < prevPos) {\n        controlParams.position += camera.rangeDiff;\n      }\n\n      if (controlParams.position > nextPos) {\n        controlParams.position -= camera.rangeDiff;\n      }\n    }\n\n    controlParams.circular = false;\n    controller.update(controlParams);\n\n    this._indexRange = {\n      min: prevPanel.index,\n      max: nextPanel.index\n    };\n\n    return this;\n  }\n\n  public async moveToPanel(panel: Panel, options: Parameters<Control[\"moveToPanel\"]>[1]): Promise<void> {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const controller = this._controller;\n\n    controller.update(camera.controlParams);\n\n    return super.moveToPanel(panel, options);\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n    const axesRange = this._controller.range;\n    const indexRange = this._indexRange;\n    const cameraRange = camera.range;\n\n    const clampedPosition = clamp(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);\n    const anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtPosition || !activePanel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const prevPos = activePanel.position;\n\n    const isOverThreshold = Math.abs(position - prevPos) >= flicking.threshold;\n    const adjacentAnchor = (position > prevPos)\n      ? camera.getNextAnchor(anchorAtPosition)\n      : camera.getPrevAnchor(anchorAtPosition);\n\n    let targetPos: number;\n    let targetPanel: Panel;\n\n    const anchors = camera.anchorPoints;\n    const firstAnchor = anchors[0];\n    const lastAnchor = anchors[anchors.length - 1];\n\n    const shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);\n    const shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);\n\n    if (shouldBounceToFirst || shouldBounceToLast) {\n      // In bounce area\n      const targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;\n\n      targetPanel = targetAnchor.panel;\n      targetPos = targetAnchor.position;\n    } else if (isOverThreshold && anchorAtPosition.position !== activePanel.position) {\n      // Move to anchor at position\n      targetPanel = anchorAtPosition.panel;\n      targetPos = anchorAtPosition.position;\n    } else if (isOverThreshold && adjacentAnchor && isBetween(adjacentAnchor.index, indexRange.min, indexRange.max)) {\n      // Move to adjacent anchor\n      targetPanel = adjacentAnchor.panel;\n      targetPos = adjacentAnchor.position;\n    } else {\n      // Restore to active panel\n      targetPos = camera.clampToReachablePosition(activePanel.position);\n      targetPanel = activePanel;\n    }\n\n    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: targetPos,\n      duration,\n      newActivePanel: targetPanel,\n      axesEvent\n    });\n  }\n\n  public setActive = (newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) => {\n    super.setActive(newActivePanel, prevActivePanel, isTrusted);\n    this.updateInput();\n  };\n\n  private _resetIndexRange() {\n    this._indexRange = { min: 0, max: 0 };\n  }\n}\n\nexport default StrictControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Control from \"./Control\";\nimport SnapControl, { SnapControlOptions } from \"./SnapControl\";\nimport FreeControl, { FreeControlOptions } from \"./FreeControl\";\nimport StrictControl, { StrictControlOptions } from \"./StrictControl\";\nimport AxesController from \"./AxesController\";\nimport State from \"./states/State\";\nimport IdleState from \"./states/IdleState\";\nimport HoldingState from \"./states/HoldingState\";\nimport DraggingState from \"./states/DraggingState\";\nimport AnimatingState from \"./states/AnimatingState\";\nimport DisabledState from \"./states/DisabledState\";\nimport StateMachine from \"./StateMachine\";\n\nexport {\n  Control,\n  SnapControl,\n  FreeControl,\n  StrictControl,\n  AxesController,\n  State,\n  IdleState,\n  HoldingState,\n  DraggingState,\n  AnimatingState,\n  DisabledState,\n  StateMachine\n};\n\nexport type {\n  SnapControlOptions,\n  FreeControlOptions,\n  StrictControlOptions\n};\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport Panel from \"../../core/panel/Panel\";\nimport AnchorPoint from \"../../core/AnchorPoint\";\nimport { clamp } from \"../../utils\";\n\n/**\n * A mode of camera\n */\nabstract class CameraMode {\n  protected _flicking: Flicking;\n\n  /** */\n  public constructor(flicking: Flicking) {\n    this._flicking = flicking;\n  }\n\n  public abstract checkAvailability(): boolean;\n  public abstract getRange(): { min: number; max: number };\n\n  public getAnchors(): AnchorPoint[] {\n    const panels = this._flicking.renderer.panels;\n\n    return panels.map((panel, index) => new AnchorPoint({\n      index,\n      position: panel.position,\n      panel\n    }));\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const anchors = this._flicking.camera.anchorPoints;\n    const anchorsIncludingPosition = anchors.filter(anchor => anchor.panel.includePosition(position, true));\n\n    return anchorsIncludingPosition.reduce((nearest: AnchorPoint | null, anchor) => {\n      if (!nearest) return anchor;\n\n      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position)\n        ? nearest\n        : anchor;\n    }, null);\n  }\n\n  public clampToReachablePosition(position: number): number {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n\n    return clamp(position, range.min, range.max);\n  }\n\n  public getCircularOffset(): number {\n    return 0;\n  }\n\n  public canReach(panel: Panel): boolean {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n\n    if (panel.removed) return false;\n\n    const panelPos = panel.position;\n\n    return panelPos >= range.min && panelPos <= range.max;\n  }\n\n  public canSee(panel: Panel): boolean {\n    const camera = this._flicking.camera;\n    const visibleRange = camera.visibleRange;\n    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.\n    return panel.isVisibleOnRange(visibleRange.min, visibleRange.max);\n  }\n}\n\nexport default CameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport CameraMode from \"./CameraMode\";\n\nclass LinearCameraMode extends CameraMode {\n  public checkAvailability(): boolean {\n    // It's always available\n    return true;\n  }\n\n  public getRange(): { min: number; max: number } {\n    const renderer = this._flicking.renderer;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    return { min: firstPanel?.position ?? 0, max: lastPanel?.position ?? 0 };\n  }\n}\n\nexport default LinearCameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../../core/panel/Panel\";\nimport AnchorPoint from \"../../core/AnchorPoint\";\nimport { DIRECTION } from \"../../const/external\";\nimport { circulatePosition } from \"../../utils\";\n\nimport CameraMode from \"./CameraMode\";\n\n/**\n * A {@link Camera} mode that connects the last panel and the first panel, enabling continuous loop\n * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera} 모드\n */\nclass CircularCameraMode extends CameraMode {\n  public checkAvailability(): boolean {\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panels = renderer.panels;\n\n    if (panels.length <= 0) {\n      return false;\n    }\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    const lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n\n    const visibleSize = flicking.camera.size;\n    const panelSizeSum = lastPanelNext - firstPanelPrev;\n\n    const canSetCircularMode = panels\n      .every(panel => panelSizeSum - panel.size >= visibleSize);\n\n    return canSetCircularMode;\n  }\n\n  public getRange(): { min: number; max: number } {\n    const flicking = this._flicking;\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      return { min: 0, max: 0 };\n    }\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    const lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n\n    return { min: firstPanelPrev, max: lastPanelNext };\n  }\n\n  public getAnchors(): AnchorPoint[] {\n    const flicking = this._flicking;\n    const panels = flicking.renderer.panels;\n\n    return panels.map((panel, index) => new AnchorPoint({\n      index,\n      position: panel.position,\n      panel\n    }));\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n    const anchors = camera.anchorPoints;\n    const rangeDiff = camera.rangeDiff;\n    const anchorCount = anchors.length;\n    const positionInRange = circulatePosition(position, range.min, range.max);\n\n    let anchorInRange: AnchorPoint | null = super.findAnchorIncludePosition(positionInRange);\n\n    if (anchorCount > 0 && (position === range.min || position === range.max)) {\n      const possibleAnchors = [\n        anchorInRange,\n        new AnchorPoint({\n          index: 0,\n          position: anchors[0].position + rangeDiff,\n          panel: anchors[0].panel\n        }),\n        new AnchorPoint({\n          index: anchorCount - 1,\n          position: anchors[anchorCount - 1].position - rangeDiff,\n          panel: anchors[anchorCount - 1].panel\n        })\n      ].filter(anchor => !!anchor) as AnchorPoint[];\n\n      anchorInRange = possibleAnchors.reduce((nearest: AnchorPoint | null, anchor) => {\n        if (!nearest) return anchor;\n\n        return Math.abs(nearest.position - position) < Math.abs(anchor.position - position)\n          ? nearest\n          : anchor;\n      }, null);\n    }\n\n    if (!anchorInRange) return null;\n\n    if (position < range.min) {\n      const loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    } else if (position > range.max) {\n      const loopCount = Math.floor((position - range.max) / rangeDiff) + 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    }\n\n    return anchorInRange;\n  }\n\n  public getCircularOffset(): number {\n    const flicking = this._flicking;\n    const camera = flicking.camera;\n\n    if (!camera.circularEnabled) return 0;\n\n    const toggled = flicking.panels.filter(panel => panel.toggled);\n    const toggledPrev = toggled.filter(panel => panel.toggleDirection === DIRECTION.PREV);\n    const toggledNext = toggled.filter(panel => panel.toggleDirection === DIRECTION.NEXT);\n\n    return this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);\n  }\n\n  public clampToReachablePosition(position: number): number {\n    // Basically all position is reachable for circular camera\n    return position;\n  }\n\n  public canReach(panel: Panel): boolean {\n    if (panel.removed) return false;\n\n    // Always reachable on circular mode\n    return true;\n  }\n\n  public canSee(panel: Panel): boolean {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n    const rangeDiff = camera.rangeDiff;\n    const visibleRange = camera.visibleRange;\n    const visibleInCurrentRange = super.canSee(panel);\n\n    // Check looped visible area for circular case\n    if (visibleRange.min < range.min) {\n      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff);\n    } else if (visibleRange.max > range.max) {\n      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff);\n    }\n\n    return visibleInCurrentRange;\n  }\n\n  private _calcPanelAreaSum(panels: Panel[]) {\n    return panels.reduce((sum: number, panel: Panel) => sum + panel.sizeIncludingMargin, 0);\n  }\n}\n\nexport default CircularCameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport AnchorPoint from \"../../core/AnchorPoint\";\nimport Panel from \"../../core/panel/Panel\";\nimport { parseAlign } from \"../../utils\";\n\nimport CameraMode from \"./CameraMode\";\n\nclass BoundCameraMode extends CameraMode {\n  public checkAvailability(): boolean {\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      return false;\n    }\n\n    const viewportSize = flicking.camera.size;\n    const firstPanelPrev = firstPanel.range.min;\n    const lastPanelNext = lastPanel.range.max;\n    const panelAreaSize = lastPanelNext - firstPanelPrev;\n    const isBiggerThanViewport = viewportSize < panelAreaSize;\n\n    return isBiggerThanViewport;\n  }\n\n  public getRange(): { min: number; max: number } {\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const alignPos = flicking.camera.alignPosition;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      return { min: 0, max: 0 };\n    }\n\n    const viewportSize = flicking.camera.size;\n    const firstPanelPrev = firstPanel.range.min;\n    const lastPanelNext = lastPanel.range.max;\n    const panelAreaSize = lastPanelNext - firstPanelPrev;\n    const isBiggerThanViewport = viewportSize < panelAreaSize;\n\n    const firstPos = firstPanelPrev + alignPos;\n    const lastPos = lastPanelNext - viewportSize + alignPos;\n\n    if (isBiggerThanViewport) {\n      return { min: firstPos, max: lastPos };\n    } else {\n      const align = flicking.camera.align;\n      const alignVal = typeof align === \"object\"\n        ? (align as { camera: string | number }).camera\n        : align;\n\n      const pos = firstPos + parseAlign(alignVal, lastPos - firstPos);\n\n      return { min: pos, max: pos };\n    }\n  }\n\n  public getAnchors(): AnchorPoint[] {\n    const flicking = this._flicking;\n    const camera = flicking.camera;\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const range = flicking.camera.range;\n    const reachablePanels = panels.filter(panel => camera.canReach(panel));\n\n    if (reachablePanels.length > 0) {\n      const shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;\n      const shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;\n      const indexOffset = shouldPrependBoundAnchor ? 1 : 0;\n\n      const newAnchors = reachablePanels.map((panel, idx) => new AnchorPoint({\n        index: idx + indexOffset,\n        position: panel.position,\n        panel\n      }));\n\n      if (shouldPrependBoundAnchor) {\n        newAnchors.splice(0, 0, new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panels[reachablePanels[0].index - 1]\n        }));\n      }\n\n      if (shouldAppendBoundAnchor) {\n        newAnchors.push(new AnchorPoint({\n          index: newAnchors.length,\n          position: range.max,\n          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]\n        }));\n      }\n\n      return newAnchors;\n    } else if (range.min !== range.max) {\n      // There're more than 2 panels\n      const nearestPanelAtMin = this._findNearestPanel(range.min, panels);\n      const panelAtMin = nearestPanelAtMin.index === panels.length - 1\n        ? nearestPanelAtMin.prev()!\n        : nearestPanelAtMin;\n      const panelAtMax = panelAtMin.next()!;\n\n      return [\n        new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panelAtMin\n        }),\n        new AnchorPoint({\n          index: 1,\n          position: range.max,\n          panel: panelAtMax\n        })\n      ];\n    } else {\n      return [new AnchorPoint({\n        index: 0,\n        position: range.min,\n        panel: this._findNearestPanel(range.min, panels)\n      })];\n    }\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n    const anchors = camera.anchorPoints;\n\n    if (anchors.length <= 0) return null;\n\n    if (position <= range.min) {\n      return anchors[0];\n    } else if (position >= range.max) {\n      return anchors[anchors.length - 1];\n    } else {\n      return super.findAnchorIncludePosition(position);\n    }\n  }\n\n  private _findNearestPanel(pos: number, panels: Panel[]): Panel {\n    let prevDist = Infinity;\n    for (let panelIdx = 0; panelIdx < panels.length; panelIdx++) {\n      const panel = panels[panelIdx];\n      const dist = Math.abs(panel.position - pos);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return panels[panelIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return panels[panels.length - 1];\n  }\n}\n\nexport default BoundCameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport * as ERROR from \"../const/error\";\nimport { ALIGN, CIRCULAR_FALLBACK, DIRECTION, EVENTS } from \"../const/external\";\nimport { checkExistence, find, getFlickingAttached, getProgress, includes, parseAlign, toArray } from \"../utils\";\n\nimport { CameraMode, BoundCameraMode, CircularCameraMode, LinearCameraMode } from \"./mode\";\n\nexport interface CameraOptions {\n  align: FlickingOptions[\"align\"];\n}\n\n/**\n * A component that manages actual movement inside the viewport\n * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트\n */\nclass Camera {\n  // Options\n  private _align: FlickingOptions[\"align\"];\n\n  // Internal states\n  private _flicking: Flicking;\n  private _mode: CameraMode;\n  private _el: HTMLElement;\n  private _transform: string;\n  private _position: number;\n  private _alignPos: number;\n  private _offset: number;\n  private _circularOffset: number;\n  private _circularEnabled: boolean;\n  private _range: { min: number; max: number };\n  private _visiblePanels: Panel[];\n  private _anchors: AnchorPoint[];\n  private _needPanelTriggered: { prev: boolean; next: boolean };\n\n  // Internal states getter\n  /**\n   * The camera element(`.flicking-camera`)\n   * @ko 카메라 엘리먼트(`.flicking-camera`)\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n  /**\n   * An array of the child elements of the camera element(`.flicking-camera`)\n   * @ko 카메라 엘리먼트(`.flicking-camera`)의 자식 엘리먼트 배열\n   * @type {HTMLElement[]}\n   * @readonly\n   */\n  public get children() { return toArray(this._el.children) as HTMLElement[]; }\n  /**\n   * Current position of the camera\n   * @ko Camera의 현재 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._position; }\n  /**\n   * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at\n   * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option\n   * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get offset() { return this._offset - this._circularOffset; }\n  /**\n   * Whether the `circular` option is enabled.\n   * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\n   * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get circularEnabled() { return this._circularEnabled; }\n  /**\n   * A current camera mode\n   * @type {CameraMode}\n   * @readonly\n   */\n  public get mode() { return this._mode; }\n  /**\n   * A range that Camera's {@link Camera#position position} can reach\n   * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} max A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get range() { return this._range; }\n  /**\n   * A difference between Camera's minimum and maximum position that can reach\n   * @ko Camera가 도달 가능한 최소/최대 좌표의 차이\n   * @type {number}\n   * @readonly\n   */\n  public get rangeDiff() { return this._range.max - this._range.min; }\n  /**\n   * An array of visible panels from the current position\n   * @ko 현재 보이는 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   */\n  public get visiblePanels() { return this._visiblePanels; }\n  /**\n   * A range of the visible area from the current position\n   * @ko 현재 위치에서 보이는 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get visibleRange() { return { min: this._position - this._alignPos, max: this._position - this._alignPos + this.size }; }\n  /**\n   * An array of {@link AnchorPoint}s that Camera can be stopped at\n   * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록\n   * @type {AnchorPoint[]}\n   * @readonly\n   */\n  public get anchorPoints() { return this._anchors; }\n  /**\n   * A current parameters of the Camera for updating {@link AxesController}\n   * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들\n   * @type {ControlParams}\n   * @readonly\n   */\n  public get controlParams() { return { range: this._range, position: this._position, circular: this._circularEnabled }; }\n  /**\n   * A Boolean value indicating whether Camera's over the minimum or maximum position reachable\n   * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다\n   * @type {boolean}\n   * @readonly\n   */\n  public get atEdge() { return this._position <= this._range.min || this._position >= this._range.max; }\n  /**\n   * Return the size of the viewport\n   * @ko 뷰포트 크기를 반환합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() {\n    const flicking = this._flicking;\n    return flicking\n      ? flicking.horizontal\n        ? flicking.viewport.width\n        : flicking.viewport.height\n      : 0;\n  }\n\n  /**\n   * Return the camera's position progress from the first panel to last panel\n   * Range is from 0 to last panel's index\n   * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다\n   * 범위는 0부터 마지막 패널의 인덱스까지입니다\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n    const position = this._position + this._offset;\n    const nearestAnchor = this.findNearestAnchor(this._position);\n\n    if (!flicking || !nearestAnchor) {\n      return NaN;\n    }\n\n    const nearestPanel = nearestAnchor.panel;\n    const panelPos = nearestPanel.position + nearestPanel.offset;\n    const bounceSize = flicking.control.controller.bounce!;\n\n    const { min: prevRange, max: nextRange } = this.range;\n    const rangeDiff = this.rangeDiff;\n\n    if (position === panelPos) {\n      return nearestPanel.index;\n    }\n\n    if (position < panelPos) {\n      const prevPanel = nearestPanel.prev();\n      let prevPosition = prevPanel\n        ? prevPanel.position + prevPanel.offset\n        : prevRange - bounceSize[0];\n\n      // Looped\n      if (prevPosition > panelPos) {\n        prevPosition -= rangeDiff;\n      }\n\n      return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);\n    } else {\n      const nextPanel = nearestPanel.next();\n      let nextPosition = nextPanel\n        ? nextPanel.position + nextPanel.offset\n        : nextRange + bounceSize[1];\n\n      // Looped\n      if (nextPosition < panelPos) {\n        nextPosition += rangeDiff;\n      }\n\n      return nearestPanel.index + getProgress(position, panelPos, nextPosition);\n    }\n  }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element\n   * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n  }\n\n  /** */\n  public constructor(flicking: Flicking, {\n    align = ALIGN.CENTER\n  }: Partial<CameraOptions> = {}) {\n    this._flicking = flicking;\n    this._resetInternalValues();\n\n    // Options\n    this._align = align;\n  }\n\n  /**\n   * Initialize Camera\n   * @ko Camera를 초기화합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element\n   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>\n   * @return {this}\n   */\n  public init(): this {\n    const viewportEl = this._flicking.viewport.element;\n\n    checkExistence(viewportEl.firstElementChild, \"First element child of the viewport element\");\n    this._el = viewportEl.firstElementChild as HTMLElement;\n    this._checkTranslateSupport();\n\n    this._updateMode();\n\n    return this;\n  }\n\n  /**\n   * Destroy Camera and return to initial state\n   * @ko Camera를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): this {\n    this._resetInternalValues();\n    return this;\n  }\n\n  /**\n   * Move to the given position and apply CSS transform\n   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다\n   * @param {number} pos A new position<ko>움직일 위치</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public lookAt(pos: number): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const prevPos = this._position;\n\n    this._position = pos;\n    const toggled = this._togglePanels(prevPos, pos);\n    this._refreshVisiblePanels();\n    this._checkNeedPanel();\n    this._checkReachEnd(prevPos, pos);\n\n    if (toggled) {\n      void flicking.renderer.render().then(() => {\n        this.updateOffset();\n      });\n    } else {\n      this.applyTransform();\n    }\n  }\n\n  /**\n   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>\n   */\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    if (!this._circularEnabled || anchor.index !== 0) {\n      return this._anchors[anchor.index - 1] || null;\n    } else {\n      const anchors = this._anchors;\n      const rangeDiff = this.rangeDiff;\n      const lastAnchor = anchors[anchors.length - 1];\n\n      return new AnchorPoint({\n        index: lastAnchor.index,\n        position: lastAnchor.position - rangeDiff,\n        panel: lastAnchor.panel\n      });\n    }\n  }\n\n  /**\n   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>\n   */\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (!this._circularEnabled || anchor.index !== anchors.length - 1) {\n      return anchors[anchor.index + 1] || null;\n    } else {\n      const rangeDiff = this.rangeDiff;\n      const firstAnchor = anchors[0];\n\n      return new AnchorPoint({\n        index: firstAnchor.index,\n        position: firstAnchor.position + rangeDiff,\n        panel: firstAnchor.panel\n      });\n    }\n  }\n\n  /**\n   * Return the camera's position progress in the panel below\n   * Value is from 0 to 1 when the camera's inside panel\n   * Value can be lower than 0 or bigger than 1 when it's in the margin area\n   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다\n   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다\n   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다\n   */\n  public getProgressInPanel(panel: Panel) {\n    const panelRange = panel.range;\n\n    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);\n  }\n\n  /**\n   * Return {@link AnchorPoint} that includes given position\n   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead\n   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다\n   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>\n   */\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    return this._mode.findAnchorIncludePosition(position);\n  }\n\n  /**\n   * Return {@link AnchorPoint} nearest to given position\n   * If there're no {@link AnchorPoint}s, return `null` instead\n   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다\n   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>\n   */\n  public findNearestAnchor(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (anchors.length <= 0) return null;\n\n    let prevDist = Infinity;\n    for (let anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {\n      const anchor = anchors[anchorIdx];\n      const dist = Math.abs(anchor.position - position);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return anchors[anchorIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return anchors[anchors.length - 1];\n  }\n\n  /**\n   * Return {@link AnchorPoint} that matches {@link Flicking#currentPanel}\n   * @ko 현재 {@link Flicking#currentPanel}에 해당하는 {@link AnchorPoint}를 반환합니다\n   * @return {AnchorPoint | null}\n   */\n  public findActiveAnchor(): AnchorPoint | null {\n    const flicking = getFlickingAttached(this._flicking);\n    const activeIndex = flicking.control.activeIndex;\n\n    return find(this._anchors, anchor => anchor.panel.index === activeIndex);\n  }\n\n  /**\n   * Clamp the given position between camera's range\n   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다\n   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>\n   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>\n   */\n  public clampToReachablePosition(position: number): number {\n    return this._mode.clampToReachablePosition(position);\n  }\n\n  /**\n   * Check whether the given panel is inside of the Camera's range\n   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>\n   */\n  public canReach(panel: Panel): boolean {\n    return this._mode.canReach(panel);\n  }\n\n  /**\n   * Check whether the given panel element is visible at the current position\n   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>\n   */\n  public canSee(panel: Panel): boolean {\n    return this._mode.canSee(panel);\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @method\n   * @abstract\n   * @memberof Camera\n   * @instance\n   * @name updateRange\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking);\n    const renderer = flicking.renderer;\n    const panels = renderer.panels;\n\n    this._updateMode();\n    this._range = this._mode.getRange();\n\n    if (this._circularEnabled) {\n      panels.forEach(panel => panel.updateCircularToggleDirection());\n    }\n\n    return this;\n  }\n\n  /**\n   * Update Camera's {@link Camera#alignPosition alignPosition}\n   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateAlignPos(): this {\n    const align = this._align;\n\n    const alignVal = typeof align === \"object\"\n      ? (align as { camera: string | number }).camera\n      : align;\n\n    this._alignPos = parseAlign(alignVal, this.size);\n\n    return this;\n  }\n\n  /**\n   * Update Camera's {@link Camera#anchorPoints anchorPoints}\n   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAnchors(): this {\n    this._anchors = this._mode.getAnchors();\n\n    return this;\n  }\n\n  /**\n   * Update Viewport's height to active panel's height\n   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAdaptiveHeight() {\n    const flicking = getFlickingAttached(this._flicking);\n    const activePanel = flicking.control.activePanel;\n\n    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;\n\n    flicking.viewport.setSize({\n      height: activePanel.height\n    });\n  }\n\n  /**\n   * Update current offset of the camera\n   * @ko 현재 카메라의 오프셋을 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateOffset(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const position = this._position;\n    const unRenderedPanels = flicking.panels.filter(panel => !panel.rendered);\n\n    this._offset = unRenderedPanels\n      .filter(panel => panel.position + panel.offset < position)\n      .reduce((offset, panel) => offset + panel.sizeIncludingMargin, 0);\n\n    this._circularOffset = this._mode.getCircularOffset();\n\n    this.applyTransform();\n\n    return this;\n  }\n\n  /**\n   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again\n   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetNeedPanelHistory(): this {\n    this._needPanelTriggered = { prev: false, next: false };\n    return this;\n  }\n\n  /**\n   * Apply \"transform\" style with the current position to camera element\n   * @ko 현재 위치를 기준으로한 transform 스타일을 카메라 엘리먼트에 적용합니다.\n   * @return {this}\n   */\n  public applyTransform(): this {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking);\n    const renderer = flicking.renderer;\n\n    if (renderer.rendering) return this;\n\n    const actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n\n    return this;\n  }\n\n  private _resetInternalValues() {\n    this._position = 0;\n    this._alignPos = 0;\n    this._offset = 0;\n    this._circularOffset = 0;\n    this._circularEnabled = false;\n    this._range = { min: 0, max: 0 };\n    this._visiblePanels = [];\n    this._anchors = [];\n    this._needPanelTriggered = { prev: false, next: false };\n  }\n\n  private _refreshVisiblePanels() {\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = flicking.renderer.panels;\n\n    const newVisiblePanels = panels.filter(panel => this.canSee(panel));\n    const prevVisiblePanels = this._visiblePanels;\n    this._visiblePanels = newVisiblePanels;\n\n    const added: Panel[] = newVisiblePanels.filter(panel => !includes(prevVisiblePanels, panel));\n    const removed: Panel[] = prevVisiblePanels.filter(panel => !includes(newVisiblePanels, panel));\n\n    if (added.length > 0 || removed.length > 0) {\n      void flicking.renderer.render().then(() => {\n        flicking.trigger(new ComponentEvent(EVENTS.VISIBLE_CHANGE, {\n          added,\n          removed,\n          visiblePanels: newVisiblePanels\n        }));\n      });\n    }\n  }\n\n  private _checkNeedPanel(): void {\n    const needPanelTriggered = this._needPanelTriggered;\n\n    if (needPanelTriggered.prev && needPanelTriggered.next) return;\n\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      if (!needPanelTriggered.prev) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n      if (!needPanelTriggered.next) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n\n      return;\n    }\n\n    const cameraPosition = this._position;\n    const cameraSize = this.size;\n    const cameraRange = this._range;\n    const needPanelThreshold = flicking.needPanelThreshold;\n\n    const cameraPrev = cameraPosition - this._alignPos;\n    const cameraNext = cameraPrev + cameraSize;\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n\n    if (!needPanelTriggered.prev) {\n      const firstPanelPrev = firstPanel.range.min;\n\n      if (cameraPrev <= (firstPanelPrev + needPanelThreshold) || cameraPosition <= (cameraRange.min + needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n    }\n\n    if (!needPanelTriggered.next) {\n      const lastPanelNext = lastPanel.range.max;\n\n      if (cameraNext >= (lastPanelNext - needPanelThreshold) || cameraPosition >= (cameraRange.max - needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n    }\n  }\n\n  private _checkReachEnd(prevPos: number, newPos: number): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const range = this._range;\n\n    const wasBetweenRange = prevPos > range.min && prevPos < range.max;\n    const isBetweenRange = newPos > range.min && newPos < range.max;\n\n    if (!wasBetweenRange || isBetweenRange) return;\n\n    const direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;\n\n    flicking.trigger(new ComponentEvent(EVENTS.REACH_EDGE, {\n      direction\n    }));\n  }\n\n  private _checkTranslateSupport = () => {\n    const transforms = [\"webkitTransform\", \"msTransform\", \"MozTransform\", \"OTransform\", \"transform\"];\n\n    const supportedStyle = document.documentElement.style;\n    let transformName = \"\";\n    for (const prefixedTransform of transforms) {\n      if (prefixedTransform in supportedStyle) {\n        transformName = prefixedTransform;\n      }\n    }\n\n    if (!transformName) {\n      throw new FlickingError(ERROR.MESSAGE.TRANSFORM_NOT_SUPPORTED, ERROR.CODE.TRANSFORM_NOT_SUPPORTED);\n    }\n\n    this._transform = transformName;\n  };\n\n  private _updateMode() {\n    const flicking = getFlickingAttached(this._flicking);\n\n    if (flicking.circular) {\n      const circularMode = new CircularCameraMode(flicking);\n      const canSetCircularMode = circularMode.checkAvailability();\n\n      if (canSetCircularMode) {\n        this._mode = circularMode;\n      } else {\n        const fallbackMode = flicking.circularFallback;\n\n        this._mode = fallbackMode === CIRCULAR_FALLBACK.BOUND\n          ? new BoundCameraMode(flicking)\n          : new LinearCameraMode(flicking);\n      }\n\n      this._circularEnabled = canSetCircularMode;\n    } else {\n      this._mode = flicking.bound\n        ? new BoundCameraMode(flicking)\n        : new LinearCameraMode(flicking);\n    }\n  }\n\n  private _togglePanels(prevPos: number, pos: number): boolean {\n    if (pos === prevPos) return false;\n\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = flicking.renderer.panels;\n    const toggled = panels.map(panel => panel.toggle(prevPos, pos));\n\n    return toggled.some(isToggled => isToggled);\n  }\n}\n\nexport default Camera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Camera, { CameraOptions } from \"./Camera\";\n\nexport {\n  Camera\n};\n\nexport type {\n  CameraOptions\n};\n\nexport * from \"./mode\";\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\nimport ImReady from \"@egjs/imready\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { ALIGN, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached, getMinusCompensatedIndex, includes, parsePanelAlign } from \"../utils\";\n\nimport RenderingStrategy from \"./strategy/RenderingStrategy\";\n\nexport interface RendererOptions {\n  align?: FlickingOptions[\"align\"];\n  strategy: RenderingStrategy;\n}\n\n/**\n * A component that manages {@link Panel} and its elements\n * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트\n */\nabstract class Renderer {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _panels: Panel[];\n  protected _rendering: boolean;\n\n  // Options\n  protected _align: NonNullable<RendererOptions[\"align\"]>;\n  protected _strategy: RendererOptions[\"strategy\"];\n\n  // Internal states Getter\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._panels; }\n  /**\n   * A boolean value indicating whether rendering is in progress\n   * @ko 현재 렌더링이 시작되어 끝나기 전까지의 상태인지의 여부\n   * @type {boolean}\n   * @readonly\n   * @internal\n   */\n  public get rendering() { return this._rendering; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._panels.length; }\n  /**\n   * @internal\n   */\n  public get strategy() { return this._strategy; }\n\n  // Options Getter\n  /**\n   * A {@link Panel}'s {@link Panel#align align} value that applied to all panels\n   * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: NonNullable<RendererOptions[\"align\"]>) {\n    this._align = val;\n\n    const panelAlign = parsePanelAlign(val);\n    this._panels.forEach(panel => { panel.align = panelAlign; });\n  }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {Constants.ALIGN | string | number} [options.align=\"center\"] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>\n   * @param {object} [options.strategy] An instance of RenderingStrategy(internal module)<ko>RenderingStrategy의 인스턴스(내부 모듈)</ko>\n   */\n  public constructor({\n    align = ALIGN.CENTER,\n    strategy\n  }: RendererOptions) {\n    this._flicking = null;\n    this._panels = [];\n    this._rendering = false;\n\n    // Bind options\n    this._align = align;\n    this._strategy = strategy;\n  }\n\n  /**\n   * Render panel elements inside the camera element\n   * @ko 패널 엘리먼트들을 카메라 엘리먼트 내부에 렌더링합니다\n   * @method\n   * @abstract\n   * @memberof Renderer\n   * @instance\n   * @name render\n   * @chainable\n   * @return {this}\n   */\n  public abstract render(): Promise<void>;\n\n  protected abstract _collectPanels(): void;\n  protected abstract _createPanel(el: any, options: Omit<PanelOptions, \"elementProvider\">): Panel;\n\n  /**\n   * Initialize Renderer\n   * @ko Renderer를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._collectPanels();\n\n    return this;\n  }\n\n  /**\n   * Destroy Renderer and return to initial state\n   * @ko Renderer를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._flicking = null;\n    this._panels = [];\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   */\n  public getPanel(index: number): Panel | null {\n    return this._panels[index] || null;\n  }\n\n  public forceRenderAllPanels(): Promise<void> {\n    this._panels.forEach(panel => panel.markForShow());\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Update all panel sizes\n   * @ko 모든 패널의 크기를 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updatePanelSize(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = this._panels;\n\n    if (panels.length <= 0) return this;\n\n    if (flicking.panelsPerView > 0) {\n      const firstPanel = panels[0];\n      firstPanel.resize();\n\n      this._updatePanelSizeByGrid(firstPanel, panels);\n    } else {\n      flicking.panels.forEach(panel => panel.resize());\n    }\n\n    return this;\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {Array<object>} items An array of items to insert<ko>추가할 아이템들의 배열</ko>\n   * @param {number} [items.index] Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {any[]} [items.elements] An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>\n   * @param {boolean} [items.hasDOMInElements] Whether it contains actual DOM elements. If set to true, renderer will add them to the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에 추가합니다</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   */\n  public batchInsert(...items: Array<{\n    index: number;\n    elements: any[];\n    hasDOMInElements: boolean;\n  }>): Panel[] {\n    const allPanelsInserted = this.batchInsertDefer(...items);\n\n    if (allPanelsInserted.length <= 0) return [];\n\n    this.updateAfterPanelChange(allPanelsInserted, []);\n\n    return allPanelsInserted;\n  }\n\n  /**\n   * Defers update\n   * camera position & others will be updated after calling updateAfterPanelChange\n   * @internal\n   */\n  public batchInsertDefer(...items: Array<{\n    index: number;\n    elements: any[];\n    hasDOMInElements: boolean;\n  }>) {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking);\n\n    const prevFirstPanel = panels[0];\n    const align = parsePanelAlign(this._align);\n\n    const allPanelsInserted = items.reduce((addedPanels, item) => {\n      const insertingIdx = getMinusCompensatedIndex(item.index, panels.length);\n      const panelsPushed = panels.slice(insertingIdx);\n      const panelsInserted = item.elements.map((el, idx) => this._createPanel(el, { index: insertingIdx + idx, align, flicking }));\n\n      panels.splice(insertingIdx, 0, ...panelsInserted);\n\n      if (item.hasDOMInElements) {\n        // Insert the actual elements as camera element's children\n        this._insertPanelElements(panelsInserted, panelsPushed[0] ?? null);\n      }\n\n      // Resize the newly added panels\n      if (flicking.panelsPerView > 0) {\n        const firstPanel = prevFirstPanel || panelsInserted[0].resize();\n\n        this._updatePanelSizeByGrid(firstPanel, panelsInserted);\n      } else {\n        panelsInserted.forEach(panel => panel.resize());\n      }\n\n      // Update panel indexes & positions\n      panelsPushed.forEach(panel => {\n        panel.increaseIndex(panelsInserted.length);\n        panel.updatePosition();\n      });\n\n      return [...addedPanels, ...panelsInserted];\n    }, []);\n\n    return allPanelsInserted;\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {Array<object>} items An array of items to remove<ko>제거할 아이템들의 배열</ko>\n   * @param {number} [items.index] Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [items.deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @param {boolean} [items.hasDOMInElements=1] Whether it contains actual DOM elements. If set to true, renderer will remove them from the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에서 제거합니다</ko>\n   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public batchRemove(...items: Array<{\n    index: number;\n    deleteCount: number;\n    hasDOMInElements: boolean;\n  }>): Panel[] {\n    const allPanelsRemoved = this.batchRemoveDefer(...items);\n\n    if (allPanelsRemoved.length <= 0) return [];\n\n    this.updateAfterPanelChange([], allPanelsRemoved);\n\n    return allPanelsRemoved;\n  }\n\n  /**\n   * Defers update\n   * camera position & others will be updated after calling updateAfterPanelChange\n   * @internal\n   */\n  public batchRemoveDefer(...items: Array<{\n    index: number;\n    deleteCount: number;\n    hasDOMInElements: boolean;\n  }>) {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking);\n\n    const { control } = flicking;\n    const activePanel = control.activePanel;\n\n    const allPanelsRemoved = items.reduce((removed, item) => {\n      const { index, deleteCount } = item;\n      const removingIdx = getMinusCompensatedIndex(index, panels.length);\n\n      const panelsPulled = panels.slice(removingIdx + deleteCount);\n      const panelsRemoved = panels.splice(removingIdx, deleteCount);\n\n      if (panelsRemoved.length <= 0) return [];\n\n      // Update panel indexes & positions\n      panelsPulled.forEach(panel => {\n        panel.decreaseIndex(panelsRemoved.length);\n        panel.updatePosition();\n      });\n\n      if (item.hasDOMInElements) {\n        this._removePanelElements(panelsRemoved);\n      }\n\n      // Remove panel elements\n      panelsRemoved.forEach(panel => panel.destroy());\n\n      if (includes(panelsRemoved, activePanel)) {\n        control.resetActive();\n      }\n\n      return [...removed, ...panelsRemoved];\n    }, []);\n\n    return allPanelsRemoved;\n  }\n\n  /**\n   * @internal\n   */\n  public updateAfterPanelChange(panelsAdded: Panel[], panelsRemoved: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking);\n    const { camera, control } = flicking;\n    const panels = this._panels;\n    const activePanel = control.activePanel;\n\n    // Update camera & control\n    this._updateCameraAndControl();\n\n    void this.render();\n\n    if (!activePanel || activePanel.removed) {\n      if (panels.length <= 0) {\n        // All panels removed\n        camera.lookAt(0);\n      } else {\n        let targetIndex = activePanel?.index ?? 0;\n        if (targetIndex > panels.length - 1) {\n          targetIndex = panels.length - 1;\n        }\n\n        void control.moveToPanel(panels[targetIndex], {\n          duration: 0\n        }).catch(() => void 0);\n      }\n    } else {\n      void control.moveToPanel(control.activePanel!, {\n        duration: 0\n      }).catch(() => void 0);\n    }\n\n    flicking.camera.updateOffset();\n\n    if (panelsAdded.length > 0 || panelsRemoved.length > 0) {\n      flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n        added: panelsAdded,\n        removed: panelsRemoved\n      }));\n\n      this.checkPanelContentsReady([\n        ...panelsAdded,\n        ...panelsRemoved\n      ]);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  public checkPanelContentsReady(checkingPanels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking);\n    const resizeOnContentsReady = flicking.resizeOnContentsReady;\n    const panels = this._panels;\n\n    if (!resizeOnContentsReady || flicking.virtualEnabled) return;\n\n    const hasContents = (panel: Panel) => !!panel.element.querySelector(\"img, video\");\n    checkingPanels = checkingPanels.filter(panel => hasContents(panel));\n\n    if (checkingPanels.length <= 0) return;\n\n    const contentsReadyChecker = new ImReady();\n\n    checkingPanels.forEach(panel => {\n      panel.loading = true;\n    });\n\n    contentsReadyChecker.on(\"readyElement\", e => {\n      if (!this._flicking) {\n        // Renderer's destroy() is called before\n        contentsReadyChecker.destroy();\n        return;\n      }\n\n      const panel = checkingPanels[e.index];\n      const camera = flicking.camera;\n      const control = flicking.control;\n      const prevProgressInPanel = control.activePanel\n        ? camera.getProgressInPanel(control.activePanel)\n        : 0;\n\n      panel.loading = false;\n      panel.resize();\n      panels.slice(panel.index + 1).forEach(panelBehind => panelBehind.updatePosition());\n\n      if (!flicking.initialized) return;\n\n      camera.updateRange();\n      camera.updateOffset();\n      camera.updateAnchors();\n\n      if (control.animating) {\n        // TODO: Need Axes update\n      } else {\n        control.updatePosition(prevProgressInPanel);\n        control.updateInput();\n      }\n    });\n\n    contentsReadyChecker.on(\"preReady\", e => {\n      if (this._flicking) {\n        void this.render();\n      }\n\n      if (e.readyCount === e.totalCount) {\n        contentsReadyChecker.destroy();\n      }\n    });\n\n    contentsReadyChecker.on(\"ready\", () => {\n      if (this._flicking) {\n        void this.render();\n      }\n      contentsReadyChecker.destroy();\n    });\n\n    contentsReadyChecker.check(checkingPanels.map(panel => panel.element));\n  }\n\n  protected _updateCameraAndControl() {\n    const flicking = getFlickingAttached(this._flicking);\n    const { camera, control } = flicking;\n\n    camera.updateRange();\n    camera.updateOffset();\n    camera.updateAnchors();\n    camera.resetNeedPanelHistory();\n    control.updateInput();\n  }\n\n  protected _showOnlyVisiblePanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n  }\n\n  protected _updatePanelSizeByGrid(referencePanel: Panel, panels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking);\n    const panelsPerView = flicking.panelsPerView;\n\n    if (panelsPerView <= 0) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"panelsPerView\", panelsPerView), ERROR.CODE.WRONG_OPTION);\n    }\n    if (panels.length <= 0) return;\n\n    const viewportSize = flicking.camera.size;\n    const gap = referencePanel.margin.prev + referencePanel.margin.next;\n\n    const panelSize = (viewportSize - gap * (panelsPerView - 1)) / panelsPerView;\n    const panelSizeObj = flicking.horizontal\n      ? { width: panelSize }\n      : { height: panelSize };\n    const firstPanelSizeObj = {\n      size: panelSize,\n      height: referencePanel.height,\n      margin: referencePanel.margin\n    };\n\n    if (!flicking.noPanelStyleOverride) {\n      this._strategy.updatePanelSizes(flicking, panelSizeObj);\n    }\n\n    flicking.panels.forEach(panel => panel.resize(firstPanelSizeObj));\n  }\n\n  protected _removeAllChildsFromCamera() {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraElement = flicking.camera.element;\n\n    // Remove other elements\n    while (cameraElement.firstChild) {\n      cameraElement.removeChild(cameraElement.firstChild);\n    }\n  }\n\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null = null) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const nextSiblingElement = nextSibling?.element || null;\n    const fragment = document.createDocumentFragment();\n\n    panels.forEach(panel => fragment.appendChild(panel.element));\n    cameraElement.insertBefore(fragment, nextSiblingElement);\n  }\n\n  protected _removePanelElements(panels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraElement = flicking.camera.element;\n\n    panels.forEach(panel => {\n      cameraElement.removeChild(panel.element);\n    });\n  }\n}\n\nexport default Renderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached, toArray } from \"../utils\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nclass VanillaRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async render() {\n    const flicking = getFlickingAttached(this._flicking);\n    const strategy = this._strategy;\n\n    strategy.updateRenderingPanels(flicking);\n    strategy.renderPanels(flicking);\n\n    this._resetPanelElementOrder();\n  }\n\n  protected _collectPanels() {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n\n    this._removeAllTextNodes();\n    this._panels = this._strategy.collectPanels(flicking, camera.children);\n  }\n\n  protected _createPanel(el: HTMLElement, options: Omit<PanelOptions, \"elementProvider\">): Panel {\n    return this._strategy.createPanel(el, options);\n  }\n\n  private _resetPanelElementOrder() {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraEl = flicking.camera.element;\n\n    // We're using reversed panels here as last panel should be the last element of camera element\n    const reversedElements = this._strategy\n      .getRenderingElementsByOrder(flicking)\n      .reverse();\n\n    reversedElements.forEach((el, idx) => {\n      const nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;\n\n      if (el.nextElementSibling !== nextEl) {\n        cameraEl.insertBefore(el, nextEl);\n      }\n    });\n  }\n\n  private _removeAllTextNodes() {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraElement = flicking.camera.element;\n\n    // Remove all text nodes in the camera element\n    toArray(cameraElement.childNodes).forEach(node => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        cameraElement.removeChild(node);\n      }\n    });\n  }\n}\n\nexport default VanillaRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n * @internal\n */\nabstract class ExternalRenderer extends Renderer {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  protected _removePanelElements(panels: Panel[]): void {\n    // DO NOTHING, overrided to prevent an unexpected error\n  }\n\n  protected _removeAllChildsFromCamera(): void {\n    // DO NOTHING, overrided to prevent an unexpected error\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nexport default ExternalRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport { getProgress, getStyle, parseAlign, setSize } from \"../../utils\";\nimport { ALIGN, DIRECTION } from \"../../const/external\";\nimport { LiteralUnion, ValueOf } from \"../../type/internal\";\n\nimport ElementProvider from \"./provider/ElementProvider\";\n\nexport interface PanelOptions {\n  index: number;\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number;\n  flicking: Flicking;\n  elementProvider: ElementProvider;\n}\n\n/**\n * A slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nclass Panel {\n  // Internal States\n  protected _flicking: Flicking;\n  protected _elProvider: ElementProvider;\n  protected _index: number;\n  protected _pos: number;\n  protected _size: number;\n  protected _height: number;\n  protected _margin: { prev: number; next: number };\n  protected _alignPos: number; // Actual align pos\n  protected _rendered: boolean;\n  protected _removed: boolean;\n  protected _loading: boolean;\n  protected _toggleDirection: ValueOf<typeof DIRECTION>;\n  protected _toggled: boolean;\n  protected _togglePosition: number;\n\n  // Options\n  protected _align: PanelOptions[\"align\"];\n\n  // Internal States Getter\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._elProvider.element; }\n  /**\n   * @internal\n   * @readonly\n   */\n  public get elementProvider() { return this._elProvider; }\n  /**\n   * Index of the panel\n   * @ko 패널의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of the panel, including {@link Panel#alignPosition alignPosition}\n   * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos + this._alignPos; }\n  /**\n   * Cached size of the panel element\n   * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else\n   * @ko 패널 엘리먼트의 캐시된 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() { return this._size; }\n  /**\n   * Panel's size including CSS `margin`\n   * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else\n   * @ko CSS `margin`을 포함한 패널의 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다\n   * @type {number}\n   * @readonly\n   */\n  public get sizeIncludingMargin() { return this._size + this._margin.prev + this._margin.next; }\n  /**\n   * Height of the panel element\n   * @ko 패널 엘리먼트의 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height; }\n  /**\n   * Cached CSS `margin` value of the panel element\n   * @ko 패널 엘리먼트의 CSS `margin` 값\n   * @type {object}\n   * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>\n   * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>\n   * @readonly\n   */\n  public get margin() { return this._margin; }\n  /**\n   * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at\n   * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * A value indicating whether the panel's {@link Flicking#remove remove}d\n   * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get removed() { return this._removed; }\n  /**\n   * A value indicating whether the panel's element is being rendered on the screen\n   * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get rendered() { return this._rendered; }\n  /**\n   * A value indicating whether the panel's image/video is not loaded and waiting for resize\n   * @ko 패널 내부의 이미지/비디오가 아직 로드되지 않아 {@link Panel#resize resize}될 것인지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get loading() { return this._loading; }\n  /**\n   * Panel element's range of the bounding box\n   * @ko 패널 엘리먼트의 Bounding box 범위\n   * @type {object}\n   * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)\n   * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)\n   * @readonly\n   */\n  public get range() { return { min: this._pos, max: this._pos + this._size }; }\n  /**\n   * A value indicating whether the panel's position is toggled by circular behavior\n   * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get toggled() { return this._toggled; }\n  /**\n   * A direction where the panel's position is toggled\n   * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향\n   * @type {DIRECTION}\n   * @readonly\n   */\n  public get toggleDirection() { return this._toggleDirection; }\n  /**\n   * Actual position offset determined by {@link Panel#order}\n   * @ko {@link Panel#order}에 의한 실제 위치 변경값\n   * @type {number}\n   * @readonly\n   */\n  public get offset() {\n    const toggleDirection = this._toggleDirection;\n    const cameraRangeDiff = this._flicking.camera.rangeDiff;\n\n    return toggleDirection === DIRECTION.NONE || !this._toggled\n      ? 0\n      : toggleDirection === DIRECTION.PREV\n        ? -cameraRangeDiff\n        : cameraRangeDiff;\n  }\n\n  /**\n   * Progress of movement between previous or next panel relative to current panel\n   * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n\n    return this.index - flicking.camera.progress;\n  }\n\n  /**\n   * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)\n   * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)\n   * @type {number}\n   * @readonly\n   */\n  public get outsetProgress() {\n    const position = this.position + this.offset;\n    const alignPosition = this._alignPos;\n    const camera = this._flicking.camera;\n    const camPos = camera.position;\n\n    if (camPos === position) {\n      return 0;\n    }\n\n    if (camPos < position) {\n      const disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;\n\n      return -getProgress(camPos, position, disappearPosNext);\n    } else {\n      const disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);\n\n      return 1 - getProgress(camPos, disappearPosPrev, position);\n    }\n  }\n\n  /**\n   * Percentage of area where panel is visible in the viewport\n   * @ko 뷰포트 안에서 패널이 보이는 영역의 비율\n   * @type {number}\n   * @readonly\n   */\n  public get visibleRatio() {\n    const range = this.range;\n    const size = this._size;\n    const offset = this.offset;\n    const visibleRange = this._flicking.camera.visibleRange;\n\n    const checkingRange = {\n      min: range.min + offset,\n      max: range.max + offset\n    };\n\n    if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {\n      return 0;\n    }\n\n    let visibleSize = size;\n\n    if (visibleRange.min > checkingRange.min) {\n      visibleSize -= visibleRange.min - checkingRange.min;\n    }\n    if (visibleRange.max < checkingRange.max) {\n      visibleSize -= checkingRange.max - visibleRange.max;\n    }\n\n    return visibleSize / size;\n  }\n\n  public set loading(val: boolean) { this._loading = val; }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element\n   * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: PanelOptions[\"align\"]) { this._align = val; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   * @param {Flicking} [options.elementProvider] A provider instance that redirects elements<ko>실제 엘리먼트를 반환하는 엘리먼트 공급자의 인스턴스</ko>\n   */\n  public constructor({\n    index,\n    align,\n    flicking,\n    elementProvider\n  }: PanelOptions) {\n    this._index = index;\n    this._flicking = flicking;\n    this._elProvider = elementProvider;\n\n    this._align = align;\n\n    this._removed = false;\n    this._rendered = true;\n    this._loading = false;\n    this._resetInternalStates();\n  }\n\n  /**\n   * Mark panel element to be appended on the camera element\n   * @internal\n   */\n  public markForShow() {\n    this._rendered = true;\n    this._elProvider.show(this._flicking);\n  }\n\n  /**\n   * Mark panel element to be removed from the camera element\n   * @internal\n   */\n  public markForHide() {\n    this._rendered = false;\n    this._elProvider.hide(this._flicking);\n  }\n\n  /**\n   * Update size of the panel\n   * @ko 패널의 크기를 갱신합니다\n   * @param {object} cached Predefined cached size of the panel<ko>사전에 캐시된 패널의 크기 정보</ko>\n   * @chainable\n   * @return {this}\n   */\n  public resize(cached?: {\n    size: number;\n    height: number;\n    margin: { prev: number; next: number };\n  }): this {\n    const el = this.element;\n    const flicking = this._flicking;\n    const horizontal = flicking.horizontal;\n\n    if (cached) {\n      this._size = cached.size;\n      this._margin = { ...cached.margin };\n      this._height = cached.height;\n    } else {\n      const elStyle = getStyle(el);\n\n      this._size = horizontal ? el.offsetWidth : el.offsetHeight;\n      this._margin = horizontal\n        ? {\n          prev: parseFloat(elStyle.marginLeft || \"0\"),\n          next: parseFloat(elStyle.marginRight || \"0\")\n        } : {\n          prev: parseFloat(elStyle.marginTop || \"0\"),\n          next: parseFloat(elStyle.marginBottom || \"0\")\n        };\n      this._height = horizontal ? el.offsetHeight : this._size;\n    }\n\n    this.updatePosition();\n    this._updateAlignPos();\n\n    return this;\n  }\n\n  /**\n   * Change panel's size. This will change the actual size of the panel element by changing its CSS width/height property\n   * @ko 패널 크기를 변경합니다. 패널 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New panel size<ko>새 패널 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @chainable\n   * @return {this}\n   */\n  public setSize(size: Partial<{\n    width: number | string;\n    height: number | string;\n  }>): this {\n    setSize(this.element, size);\n\n    return this;\n  }\n\n  /**\n   * Check whether the given element is inside of this panel's {@link Panel#element element}\n   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다\n   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>\n   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>\n   */\n  public contains(element: HTMLElement): boolean {\n    return !!this.element?.contains(element);\n  }\n\n  /**\n   * Reset internal state and set {@link Panel#removed removed} to `true`\n   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.\n   * @return {void}\n   */\n  public destroy(): void {\n    this._resetInternalStates();\n    this._removed = true;\n  }\n\n  /**\n   * Check whether the given position is inside of this panel's {@link Panel#range range}\n   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.\n   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>\n   */\n  public includePosition(pos: number, includeMargin: boolean = false): boolean {\n    return this.includeRange(pos, pos, includeMargin);\n  }\n\n  /**\n   * Check whether the given range is fully included in this panel's area (inclusive)\n   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다\n   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>\n   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>\n   */\n  public includeRange(min: number, max: number, includeMargin: boolean = false): boolean {\n    const margin = this._margin;\n    const panelRange = this.range;\n\n    if (includeMargin) {\n      panelRange.min -= margin.prev;\n      panelRange.max += margin.next;\n    }\n\n    return max >= panelRange.min && min <= panelRange.max;\n  }\n\n  /**\n   * Check whether the panel is visble in the given range (exclusive)\n   * @ko 주어진 범위 내에서 이 패널의 일부가 보여지는지를 반환합니다\n   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>\n   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>\n   * @returns {boolean} A Boolean value indicating whether the panel is visible<ko>해당 범위 내에서 패널을 볼 수 있는지 여부</ko>\n   */\n  public isVisibleOnRange(min: number, max: number): boolean {\n    const panelRange = this.range;\n\n    return max > panelRange.min && min < panelRange.max;\n  }\n\n  /**\n   * Move {@link Camera} to this panel\n   * @ko {@link Camera}를 이 패널로 이동합니다\n   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>\n   */\n  public focus(duration?: number) {\n    return this._flicking.moveTo(this._index, duration);\n  }\n\n  /**\n   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel\n   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>\n   */\n  public prev(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1)\n      : renderer.getPanel(index - 1);\n  }\n\n  /**\n   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel\n   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>\n   */\n  public next(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1)\n      : renderer.getPanel(index + 1);\n  }\n\n  /**\n   * Increase panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public increaseIndex(val: number): this {\n    this._index += Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * Decrease panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public decreaseIndex(val: number): this {\n    this._index -= Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public updatePosition(): this {\n    const prevPanel = this._flicking.renderer.panels[this._index - 1];\n\n    this._pos = prevPanel\n      ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev\n      : this._margin.prev;\n\n    return this;\n  }\n\n  /**\n   * @internal\n   * @return {boolean} toggled\n   */\n  public toggle(prevPos: number, newPos: number): boolean {\n    const toggleDirection = this._toggleDirection;\n    const togglePosition = this._togglePosition;\n\n    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;\n\n    const prevToggled = this._toggled;\n\n    if (newPos > prevPos) {\n      if (togglePosition >= prevPos && togglePosition <= newPos) {\n        this._toggled = toggleDirection === DIRECTION.NEXT;\n      }\n    } else {\n      if (togglePosition <= prevPos && togglePosition >= newPos) {\n        this._toggled = toggleDirection !== DIRECTION.NEXT;\n      }\n    }\n\n    return prevToggled !== this._toggled;\n  }\n\n  /**\n   * @internal\n   */\n  public updateCircularToggleDirection(): this {\n    const flicking = this._flicking;\n\n    if (!flicking.circularEnabled) {\n      this._toggleDirection = DIRECTION.NONE;\n      this._toggled = false;\n      return this;\n    }\n\n    const camera = flicking.camera;\n    const camRange = camera.range;\n    const camAlignPosition = camera.alignPosition;\n    const camVisibleRange = camera.visibleRange;\n    const camVisibleSize = camVisibleRange.max - camVisibleRange.min;\n\n    const minimumVisible = camRange.min - camAlignPosition;\n    const maximumVisible = camRange.max - camAlignPosition + camVisibleSize;\n\n    const shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);\n    const shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);\n\n    this._toggled = false;\n    if (shouldBeVisibleAtMin) {\n      this._toggleDirection = DIRECTION.PREV;\n      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;\n      this.toggle(Infinity, camera.position);\n    } else if (shouldBeVisibleAtMax) {\n      this._toggleDirection = DIRECTION.NEXT;\n      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;\n      this.toggle(-Infinity, camera.position);\n    } else {\n      this._toggleDirection = DIRECTION.NONE;\n      this._togglePosition = 0;\n    }\n\n    return this;\n  }\n\n  private _updateAlignPos() {\n    this._alignPos = parseAlign(this._align, this._size);\n  }\n\n  private _resetInternalStates() {\n    this._size = 0;\n    this._pos = 0;\n    this._margin = { prev: 0, next: 0 };\n    this._height = 0;\n    this._alignPos = 0;\n    this._toggled = false;\n    this._togglePosition = 0;\n    this._toggleDirection = DIRECTION.NONE;\n  }\n}\n\nexport default Panel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport Panel, { PanelOptions } from \"../../core/panel/Panel\";\nimport ElementProvider from \"../../core/panel/provider/ElementProvider\";\nimport { DIRECTION } from \"../../const/external\";\nimport { parsePanelAlign } from \"../../utils\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nexport interface NormalRenderingStrategyOptions {\n  providerCtor: new (...args: any) => ElementProvider;\n}\n\n\nclass NormalRenderingStrategy implements RenderingStrategy {\n  private _providerCtor: NormalRenderingStrategyOptions[\"providerCtor\"];\n\n  public constructor({ providerCtor }: NormalRenderingStrategyOptions) {\n    this._providerCtor = providerCtor;\n  }\n\n  public renderPanels() {\n    // DO_NOTHING\n  }\n\n  public getRenderingIndexesByOrder(flicking: Flicking) {\n    const renderedPanels = flicking.renderer.panels.filter(panel => panel.rendered);\n    const toggledPrev = renderedPanels.filter(panel => panel.toggled && panel.toggleDirection === DIRECTION.PREV);\n    const toggledNext = renderedPanels.filter(panel => panel.toggled && panel.toggleDirection === DIRECTION.NEXT);\n    const notToggled = renderedPanels.filter(panel => !panel.toggled);\n\n    return [...toggledPrev, ...notToggled, ...toggledNext].map(panel => panel.index);\n  }\n\n  public getRenderingElementsByOrder(flicking: Flicking) {\n    const panels = flicking.panels;\n\n    return this.getRenderingIndexesByOrder(flicking).map(index => panels[index].element);\n  }\n\n  public updateRenderingPanels(flicking: Flicking) {\n    if (flicking.renderOnlyVisible) {\n      this._showOnlyVisiblePanels(flicking);\n    } else {\n      flicking.panels.forEach(panel => panel.markForShow());\n    }\n  }\n\n  public collectPanels(\n    flicking: Flicking,\n    elements: any[]\n  ) {\n    const align = parsePanelAlign(flicking.renderer.align);\n\n    return elements.map((el, index) => new Panel({\n      index,\n      elementProvider: new this._providerCtor(el),\n      align,\n      flicking\n    }));\n  }\n\n  public createPanel(\n    element: any,\n    options: Omit<PanelOptions, \"elementProvider\">\n  ) {\n    return new Panel({\n      ...options,\n      elementProvider: new this._providerCtor(element)\n    });\n  }\n\n  public updatePanelSizes(flicking: Flicking, size: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    flicking.panels.forEach(panel => panel.setSize(size));\n  }\n\n  private _showOnlyVisiblePanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n\n    camera.updateOffset();\n  }\n}\n\nexport default NormalRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { DIRECTION } from \"../../const/external\";\nimport { circulateIndex } from \"../../utils\";\n\nimport Panel, { PanelOptions } from \"./Panel\";\nimport VirtualElementProvider from \"./provider/VirtualElementProvider\";\n\ninterface VirtualPanelOptions extends PanelOptions {\n  elementProvider: VirtualElementProvider;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nclass VirtualPanel extends Panel {\n  protected _elProvider: VirtualElementProvider;\n  protected _cachedInnerHTML: string | null;\n\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._elProvider.element; }\n\n  /**\n   * Cached innerHTML by the previous render function\n   * @ko 이전 렌더링에서 캐시된 innerHTML 정보\n   * @type {string|null}\n   * @readonly\n   */\n  public get cachedInnerHTML() { return this._cachedInnerHTML; }\n\n  /**\n   * An number for indexing which element it will be rendered on\n   * @ko 몇 번째 엘리먼트에 렌더링될 것인지를 나타내는 숫자\n   * @type {number}\n   * @readonly\n   */\n  public get elementIndex() {\n    const flicking = this._flicking;\n    const virtualElCount = flicking.panelsPerView + 1;\n    const panelCount = flicking.panelCount;\n    let index = this._index;\n\n    if (this._toggled) {\n      // To prevent element duplication\n      index = this._toggleDirection === DIRECTION.NEXT\n        ? index + panelCount\n        : index - panelCount;\n    }\n\n    return circulateIndex(index, virtualElCount);\n  }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: VirtualPanelOptions) {\n    super(options);\n\n    options.elementProvider.init(this);\n    this._elProvider = options.elementProvider;\n    this._cachedInnerHTML = null;\n  }\n\n  public cacheRenderResult(result: string) {\n    this._cachedInnerHTML = result;\n  }\n\n  public uncacheRenderResult() {\n    this._cachedInnerHTML = null;\n  }\n\n  public render() {\n    const flicking = this._flicking;\n    const { renderPanel, cache } = flicking.virtual;\n\n    const element = this._elProvider.element;\n    const newInnerHTML = this._cachedInnerHTML || renderPanel(this, this._index);\n\n    if (newInnerHTML === element.innerHTML) return;\n\n    element.innerHTML = newInnerHTML;\n\n    if (cache) {\n      this.cacheRenderResult(newInnerHTML);\n    }\n  }\n\n  public increaseIndex(val: number) {\n    this.uncacheRenderResult();\n    return super.increaseIndex(val);\n  }\n\n  public decreaseIndex(val: number) {\n    this.uncacheRenderResult();\n    return super.decreaseIndex(val);\n  }\n}\n\nexport default VirtualPanel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport { PanelOptions } from \"../../core/panel/Panel\";\nimport VirtualPanel from \"../../core/panel/VirtualPanel\";\nimport VirtualElementProvider from \"../../core/panel/provider/VirtualElementProvider\";\nimport { parsePanelAlign, range, setSize } from \"../../utils\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nclass VirtualRenderingStrategy implements RenderingStrategy {\n  public renderPanels(flicking: Flicking) {\n    const virtualManager = flicking.virtual;\n    const visiblePanels = flicking.visiblePanels as VirtualPanel[];\n    const invisibleIndexes = range(flicking.panelsPerView + 1);\n\n    visiblePanels.forEach(panel => {\n      const elementIndex = panel.elementIndex;\n\n      panel.render();\n\n      virtualManager.show(elementIndex);\n      invisibleIndexes[elementIndex] = -1;\n    });\n\n    invisibleIndexes\n      .filter(val => val >= 0)\n      .forEach(idx => {\n        virtualManager.hide(idx);\n      });\n  }\n\n  public getRenderingIndexesByOrder(flicking: Flicking) {\n    const virtualManager = flicking.virtual;\n    const visiblePanels = [...flicking.visiblePanels]\n      .filter(panel => panel.rendered)\n      .sort((panel1, panel2) => {\n        return (panel1.position + panel1.offset) - (panel2.position + panel2.offset);\n      }) as VirtualPanel[];\n\n    if (visiblePanels.length <= 0) return virtualManager.elements.map((_, idx) => idx);\n\n    const visibleIndexes = visiblePanels.map(panel => panel.elementIndex);\n    const invisibleIndexes = virtualManager.elements\n      .map((el, idx) => ({ ...el, idx }))\n      .filter(el => !el.visible)\n      .map(el => el.idx);\n\n    return [...visibleIndexes, ...invisibleIndexes];\n  }\n\n  public getRenderingElementsByOrder(flicking: Flicking) {\n    const virtualManager = flicking.virtual;\n    const elements = virtualManager.elements;\n\n    return this.getRenderingIndexesByOrder(flicking).map(index => elements[index].nativeElement);\n  }\n\n  public updateRenderingPanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else {\n        panel.markForHide();\n      }\n    });\n\n    camera.updateOffset();\n  }\n\n  public collectPanels(flicking: Flicking) {\n    const align = parsePanelAlign(flicking.renderer.align);\n\n    return range(flicking.virtual.initialPanelCount).map(index => new VirtualPanel({\n      index,\n      elementProvider: new VirtualElementProvider(flicking),\n      align,\n      flicking\n    }));\n  }\n\n  public createPanel(_el: any, options: PanelOptions) {\n    return new VirtualPanel({\n      ...options,\n      elementProvider: new VirtualElementProvider(options.flicking)\n    });\n  }\n\n  public updatePanelSizes(flicking: Flicking, size: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    flicking.virtual.elements.forEach(el => {\n      setSize(el.nativeElement, size);\n    });\n    flicking.panels.forEach(panel => panel.setSize(size));\n  }\n}\n\nexport default VirtualRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Renderer, { RendererOptions } from \"./Renderer\";\nimport VanillaRenderer from \"./VanillaRenderer\";\nimport ExternalRenderer from \"./ExternalRenderer\";\n\nexport * from \"./strategy\";\n\nexport {\n  Renderer,\n  VanillaRenderer,\n  ExternalRenderer\n};\n\nexport type {\n  RendererOptions\n};\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component, { ComponentEvent } from \"@egjs/component\";\n\nimport FlickingError from \"./core/FlickingError\";\nimport Viewport from \"./core/Viewport\";\nimport AutoResizer from \"./core/AutoResizer\";\nimport { Panel } from \"./core/panel\";\nimport { VanillaElementProvider } from \"./core/panel/provider\";\nimport VirtualManager, { VirtualOptions } from \"./core/VirtualManager\";\nimport { Control, SnapControl, SnapControlOptions, FreeControl, StrictControl, FreeControlOptions, StrictControlOptions } from \"./control\";\nimport { Camera } from \"./camera\";\nimport { Renderer, VanillaRenderer, ExternalRenderer, RendererOptions, NormalRenderingStrategy, VirtualRenderingStrategy } from \"./renderer\";\nimport { EVENTS, ALIGN, MOVE_TYPE, DIRECTION, CIRCULAR_FALLBACK } from \"./const/external\";\nimport * as ERROR from \"./const/error\";\nimport { findIndex, getElement, includes, parseElement } from \"./utils\";\nimport { HoldStartEvent, HoldEndEvent, MoveStartEvent, SelectEvent, MoveEvent, MoveEndEvent, WillChangeEvent, WillRestoreEvent, NeedPanelEvent, VisibleChangeEvent, ReachEdgeEvent, ReadyEvent, AfterResizeEvent, BeforeResizeEvent, ChangedEvent, RestoredEvent, PanelChangeEvent } from \"./type/event\";\nimport { LiteralUnion, ValueOf } from \"./type/internal\";\nimport { ElementLike, Plugin, Status, MoveTypeOptions } from \"./type/external\";\n\n/**\n * @interface\n */\nexport interface FlickingEvents {\n  [EVENTS.READY]: ReadyEvent;\n  [EVENTS.BEFORE_RESIZE]: BeforeResizeEvent;\n  [EVENTS.AFTER_RESIZE]: AfterResizeEvent;\n  [EVENTS.HOLD_START]: HoldStartEvent;\n  [EVENTS.HOLD_END]: HoldEndEvent;\n  [EVENTS.MOVE_START]: MoveStartEvent;\n  [EVENTS.MOVE]: MoveEvent;\n  [EVENTS.MOVE_END]: MoveEndEvent;\n  [EVENTS.WILL_CHANGE]: WillChangeEvent;\n  [EVENTS.CHANGED]: ChangedEvent;\n  [EVENTS.WILL_RESTORE]: WillRestoreEvent;\n  [EVENTS.RESTORED]: RestoredEvent;\n  [EVENTS.SELECT]: SelectEvent;\n  [EVENTS.NEED_PANEL]: NeedPanelEvent;\n  [EVENTS.VISIBLE_CHANGE]: VisibleChangeEvent;\n  [EVENTS.REACH_EDGE]: ReachEdgeEvent;\n  [EVENTS.PANEL_CHANGE]: PanelChangeEvent;\n}\n\n/**\n * @interface\n */\nexport interface FlickingOptions {\n  // UI / LAYOUT\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number | { panel: number | string; camera: number | string };\n  defaultIndex: number;\n  horizontal: boolean;\n  circular: boolean;\n  circularFallback: LiteralUnion<ValueOf<typeof CIRCULAR_FALLBACK>>;\n  bound: boolean;\n  adaptive: boolean;\n  panelsPerView: number;\n  noPanelStyleOverride: boolean;\n  resizeOnContentsReady: boolean;\n\n  // EVENT\n  needPanelThreshold: number;\n  preventEventsBeforeInit: boolean;\n\n  // ANIMATION\n  deceleration: number;\n  duration: number;\n  easing: (x: number) => number;\n\n  // INPUT\n  inputType: string[];\n  moveType: ValueOf<typeof MOVE_TYPE> | MoveTypeOptions<ValueOf<typeof MOVE_TYPE>>;\n  threshold: number;\n  interruptable: boolean;\n  bounce: number | string | [number | string, number | string];\n  iOSEdgeSwipeThreshold: number;\n  preventClickOnDrag: boolean;\n  disableOnInit: boolean;\n\n  // PERFORMANCE\n  renderOnlyVisible: boolean;\n  virtual: VirtualOptions | null;\n\n  // OTHERS\n  autoInit: boolean;\n  autoResize: boolean;\n  useResizeObserver: boolean;\n  resizeDebounce: number;\n  maxResizeDebounce: number;\n  externalRenderer: ExternalRenderer | null;\n\n  // @deprecated\n  renderExternal: {\n    renderer: new (options: RendererOptions) => ExternalRenderer;\n    rendererOptions: RendererOptions;\n  } | null;\n}\n\n/**\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|@egjs/component}\n * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}\n */\nclass Flicking extends Component<FlickingEvents> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @type {string}\n   * @readonly\n   * @example\n   * ```ts\n   * Flicking.VERSION;  // ex) 4.0.0\n   * ```\n   */\n  public static VERSION = \"#__VERSION__#\";\n\n  // Core components\n  private _viewport: Viewport;\n  private _autoResizer: AutoResizer;\n  private _camera: Camera;\n  private _control: Control;\n  private _renderer: Renderer;\n  private _virtualManager: VirtualManager;\n\n  // Options\n  private _align: FlickingOptions[\"align\"];\n  private _defaultIndex: FlickingOptions[\"defaultIndex\"];\n  private _horizontal: FlickingOptions[\"horizontal\"];\n  private _circular: FlickingOptions[\"circular\"];\n  private _circularFallback: FlickingOptions[\"circularFallback\"];\n  private _bound: FlickingOptions[\"bound\"];\n  private _adaptive: FlickingOptions[\"adaptive\"];\n  private _panelsPerView: FlickingOptions[\"panelsPerView\"];\n  private _noPanelStyleOverride: FlickingOptions[\"noPanelStyleOverride\"];\n  private _resizeOnContentsReady: FlickingOptions[\"resizeOnContentsReady\"];\n  private _virtual: FlickingOptions[\"virtual\"];\n\n  private _needPanelThreshold: FlickingOptions[\"needPanelThreshold\"];\n  private _preventEventsBeforeInit: FlickingOptions[\"preventEventsBeforeInit\"];\n\n  private _deceleration: FlickingOptions[\"deceleration\"];\n  private _duration: FlickingOptions[\"duration\"];\n  private _easing: FlickingOptions[\"easing\"];\n\n  private _inputType: FlickingOptions[\"inputType\"];\n  private _moveType: FlickingOptions[\"moveType\"];\n  private _threshold: FlickingOptions[\"threshold\"];\n  private _interruptable: FlickingOptions[\"interruptable\"];\n  private _bounce: FlickingOptions[\"bounce\"];\n  private _iOSEdgeSwipeThreshold: FlickingOptions[\"iOSEdgeSwipeThreshold\"];\n  private _preventClickOnDrag: FlickingOptions[\"preventClickOnDrag\"];\n  private _disableOnInit: FlickingOptions[\"disableOnInit\"];\n\n  private _renderOnlyVisible: FlickingOptions[\"renderOnlyVisible\"];\n\n  private _autoInit: FlickingOptions[\"autoInit\"];\n  private _autoResize: FlickingOptions[\"autoResize\"];\n  private _useResizeObserver: FlickingOptions[\"useResizeObserver\"];\n  private _resizeDebounce: FlickingOptions[\"resizeDebounce\"];\n  private _maxResizeDebounce: FlickingOptions[\"maxResizeDebounce\"];\n  private _externalRenderer: FlickingOptions[\"externalRenderer\"];\n  private _renderExternal: FlickingOptions[\"renderExternal\"];\n\n  // Internal State\n  private _initialized: boolean;\n  private _plugins: Plugin[];\n\n  // Components\n  /**\n   * {@link Control} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스\n   * @type {Control}\n   * @default SnapControl\n   * @readonly\n   * @see Control\n   * @see SnapControl\n   * @see FreeControl\n   */\n  public get control() { return this._control; }\n  /**\n   * {@link Camera} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스\n   * @type {Camera}\n   * @default LinearCamera\n   * @readonly\n   * @see Camera\n   * @see LinearCamera\n   * @see BoundCamera\n   * @see CircularCamera\n   */\n  public get camera() { return this._camera; }\n  /**\n   * {@link Renderer} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스\n   * @type {Renderer}\n   * @default VanillaRenderer\n   * @readonly\n   * @see Renderer\n   * @see VanillaRenderer\n   * @see ExternalRenderer\n   */\n  public get renderer() { return this._renderer; }\n  /**\n   * A component that manages viewport size\n   * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n   * @type {Viewport}\n   * @readonly\n   * @see Viewport\n   */\n  public get viewport() { return this._viewport; }\n  // Internal States\n  /**\n   * Whether Flicking's {@link Flicking#init init()} is called.\n   * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.\n   * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.\n   * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get initialized() { return this._initialized; }\n  /**\n   * Whether the `circular` option is enabled.\n   * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\n   * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get circularEnabled() { return this._camera.circularEnabled; }\n  /**\n   * Whether the `virtual` option is enabled.\n   * The {@link Flicking#virtual virtual} option can't be enabled when  {@link Flicking#panelsPerView panelsPerView} is less or equal than zero.\n   * @ko {@link Flicking#virtual virtual} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#virtual virtual} 옵션은 {@link Flicking#panelsPerView panelsPerView} 옵션의 값이 0보다 같거나 작으면 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get virtualEnabled() { return this._panelsPerView > 0 && this._virtual != null; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get index() { return this._control.activeIndex; }\n  /**\n   * The root(`.flicking-viewport`) element\n   * @ko root(`.flicking-viewport`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._viewport.element; }\n  /**\n   * Currently active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel}\n   * @readonly\n   * @see Panel\n   */\n  public get currentPanel() { return this._control.activePanel; }\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._renderer.panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._renderer.panelCount; }\n  /**\n   * Array of panels that is visible at the current position\n   * @ko 현재 보이는 패널의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get visiblePanels() { return this._camera.visiblePanels; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._control.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._control.holding; }\n  /**\n   * A current list of activated plugins\n   * @ko 현재 활성화된 플러그인 목록\n   * @type {Plugin[]}\n   * @readonly\n   */\n  public get activePlugins() { return this._plugins; }\n\n  // Options Getter\n  // UI / LAYOUT\n  /**\n   * Align position of the panels within viewport. You can set different values each for the panel and camera\n   * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다\n   * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}\n   * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>\n   * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>\n   * @default \"center\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // Literal strings\n   *   \"prev\", \"center\", \"next\",\n   *   // % values, applied to both panel & camera\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000,\n   *   // Setting a different value for panel & camera\n   *   { panel: \"10%\", camera: \"25%\" }\n   * ];\n   *\n   * possibleOptions.forEach(align => {\n   *   new Flicking(\"#el\", { align });\n   * });\n   * ```\n   */\n  public get align() { return this._align; }\n  /**\n   * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer\n   * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다\n   * @type {number}\n   * @default 0\n   */\n  public get defaultIndex() { return this._defaultIndex; }\n  /**\n   * Direction of panel movement (true: horizontal, false: vertical)\n   * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)\n   * @type {boolean}\n   * @default true\n   */\n  public get horizontal() { return this._horizontal; }\n  /**\n   * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.\n   * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get circular() { return this._circular; }\n  /**\n   * Set panel control mode for the case when circular cannot be enabled.\n   * \"linear\" will set the view's range from the top of the first panel to the top of the last panel.\n   * \"bound\" will prevent the view from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel.\n   * @ko 순환 모드 사용 불가능시 사용할 패널 조작 범위 설정 방식을 변경합니다.\n   * \"linear\" 사용시 시점이 첫번째 엘리먼트 위에서부터 마지막 엘리먼트 위까지 움직일 수 있도록 설정합니다.\n   * \"bound\" 사용시 시점이 첫번째 엘리먼트와 마지막 엘리먼트의 끝과 끝 사이에서 움직일 수 있도록 설정합니다.\n   * @see CIRCULAR_FALLBACK\n   * @type {string}\n   * @default \"linear\"\n   */\n  public get circularFallback() { return this._circularFallback; }\n  /**\n   * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n   * Only can be enabled when `circular=false`\n   * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다\n   * `circular=false`인 경우에만 사용할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get bound() { return this._bound; }\n  /**\n   * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`\n   * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get adaptive() { return this._adaptive; }\n  /**\n   * A visible number of panels on viewport. Enabling this option will automatically resize panel size\n   * @ko 한 화면에 보이는 패널의 개수. 이 옵션을 활성화할 경우 패널의 크기를 강제로 재조정합니다\n   * @type {number}\n   * @default -1\n   */\n  public get panelsPerView() { return this._panelsPerView; }\n  /**\n   * Enabling this option will not change `width/height` style of the panels if {@link Flicking#panelsPerView} is enabled.\n   * This behavior can be useful in terms of performance when you're manually managing all panel sizes\n   * @ko 이 옵션을 활성화할 경우, {@link Flicking#panelsPerView} 옵션이 활성화되었을 때 패널의 `width/height` 스타일을 변경하지 않도록 설정합니다.\n   * 모든 패널들의 크기를 직접 관리하고 있을 경우, 이 옵션을 활성화하면 성능면에서 유리할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get noPanelStyleOverride() { return this._noPanelStyleOverride; }\n  /**\n   * Enabling this option will automatically call {@link Flicking#resize} when all image/video inside panels are loaded.\n   * This can be useful when you have contents inside Flicking that changes its size when it's loaded\n   * @ko 이 옵션을 활성화할 경우, Flicking 패널 내부의 이미지/비디오들이 로드되었을 때 자동으로 {@link Flicking#resize}를 호출합니다.\n   * 이 동작은 Flicking 내부에 로드 전/후로 크기가 변하는 콘텐츠를 포함하고 있을 때 유용하게 사용하실 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get resizeOnContentsReady() { return this._resizeOnContentsReady; }\n  // EVENTS\n  /**\n   * A Threshold from viewport edge before triggering `needPanel` event\n   * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리\n   * @type {number}\n   * @default 0\n   */\n  public get needPanelThreshold() { return this._needPanelThreshold; }\n  /**\n   * When enabled, events are not triggered before `ready` when initializing\n   * @ko 활성화할 경우 초기화시 `ready` 이벤트 이전의 이벤트가 발생하지 않습니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get preventEventsBeforeInit() { return this._preventEventsBeforeInit; }\n  // ANIMATION\n  /**\n   * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time\n   * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다\n   * @type {number}\n   * @default 0.0075\n   */\n  public get deceleration() { return this._deceleration; }\n  /**\n   * An easing function applied to the panel movement animation. Default value is `easeOutCubic`\n   * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다\n   * @type {function}\n   * @default x => 1 - Math.pow(1 - x, 3)\n   * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n   */\n  public get easing() { return this._easing; }\n  /**\n   * Default duration of the animation (ms)\n   * @ko 디폴트 애니메이션 재생 시간 (ms)\n   * @type {number}\n   * @default 500\n   */\n  public get duration() { return this._duration; }\n  // INPUT\n  /**\n   * Types of input devices to enable\n   * @ko 활성화할 입력 장치 종류\n   * @type {string[]}\n   * @default [\"touch\", \"mouse\"]\n   * @see {@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Possible values (PanInputOption#inputType)}\n   * <ko>{@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 가능한 값들 (PanInputOption#inputType)}</ko>\n   */\n  public get inputType() { return this._inputType; }\n  /**\n   * Movement style by user input. This will change instance type of {@link Flicking#control}\n   * You can use the values of the constant {@link MOVE_TYPE}\n   * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다\n   * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다\n   * @type {MOVE_TYPE | Pair<string, object>}\n   * @default \"snap\"\n   * @example\n   * |moveType|control|options|\n   * |:---:|:---:|:---:|\n   * |\"snap\"|{@link SnapControl}||\n   * |\"freeScroll\"|{@link FreeControl}|{@link FreeControlOptions}|\n   *\n   * ```ts\n   * import Flicking, { MOVE_TYPE } from \"@egjs/flicking\";\n   *\n   * const flicking = new Flicking({\n   *   moveType: MOVE_TYPE.SNAP\n   * });\n   * ```\n   *\n   * ```ts\n   * const flicking = new Flicking({\n   *   // If you want more specific settings for the moveType\n   *   // [moveType, options for that moveType]\n   *   // In this case, it's [\"freeScroll\", FreeControlOptions]\n   *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]\n   * });\n   * ```\n   */\n  public get moveType() { return this._moveType; }\n  /**\n   * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.\n   * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.\n   * @type {number}\n   * @default 40\n   */\n  public get threshold() { return this._threshold; }\n  /**\n   * Set animation to be interruptable by click/touch.\n   * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get interruptable() { return this._interruptable; }\n  /**\n   * The size value of the bounce area. Only can be enabled when `circular=false`.\n   * You can set different bounce value for prev/next direction by using array.\n   * `number` for px value, and `string` for px, and % value relative to viewport size.\n   * You have to call {@link Control#updateInput} after changing this to take effect.\n   * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.\n   * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.\n   * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.\n   * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.\n   * @type {string | number | Array<string | number>}\n   * @default \"20%\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // % values, relative to viewport element(\".flicking-viewport\")'s size\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000\n   * ];\n   * ```\n   *\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#el\", { bounce: \"20%\" });\n   *\n   * flicking.bounce = \"100%\";\n   * flicking.control.updateInput(); // Call this to update!\n   * ```\n   */\n  public get bounce() { return this._bounce; }\n  /**\n   * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward\n   * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)\n   * @type {number}\n   * @default 30\n   */\n  public get iOSEdgeSwipeThreshold() { return this._iOSEdgeSwipeThreshold; }\n  /**\n   * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element\n   * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get preventClickOnDrag() { return this._preventClickOnDrag; }\n  /**\n   * Automatically call {@link Flicking#disableInput disableInput()} on initialization\n   * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다\n   * @type {boolean}\n   * @default false\n   */\n  public get disableOnInit() { return this._disableOnInit; }\n  // PERFORMANCE\n  /**\n   * Whether to render visible panels only. This can dramatically increase performance when there're many panels\n   * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get renderOnlyVisible() { return this._renderOnlyVisible; }\n  /**\n   * By enabling this option, it will reduce memory consumption by restricting the number of DOM elements to `panelsPerView + 1`\n   * Must be used with `panelsPerview`.\n   * After Flicking's initialized, this property can be used to add/remove the panel count.\n   * @ko 이 옵션을 활성화할 경우 패널 엘리먼트의 개수를 `panelsPerView + 1` 개로 고정함으로써, 메모리 사용량을 줄일 수 있습니다.\n   * `panelsPerView` 옵션과 함께 사용되어야만 합니다.\n   * Flicking 초기화 이후에, 이 프로퍼티는 렌더링하는 패널의 개수를 추가/제거하기 위해 사용될 수 있습니다.\n   * @type {VirtualManager}\n   * @property {function} renderPanel A rendering function for the panel element's innerHTML<ko>패널 엘리먼트의 innerHTML을 렌더링하는 함수</ko>\n   * @property {number} initialPanelCount Initial panel count to render<ko>최초로 렌더링할 패널의 개수</ko>\n   * @property {boolean} [cache=false] Whether to cache rendered panel's innerHTML<ko>렌더링된 패널의 innerHTML 정보를 캐시할지 여부</ko>\n   * @property {string} [panelClass=\"flicking-panel\"] The class name that will be applied to rendered panel elements<ko>렌더링되는 패널 엘리먼트에 적용될 클래스 이름</ko>\n   * @example\n   * ```ts\n   * import Flicking, { VirtualPanel } from \"@egjs/flicking\";\n   *\n   * const flicking = new Flicking(\"#some_el\", {\n   *   panelsPerView: 3,\n   *   virtual: {\n   *     renderPanel: (panel: VirtualPanel, index: number) => `Panel ${index}`,\n   *     initialPanelCount: 100\n   *   }\n   * });\n   *\n   * // Add 100 virtual panels (at the end)\n   * flicking.virtual.append(100);\n   *\n   * // Remove 100 virtual panels from 0 to 100\n   * flicking.virtual.remove(0, 100);\n   * ```\n   */\n  public get virtual() { return this._virtualManager; }\n\n  // OTHERS\n  /**\n   * Call {@link Flicking#init init()} automatically when creating Flicking's instance\n   * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다\n   * @type {boolean}\n   * @default true\n   * @readonly\n   */\n  public get autoInit() { return this._autoInit; }\n  /**\n   * Whether to automatically call {@link Flicking#resize resize()} when the viewport element(.flicking-viewport)'s size is changed\n   * @ko 뷰포트 엘리먼트(.flicking-viewport)의 크기 변경시 {@link Flicking#resize resize()} 메소드를 자동으로 호출할지 여부를 설정합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get autoResize() { return this._autoResize; }\n  /**\n   * Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option\n   * @ko autoResize 옵션 사용시 {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}의 이벤트를 Window객체의 {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} 이벤트 대신 수신할지 여부를 설정합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get useResizeObserver() { return this._useResizeObserver; }\n  /**\n   * Delays size recalculation from `autoResize` by the given time in milisecond.\n   * If the size is changed again while being delayed, it cancels the previous one and delays from the beginning again.\n   * This can increase performance by preventing `resize` being called too often.\n   * @ko `autoResize` 설정시에 호출되는 크기 재계산을 주어진 시간(단위: ms)만큼 지연시킵니다.\n   * 지연시키는 도중 크기가 다시 변경되었을 경우, 이전 것을 취소하고 주어진 시간만큼 다시 지연시킵니다.\n   * 이를 통해 `resize`가 너무 많이 호출되는 것을 방지하여 성능을 향상시킬 수 있습니다.\n   * @type {number}\n   * @default 0\n   */\n  public get resizeDebounce() { return this._resizeDebounce; }\n  /**\n   * The maximum time for size recalculation delay when using `resizeDebounce`, in milisecond.\n   * This guarantees that size recalculation is performed at least once every (n)ms.\n   * @ko `resizeDebounce` 사용시에 크기 재계산이 지연되는 최대 시간을 지정합니다. (단위: ms)\n   * 이를 통해, 적어도 (n)ms에 한번은 크기 재계산을 수행하는 것을 보장할 수 있습니다.\n   * @type {number}\n   * @default 100\n   */\n  public get maxResizeDebounce() { return this._maxResizeDebounce; }\n  /**\n   * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\n   * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!\n   * @default null\n   * @internal\n   * @readonly\n   */\n  public get externalRenderer() { return this._externalRenderer; }\n  /**\n   * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\n   * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!\n   * @default null\n   * @internal\n   * @readonly\n   * @deprecated\n   */\n  public get renderExternal() { return this._renderExternal; }\n\n  // Options Setter\n  // UI / LAYOUT\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n    this._renderer.align = val;\n    this._camera.align = val;\n  }\n\n  public set defaultIndex(val: FlickingOptions[\"defaultIndex\"]) { this._defaultIndex = val; }\n  public set horizontal(val: FlickingOptions[\"horizontal\"]) { this._horizontal = val; }\n  public set circular(val: FlickingOptions[\"circular\"]) { this._circular = val; }\n  public set bound(val: FlickingOptions[\"bound\"]) { this._bound = val; }\n  public set adaptive(val: FlickingOptions[\"adaptive\"]) { this._adaptive = val; }\n  public set panelsPerView(val: FlickingOptions[\"panelsPerView\"]) { this._panelsPerView = val; }\n  public set noPanelStyleOverride(val: FlickingOptions[\"noPanelStyleOverride\"]) { this._noPanelStyleOverride = val; }\n  public set resizeOnContentsReady(val: FlickingOptions[\"resizeOnContentsReady\"]) { this._resizeOnContentsReady = val; }\n  // EVENTS\n  public set needPanelThreshold(val: FlickingOptions[\"needPanelThreshold\"]) { this._needPanelThreshold = val; }\n  public set preventEventsBeforeInit(val: FlickingOptions[\"preventEventsBeforeInit\"]) { this._preventEventsBeforeInit = val; }\n  // ANIMATION\n  public set deceleration(val: FlickingOptions[\"deceleration\"]) { this._deceleration = val; }\n  public set easing(val: FlickingOptions[\"easing\"]) { this._easing = val; }\n  public set duration(val: FlickingOptions[\"duration\"]) { this._duration = val; }\n  // INPUT\n  public set inputType(val: FlickingOptions[\"inputType\"]) { this._inputType = val; }\n  public set moveType(val: FlickingOptions[\"moveType\"]) { this._moveType = val; }\n  public set threshold(val: FlickingOptions[\"threshold\"]) { this._threshold = val; }\n  public set interruptable(val: FlickingOptions[\"interruptable\"]) { this._interruptable = val; }\n  public set bounce(val: FlickingOptions[\"bounce\"]) { this._bounce = val; }\n  public set iOSEdgeSwipeThreshold(val: FlickingOptions[\"iOSEdgeSwipeThreshold\"]) { this._iOSEdgeSwipeThreshold = val; }\n  public set preventClickOnDrag(val: FlickingOptions[\"preventClickOnDrag\"]) {\n    const prevVal = this._preventClickOnDrag;\n\n    if (val === prevVal) return;\n\n    const controller = this._control.controller;\n\n    if (val) {\n      controller.addPreventClickHandler();\n    } else {\n      controller.removePreventClickHandler();\n    }\n\n    this._preventClickOnDrag = val;\n  }\n\n  public set disableOnInit(val: FlickingOptions[\"disableOnInit\"]) { this._disableOnInit = val; }\n  // PERFORMANCE\n  public set renderOnlyVisible(val: FlickingOptions[\"renderOnlyVisible\"]) { this._renderOnlyVisible = val; }\n  // OTHERS\n  public set autoResize(val: FlickingOptions[\"autoResize\"]) {\n    this._autoResize = val;\n\n    if (val) {\n      this._autoResizer.enable();\n    } else {\n      this._autoResizer.disable();\n    }\n  }\n\n  public set useResizeObserver(val: FlickingOptions[\"useResizeObserver\"]) {\n    this._useResizeObserver = val;\n\n    if (this._autoResize) {\n      this._autoResizer.enable();\n    }\n  }\n\n  /**\n   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string\n   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>\n   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|\n   * <ko>\n   *\n   * |code|조건|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|\n   *\n   * </ko>\n   * @example\n   * ```ts\n   * import Flicking from \"@egjs/flicking\";\n   *\n   * // Creating new instance of Flicking with HTMLElement\n   * const flicking = new Flicking(document.querySelector(\".flicking-viewport\"), { circular: true });\n   *\n   * // Creating new instance of Flicking with CSS selector\n   * const flicking2 = new Flicking(\".flicking-viewport\", { circular: true });\n   * ```\n   */\n  public constructor(root: HTMLElement | string, {\n    align = ALIGN.CENTER,\n    defaultIndex = 0,\n    horizontal = true,\n    circular = false,\n    circularFallback = CIRCULAR_FALLBACK.LINEAR,\n    bound = false,\n    adaptive = false,\n    panelsPerView = -1,\n    noPanelStyleOverride = false,\n    resizeOnContentsReady = false,\n    needPanelThreshold = 0,\n    preventEventsBeforeInit = true,\n    deceleration = 0.0075,\n    duration = 500,\n    easing = x => 1 - Math.pow(1 - x, 3),\n    inputType = [\"mouse\", \"touch\"],\n    moveType = \"snap\",\n    threshold = 40,\n    interruptable = true,\n    bounce = \"20%\",\n    iOSEdgeSwipeThreshold = 30,\n    preventClickOnDrag = true,\n    disableOnInit = false,\n    renderOnlyVisible = false,\n    virtual = null,\n    autoInit = true,\n    autoResize = true,\n    useResizeObserver = true,\n    resizeDebounce = 0,\n    maxResizeDebounce = 100,\n    externalRenderer = null,\n    renderExternal = null\n  }: Partial<FlickingOptions> = {}) {\n    super();\n\n    // Internal states\n    this._initialized = false;\n    this._plugins = [];\n\n    // Bind options\n    this._align = align;\n    this._defaultIndex = defaultIndex;\n    this._horizontal = horizontal;\n    this._circular = circular;\n    this._circularFallback = circularFallback;\n    this._bound = bound;\n    this._adaptive = adaptive;\n    this._panelsPerView = panelsPerView;\n    this._noPanelStyleOverride = noPanelStyleOverride;\n    this._resizeOnContentsReady = resizeOnContentsReady;\n    this._virtual = virtual;\n    this._needPanelThreshold = needPanelThreshold;\n    this._preventEventsBeforeInit = preventEventsBeforeInit;\n    this._deceleration = deceleration;\n    this._duration = duration;\n    this._easing = easing;\n    this._inputType = inputType;\n    this._moveType = moveType;\n    this._threshold = threshold;\n    this._interruptable = interruptable;\n    this._bounce = bounce;\n    this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;\n    this._preventClickOnDrag = preventClickOnDrag;\n    this._disableOnInit = disableOnInit;\n    this._renderOnlyVisible = renderOnlyVisible;\n    this._autoInit = autoInit;\n    this._autoResize = autoResize;\n    this._useResizeObserver = useResizeObserver;\n    this._resizeDebounce = resizeDebounce;\n    this._maxResizeDebounce = maxResizeDebounce;\n    this._externalRenderer = externalRenderer;\n    this._renderExternal = renderExternal;\n\n    // Create core components\n    this._viewport = new Viewport(getElement(root));\n    this._autoResizer = new AutoResizer(this);\n    this._renderer = this._createRenderer();\n    this._camera = this._createCamera();\n    this._control = this._createControl();\n    this._virtualManager = new VirtualManager(this, virtual);\n\n    if (this._autoInit) {\n      void this.init();\n    }\n  }\n\n  /**\n   * Initialize Flicking and move to the default index\n   * This is automatically called on Flicking's constructor when `autoInit` is true(default)\n   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다\n   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다\n   * @fires Flicking#ready\n   * @return {Promise<void>}\n   */\n  public init(): Promise<void> {\n    if (this._initialized) return Promise.resolve();\n\n    const camera = this._camera;\n    const renderer = this._renderer;\n    const control = this._control;\n    const virtualManager = this._virtualManager;\n    const originalTrigger = this.trigger;\n    const preventEventsBeforeInit = this._preventEventsBeforeInit;\n\n    camera.init();\n    virtualManager.init();\n    renderer.init(this);\n    control.init(this);\n\n    if (preventEventsBeforeInit) {\n      this.trigger = () => this;\n    }\n\n    this._initialResize();\n\n    // Look at initial panel\n    this._moveToInitialPanel();\n\n    if (this._autoResize) {\n      this._autoResizer.enable();\n    }\n    if (this._preventClickOnDrag) {\n      control.controller.addPreventClickHandler();\n    }\n    if (this._disableOnInit) {\n      this.disableInput();\n    }\n    renderer.checkPanelContentsReady(renderer.panels);\n\n    return renderer.render().then(() => {\n      // Done initializing & emit ready event\n      this._plugins.forEach(plugin => plugin.init(this));\n      this._initialized = true;\n      if (preventEventsBeforeInit) {\n        this.trigger = originalTrigger;\n      }\n      this.trigger(new ComponentEvent(EVENTS.READY));\n    });\n  }\n\n  /**\n   * Destroy Flicking and remove all event handlers\n   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this.off();\n\n    this._autoResizer.disable();\n    this._control.destroy();\n    this._camera.destroy();\n    this._renderer.destroy();\n\n    this._plugins.forEach(plugin => plugin.destroy());\n\n    this._initialized = false;\n  }\n\n  /**\n   * Move to the previous panel (current index - 1)\n   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public prev(duration: number = this._duration): Promise<void> {\n    return this.moveTo(this._control.activePanel?.prev()?.index ?? -1, duration, DIRECTION.PREV);\n  }\n\n  /**\n   * Move to the next panel (current index + 1)\n   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public next(duration: number = this._duration) {\n    return this.moveTo(this._control.activePanel?.next()?.index ?? this._renderer.panelCount, duration, DIRECTION.NEXT);\n  }\n\n  /**\n   * Move to the panel with given index\n   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다\n   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public moveTo(index: number, duration: number = this._duration, direction: ValueOf<typeof DIRECTION> = DIRECTION.NONE) {\n    const renderer = this._renderer;\n    const panelCount = renderer.panelCount;\n\n    const panel = renderer.getPanel(index);\n\n    if (!panel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), ERROR.CODE.INDEX_OUT_OF_RANGE));\n    }\n\n    if (this._control.animating) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.ANIMATION_ALREADY_PLAYING, ERROR.CODE.ANIMATION_ALREADY_PLAYING));\n    }\n\n    return this._control.moveToPanel(panel, {\n      duration,\n      direction\n    });\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   * @example\n   * ```ts\n   * const panel = flicking.getPanel(0);\n   * // Which is a shorthand to...\n   * const samePanel = flicking.panels[0];\n   * ```\n   */\n  public getPanel(index: number): Panel | null {\n    return this._renderer.getPanel(index);\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @return {this}\n   */\n  public enableInput(): this {\n    this._control.enable();\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @return {this}\n   */\n  public disableInput(): this {\n    this._control.disable();\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}\n   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다\n   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>\n   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>\n   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>\n   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>\n   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true\n   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>\n   * @return {Status} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus({\n    index = true,\n    position = true,\n    includePanelHTML = false,\n    visiblePanelsOnly = false\n  }: Partial<{\n    index: boolean;\n    position: boolean;\n    includePanelHTML: boolean;\n    visiblePanelsOnly: boolean;\n  }> = {}): Status {\n    const camera = this._camera;\n    const panels = visiblePanelsOnly ? this.visiblePanels : this.panels;\n\n    const status: Status = {\n      panels: panels.map(panel => {\n        const panelInfo: Status[\"panels\"][0] = { index: panel.index };\n\n        if (includePanelHTML) {\n          panelInfo.html = panel.element.outerHTML;\n        }\n\n        return panelInfo;\n      })\n    };\n\n    if (index) {\n      status.index = this.index;\n    }\n    if (position) {\n      const nearestAnchor = camera.findNearestAnchor(camera.position);\n\n      if (nearestAnchor) {\n        status.position = {\n          panel: nearestAnchor.panel.index,\n          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)\n        };\n      }\n\n    }\n\n    if (visiblePanelsOnly) {\n      const visiblePanels = this.visiblePanels;\n\n      status.visibleOffset = visiblePanels[0]?.index ?? 0;\n    }\n\n    return status;\n  }\n\n  /**\n   * Restore to the state of the given {@link Status}\n   * @ko 주어진 {@link Status}의 상태로 복원합니다\n   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>\n   * @return {void}\n   */\n  public setStatus(status: Status): void {\n    if (!this._initialized) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_INITIALIZED, ERROR.CODE.NOT_INITIALIZED);\n    }\n\n    const {\n      index,\n      position,\n      visibleOffset,\n      panels\n    } = status;\n\n    const renderer = this._renderer;\n    const control = this._control;\n\n    // Can't add/remove panels on external rendering\n    if (panels[0]?.html && !this._renderExternal) {\n      renderer.batchRemove({ index: 0, deleteCount: this.panels.length, hasDOMInElements: true });\n      renderer.batchInsert({ index: 0, elements: parseElement(panels.map(panel => panel.html!)), hasDOMInElements: true });\n    }\n\n    if (index) {\n      const panelIndex = visibleOffset\n        ? index - visibleOffset\n        : index;\n\n      void this.moveTo(panelIndex, 0).catch(() => void 0);\n    }\n\n    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {\n      const { panel, progressInPanel } = position;\n      const panelIndex = visibleOffset\n        ? panel - visibleOffset\n        : panel;\n      const panelRange = renderer.panels[panelIndex].range;\n      const newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      void control.moveToPosition(newCameraPos, 0).catch(() => void 0);\n    }\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다\n   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public addPlugins(...plugins: Plugin[]) {\n    if (this._initialized) {\n      plugins.forEach(item => item.init(this));\n    }\n\n    this._plugins.push(...plugins);\n\n    return this;\n  }\n\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거합니다.\n   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public removePlugins(...plugins: Plugin[]) {\n    plugins.forEach(item => {\n      const foundIndex = findIndex(this._plugins, val => val === item);\n\n      if (foundIndex >= 0) {\n        item.destroy();\n        this._plugins.splice(foundIndex, 1);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Update viewport/panel sizes\n   * @ko 패널 및 뷰포트의 크기를 갱신합니다\n   * @method\n   * @fires Flicking#beforeResize\n   * @fires Flicking#afterResize\n   * @return {this}\n   */\n  public async resize(): Promise<void> {\n    const viewport = this._viewport;\n    const renderer = this._renderer;\n    const camera = this._camera;\n    const control = this._control;\n\n    const activePanel = control.activePanel;\n    const prevWidth = viewport.width;\n    const prevHeight = viewport.height;\n    const prevProgressInPanel = activePanel\n      ? camera.getProgressInPanel(activePanel)\n      : 0;\n\n    this.trigger(new ComponentEvent(EVENTS.BEFORE_RESIZE, {\n      width: prevWidth,\n      height: prevHeight,\n      element: viewport.element\n    }));\n\n    viewport.resize();\n    await renderer.forceRenderAllPanels(); // Render all panel elements, to update sizes\n    renderer.updatePanelSize();\n    camera.updateAlignPos();\n    camera.updateRange();\n    camera.updateAnchors();\n    await renderer.render();\n\n    if (control.animating) {\n      // TODO:\n    } else {\n      control.updatePosition(prevProgressInPanel);\n      control.updateInput();\n    }\n\n    const newWidth = viewport.width;\n    const newHeight = viewport.height;\n    const sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;\n\n    this.trigger(new ComponentEvent(EVENTS.AFTER_RESIZE, {\n      width: viewport.width,\n      height: viewport.height,\n      prev: {\n        width: prevWidth,\n        height: prevHeight\n      },\n      sizeChanged,\n      element: viewport.element\n    }));\n  }\n\n  /**\n   * Add new panels after the last panel\n   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#flick\");\n   * // These are possible parameters\n   * flicking.append(document.createElement(\"div\"));\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public append(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(this._renderer.panelCount, element);\n  }\n\n  /**\n   * Add new panels before the first panel\n   * This will increase index of panels after by the number of panels added\n   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다\n   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.prepend(document.createElement(\"div\"));\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.prepend(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public prepend(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(0, element);\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.insert(0, document.createElement(\"div\"));\n   * flicking.insert(2, \"\\<div\\>Panel\\</div\\>\");\n   * flicking.insert(1, [\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.insert(3, \"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public insert(index: number, element: ElementLike | ElementLike[]): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchInsert({ index, elements: parseElement(element), hasDOMInElements: true });\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchRemove({ index, deleteCount, hasDOMInElements: true });\n  }\n\n  private _createControl(): Control {\n    const moveType = this._moveType;\n    const moveTypes = Object.keys(MOVE_TYPE).map(key => MOVE_TYPE[key] as ValueOf<typeof MOVE_TYPE>);\n\n    const moveTypeStr = Array.isArray(moveType)\n      ? moveType[0]\n      : moveType;\n\n    const moveTypeOptions = Array.isArray(moveType)\n      ? moveType[1] ?? {}\n      : {};\n\n    if (!includes(moveTypes, moveTypeStr)) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"moveType\", JSON.stringify(moveType)), ERROR.CODE.WRONG_OPTION);\n    }\n\n    switch (moveTypeStr) {\n      case MOVE_TYPE.SNAP:\n        return new SnapControl(moveTypeOptions as SnapControlOptions);\n      case MOVE_TYPE.FREE_SCROLL:\n        return new FreeControl(moveTypeOptions as FreeControlOptions);\n      case MOVE_TYPE.STRICT:\n        return new StrictControl(moveTypeOptions as StrictControlOptions);\n    }\n  }\n\n  private _createCamera(): Camera {\n    if (this._circular && this._bound) {\n      // eslint-disable-next-line no-console\n      console.warn(\"\\\"circular\\\" and \\\"bound\\\" option cannot be used together, ignoring bound.\");\n    }\n\n    return new Camera(this, {\n      align: this._align\n    });\n  }\n\n  private _createRenderer(): Renderer {\n    const externalRenderer = this._externalRenderer;\n    if (this._virtual && this._panelsPerView <= 0) {\n      // eslint-disable-next-line no-console\n      console.warn(\"\\\"virtual\\\" and \\\"panelsPerView\\\" option should be used together, ignoring virtual.\");\n    }\n\n    return externalRenderer\n      ? externalRenderer\n      : this._renderExternal\n        ? this._createExternalRenderer()\n        : this._createVanillaRenderer();\n  }\n\n  private _createExternalRenderer(): ExternalRenderer {\n    const {\n      renderer,\n      rendererOptions\n    } = this._renderExternal!;\n\n    return new (renderer)({ align: this._align, ...rendererOptions });\n  }\n\n  private _createVanillaRenderer(): VanillaRenderer {\n    const virtual = this.virtualEnabled;\n\n    return new VanillaRenderer({\n      align: this._align,\n      strategy: virtual\n        ? new VirtualRenderingStrategy()\n        : new NormalRenderingStrategy({\n          providerCtor: VanillaElementProvider\n        })\n    });\n  }\n\n  private _moveToInitialPanel(): void {\n    const renderer = this._renderer;\n    const control = this._control;\n    const camera = this._camera;\n    const initialPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);\n\n    if (!initialPanel) return;\n\n    const nearestAnchor = camera.findNearestAnchor(initialPanel.position);\n    control.setActive(initialPanel, null, false);\n\n    if (!nearestAnchor) {\n      throw new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(initialPanel.position), ERROR.CODE.POSITION_NOT_REACHABLE);\n    }\n\n    let position = initialPanel.position;\n\n    if (!camera.canReach(initialPanel)) {\n      position = nearestAnchor.position;\n    }\n\n    camera.lookAt(position);\n    control.updateInput();\n    camera.updateOffset();\n  }\n\n  private _initialResize() {\n    const viewport = this._viewport;\n    const renderer = this._renderer;\n    const camera = this._camera;\n    const control = this._control;\n\n    this.trigger(new ComponentEvent(EVENTS.BEFORE_RESIZE, {\n      width: 0,\n      height: 0,\n      element: viewport.element\n    }));\n\n    viewport.resize();\n    renderer.updatePanelSize();\n    camera.updateAlignPos();\n    camera.updateRange();\n    camera.updateAnchors();\n    camera.updateOffset();\n    control.updateInput();\n\n    const newWidth = viewport.width;\n    const newHeight = viewport.height;\n    const sizeChanged = newWidth !== 0 || newHeight !== 0;\n\n    this.trigger(new ComponentEvent(EVENTS.AFTER_RESIZE, {\n      width: viewport.width,\n      height: viewport.height,\n      prev: {\n        width: 0,\n        height: 0\n      },\n      sizeChanged,\n      element: viewport.element\n    }));\n  }\n}\n\nexport default Flicking;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Viewport from \"./Viewport\";\nimport FlickingError from \"./FlickingError\";\nimport AnchorPoint from \"./AnchorPoint\";\nimport VirtualManager from \"./VirtualManager\";\n\nexport {\n  Viewport,\n  FlickingError,\n  AnchorPoint,\n  VirtualManager\n};\n\nexport * from \"./panel\";\n","import Component from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nconst withFlickingMethods = (prototype: any, flickingName: string) => {\n  [Component.prototype, Flicking.prototype].forEach(proto => {\n    Object.getOwnPropertyNames(proto).filter(name => !prototype[name] && name.indexOf(\"_\") !== 0 && name !== \"constructor\")\n      .forEach((name: string) => {\n        const descriptor = Object.getOwnPropertyDescriptor(proto, name)!;\n\n        if (descriptor.value) {\n          // Public Function\n          Object.defineProperty(prototype, name, {\n            value: function(...args) {\n              return descriptor.value.call(this[flickingName], ...args);\n            }\n          });\n        } else {\n          const getterDescriptor: { get?: () => any; set?: (val: any) => void } = {};\n          if (descriptor.get) {\n            getterDescriptor.get = function() {\n              const flicking = this[flickingName];\n              return flicking && descriptor.get?.call(flicking);\n            };\n          }\n          if (descriptor.set) {\n            getterDescriptor.set = function(...args) {\n              return descriptor.set?.call(this[flickingName], ...args);\n            };\n          }\n\n          Object.defineProperty(prototype, name, getterDescriptor);\n        }\n      });\n  });\n};\n\nexport default withFlickingMethods;\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\nimport Renderer from \"../renderer/Renderer\";\nimport Panel from \"../core/panel/Panel\";\n\nexport default (flicking: Flicking, diffResult: DiffResult<any>, rendered: any[]) => {\n  const renderer = flicking.renderer;\n  const panels = renderer.panels;\n  const prevList = [...diffResult.prevList];\n\n  const added: Panel[] = [];\n  const removed: Panel[] = [];\n\n  if (diffResult.removed.length > 0) {\n    let endIdx = -1;\n    let prevIdx = -1;\n\n    diffResult.removed.forEach(removedIdx => {\n      if (endIdx < 0) {\n        endIdx = removedIdx;\n      }\n\n      if (prevIdx >= 0 && removedIdx !== prevIdx - 1) {\n        removed.push(...batchRemove(renderer, prevIdx, endIdx + 1));\n\n        endIdx = removedIdx;\n        prevIdx = removedIdx;\n      } else {\n        prevIdx = removedIdx;\n      }\n\n      prevList.splice(removedIdx, 1);\n    });\n\n    removed.push(...batchRemove(renderer, prevIdx, endIdx + 1));\n  }\n\n  diffResult.ordered.forEach(([from, to]) => {\n    const prevPanel = panels.splice(from, 1)[0];\n    panels.splice(to, 0, prevPanel);\n  });\n\n  if (diffResult.ordered.length > 0) {\n    panels.forEach((panel, idx) => {\n      const indexDiff = idx - panel.index;\n\n      if (indexDiff > 0) {\n        panel.increaseIndex(indexDiff);\n      } else {\n        panel.decreaseIndex(-indexDiff);\n      }\n    });\n\n    panels.sort((panel1, panel2) => panel1.index - panel2.index);\n\n    panels.forEach(panel => {\n      panel.updatePosition();\n    });\n  }\n\n  if (diffResult.added.length > 0) {\n    let startIdx = -1;\n    let prevIdx = -1;\n\n    const addedElements = rendered.slice(prevList.length);\n\n    diffResult.added.forEach((addedIdx, idx) => {\n      if (startIdx < 0) {\n        startIdx = idx;\n      }\n\n      if (prevIdx >= 0 && addedIdx !== prevIdx + 1) {\n        added.push(...batchInsert(renderer, diffResult, addedElements, startIdx, idx + 1));\n\n        startIdx = -1;\n        prevIdx = -1;\n      } else {\n        prevIdx = addedIdx;\n      }\n    });\n\n    if (startIdx >= 0) {\n      added.push(...batchInsert(renderer, diffResult, addedElements, startIdx));\n    }\n  }\n\n  renderer.updateAfterPanelChange(added, removed);\n};\n\nconst batchInsert = (renderer: Renderer, diffResult: DiffResult<any>, addedElements: any[], startIdx: number, endIdx?: number) => {\n  return renderer.batchInsertDefer(\n    ...diffResult.added.slice(startIdx, endIdx).map((index, elIdx) => ({ index, elements: [addedElements[elIdx]], hasDOMInElements: false }))\n  );\n};\n\nconst batchRemove = (renderer: Renderer, startIdx: number, endIdx?: number) => {\n  const removed = renderer.panels.slice(startIdx, endIdx);\n\n  return renderer.batchRemoveDefer({ index: startIdx, deleteCount: removed.length, hasDOMInElements: false });\n};\n\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\n\nexport default <T>(flicking: Flicking, diffResult: DiffResult<T>) => {\n  const removedPanels = diffResult.removed.reduce((map, idx) => {\n    map[idx] = true;\n    return map;\n  }, {});\n\n  const maintainedMap = diffResult.maintained.reduce((map, [prev, current]) => {\n    map[prev] = current;\n    return map;\n  }, {});\n\n  return [\n    ...flicking.panels\n      .filter(panel => !removedPanels[panel.index])\n      // Sort panels by position\n      .sort((panel1, panel2) => (panel1.position + panel1.offset) - (panel2.position + panel2.offset))\n      .map(panel => diffResult.list[maintainedMap[panel.index]]),\n    ...diffResult.added.map(idx => diffResult.list[idx])\n  ];\n};\n\n","import { FlickingOptions } from \"../Flicking\";\nimport { ALIGN } from \"../const/external\";\nimport { parseArithmeticExpression } from \"../utils\";\n\nexport default (align: FlickingOptions[\"align\"] = ALIGN.CENTER, horizontal: boolean = true, firstPanelSize?: string) => {\n  const cameraAlign = getCameraAlign(align);\n  const panelAlign = getPanelAlign(align);\n\n  if (panelAlign == null) return \"\";\n\n  const camPosition = `calc(${cameraAlign} - (${firstPanelSize || \"0px\"} * ${panelAlign.percentage}) - ${panelAlign.absolute}px)`;\n\n  return horizontal\n    ? `translate(${camPosition})`\n    : `translate(0, ${camPosition})`;\n};\n\nconst getCameraAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { camera: string | number }).camera\n    : align;\n\n  return parseAlign(alignVal);\n};\n\nconst getPanelAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { panel: string | number }).panel\n    : align;\n\n  return parseArithmeticExpression(parseAlign(alignVal));\n};\n\nconst parseAlign = (alignVal: number | string) => {\n  if (typeof alignVal === \"number\") {\n    return `${alignVal}px`;\n  }\n\n  switch (alignVal) {\n    case ALIGN.CENTER:\n      return \"50%\";\n    case ALIGN.NEXT:\n      return \"100%\";\n    case ALIGN.PREV:\n      return \"0%\";\n    default:\n      return alignVal;\n  }\n};\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"./Flicking\";\nimport * as Core from \"./core\";\nimport * as Camera from \"./camera\";\nimport * as Control from \"./control\";\nimport * as Renderer from \"./renderer\";\nimport * as Constants from \"./const/external\";\nimport * as CFC from \"./cfc\";\nimport * as Utils from \"./utils\";\nimport { merge } from \"./utils\";\n\nmerge(Flicking, Core);\nmerge(Flicking, Camera);\nmerge(Flicking, Control);\nmerge(Flicking, Renderer);\nmerge(Flicking, Constants);\nmerge(Flicking, CFC);\nmerge(Flicking, Utils);\n\nexport default Flicking;\n"],"names":["CODE","WRONG_TYPE","ELEMENT_NOT_FOUND","VAL_MUST_NOT_NULL","NOT_ATTACHED_TO_FLICKING","WRONG_OPTION","INDEX_OUT_OF_RANGE","POSITION_NOT_REACHABLE","TRANSFORM_NOT_SUPPORTED","STOP_CALLED_BY_USER","ANIMATION_INTERRUPTED","ANIMATION_ALREADY_PLAYING","NOT_ALLOWED_IN_FRAMEWORK","NOT_INITIALIZED","NO_ACTIVE","NOT_ALLOWED_IN_VIRTUAL","MESSAGE","wrongVal","correctTypes","map","type","join","selector","val","name","optionName","min","max","position","EVENTS","READY","BEFORE_RESIZE","AFTER_RESIZE","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","WILL_CHANGE","CHANGED","WILL_RESTORE","RESTORED","SELECT","NEED_PANEL","VISIBLE_CHANGE","REACH_EDGE","PANEL_CHANGE","ALIGN","PREV","CENTER","NEXT","DIRECTION","NONE","MOVE_TYPE","SNAP","FREE_SCROLL","STRICT","CLASS","VERTICAL","HIDDEN","DEFAULT_VIRTUAL","CIRCULAR_FALLBACK","LINEAR","BOUND","merge","target","_i","sources","forEach","source","Object","keys","key","getElement","el","parent","targetEl","isString","parentEl","document","queryResult","querySelector","FlickingError","ERROR","nodeType","Node","ELEMENT_NODE","checkExistence","value","nameOnErrMsg","clamp","x","Math","getFlickingAttached","toArray","iterable","slice","call","parseAlign","align","size","alignPoint","parseArithmeticSize","parseBounce","bounce","parsedBounce","Array","isArray","parsedVal","cssValue","base","parsed","parseArithmeticExpression","percentage","absolute","cssRegex","idx","matchResult","exec","sign","unit","parsedValue","parseFloat","signMultiplier","parseCSSSizeValue","parsePanelAlign","panel","getDirection","start","end","parseElement","element","elements","tempDiv","createElement","innerHTML","push","children","firstChild","removeChild","getMinusCompensatedIndex","includes","array","array_1","__values","circulatePosition","pos","offset","find","checker","array_2","findRight","length","findIndex","getProgress","prev","next","getStyle","window","getComputedStyle","currentStyle","setSize","_a","width","height","style","isBetween","circulateIndex","index","range","arr","i","setPrototypeOf","obj","proto","__proto__","__extends","message","code","_super","_this","prototype","Error","_el","_width","_height","_padding","left","right","top","bottom","_isBorderBoxSizing","padding","isBorderBoxSizing","newWidth","newHeight","resize","elStyle","clientWidth","clientHeight","paddingLeft","paddingRight","paddingTop","paddingBottom","boxSizing","flicking","_flicking","resizeDebounce","maxResizeDebounce","_maxResizeDebounceTimer","setTimeout","_doScheduledResize","_resizeTimer","clearTimeout","isFirstResize","_onResize","_enabled","_resizeObserver","viewport","disable","useResizeObserver","ResizeObserver","viewportSizeNot0","resizeObserver","_skipFirstResize","observe","addEventListener","disconnect","removeEventListener","_element","_rendered","cameraEl","camera","parentElement","appendChild","_virtualElement","nativeElement","visible","elIndex","_panel","elementIndex","virtualElements","virtual","options","_renderPanel","renderPanel","_initialPanelCount","initialPanelCount","_cache","cache","_panelClass","panelClass","_elements","renderer","panels","uncacheRenderResult","virtualEnabled","externalRenderer","renderExternal","_initVirtualElements","nativeEl","display","count","insert","batchInsert","hasDOMInElements","batchRemove","deleteCount","cameraElement","panelsPerView","fragment","createDocumentFragment","newElements","panelEl","className","dataset","toString","EVENT","HOLD","CHANGE","RELEASE","ANIMATION_END","FINISH","POSITION_KEY","STATE_TYPE","_delta","_targetPanel","prevState","ctx","axesEvent","transitTo","delta","AXES","prevPosition","newPosition","circularEnabled","lookAt","moveEvent","ComponentEvent","isTrusted","holding","direction","trigger","isCanceled","DISABLED","panelCount","holdStartEvent","HOLDING","controller","control","animatingContext","moveStartEvent","ANIMATING","onChange","State","inputEvent","horizontal","offsetX","offsetY","DRAGGING","flick","setTo","IDLE","_releaseEvent","releaseEvent","srcEvent","clickedElement","touchEvent","touch","changedTouches","elementFromPoint","clientX","clientY","clickedPanel","panels_1","contains","cameraPosition","clickedPanelPosition","_moveToChangedPosition","destPos","duration","moveToPosition","updateInput","setActive","activePanel","stop","nextStateType","nextState","IdleState","HoldingState","DraggingState","AnimatingState","DisabledState","onEnter","_state","eventType","externalCtx","currentState","onHold","onRelease","onAnimationEnd","onFinish","_dragged","e","preventDefault","stopPropagation","_resetInternalValues","_stateMachine","StateMachine","_axes","state","_animatingContext","axes","circular","axis","_panInput","isEnable","get","Axes","deceleration","interruptable","easing","PanInput","inputType","iOSEdgeSwipeThreshold","scale","releaseOnScroll","connect","on","fire","removePreventClickHandler","destroy","enable","controlParams","axm","set","_onAxesHold","_onAxesChange","_preventClickWhenDragged","off","Promise","reject","startPos","targetPanel","resolve","animate","resetContext","once","_b","newPos","animationFinishHandler","interruptionHandler","_controller","AxesController","_activePanel","animating","init","_progressInPanel","clampToReachablePosition","update","nearestAnchor","findNearestAnchor","removed","canReach","camPos_1","camRangeDiff","rangeDiff","possiblePositions","filter","reduce","nearestPosition","abs","Infinity","_triggerIndexChangeEvent","_animateToPosition","newActivePanel","prevActivePanel","updateAdaptiveHeight","prevIndex","prevPanel","triggeringEvent","event","animateTo","then","render","catch","err","_index","_pos","_count","activeAnchor","findActiveAnchor","anchorAtCamera","snapThreshold","_calcSnapThreshold","posDelta","absPosDelta","snapDelta","targetAnchor","_findSnappedAnchor","threshold","_findAdjacentAnchor","currentPos","clampedPosition","anchorAtPosition","findAnchorIncludePosition","isFinite","anchors","anchorPoints","loopCount","floor","circularIndexOffset","anchorAtPositionIndex","anchor","AnchorPoint","loop","adjacentAnchor","getNextAnchor","getPrevAnchor","isNextDirection","panelSize","alignPos","alignPosition","margin","Control","stopAtEdge","_stopAtEdge","progressInPanel","panelRange","targetPos","_resetIndexRange","cameraRange","currentIndex","prevPanelIndex","nextPanelIndex","nextPanel","prevPos","nextPos","_indexRange","moveToPanel","axesRange","indexRange","isOverThreshold","firstAnchor","lastAnchor","shouldBounceToFirst","shouldBounceToLast","anchorsIncludingPosition","includePosition","nearest","panelPos","visibleRange","isVisibleOnRange","firstPanel","getPanel","lastPanel","CameraMode","firstPanelPrev","lastPanelNext","visibleSize","panelSizeSum","canSetCircularMode","every","anchorCount","positionInRange","anchorInRange","possibleAnchors","toggled","toggledPrev","toggleDirection","toggledNext","_calcPanelAreaSum","visibleInCurrentRange","canSee","sum","sizeIncludingMargin","viewportSize","panelAreaSize","isBiggerThanViewport","firstPos","lastPos","alignVal","reachablePanels","shouldPrependBoundAnchor","shouldAppendBoundAnchor","indexOffset_1","newAnchors","splice","nearestPanelAtMin","_findNearestPanel","panelAtMin","panelAtMax","prevDist","panelIdx","dist","transforms","supportedStyle","documentElement","transformName","transforms_1","prefixedTransform","_transform","_align","_position","_alignPos","_offset","_circularOffset","_circularEnabled","_mode","_range","_visiblePanels","_anchors","NaN","nearestPanel","bounceSize","prevRange","nextRange","nextPosition","viewportEl","firstElementChild","_checkTranslateSupport","_updateMode","_togglePanels","_refreshVisiblePanels","_checkNeedPanel","_checkReachEnd","updateOffset","applyTransform","anchorIdx","activeIndex","getRange","updateCircularToggleDirection","getAnchors","adaptive","unRenderedPanels","rendered","getCircularOffset","_needPanelTriggered","rendering","actualPosition","newVisiblePanels","prevVisiblePanels","added","visiblePanels","needPanelTriggered","cameraSize","needPanelThreshold","cameraPrev","cameraNext","wasBetweenRange","isBetweenRange","circularMode","CircularCameraMode","checkAvailability","fallbackMode","circularFallback","BoundCameraMode","LinearCameraMode","bound","toggle","some","isToggled","strategy","_panels","_rendering","_strategy","panelAlign","_collectPanels","markForShow","_updatePanelSizeByGrid","items","allPanelsInserted","batchInsertDefer","updateAfterPanelChange","prevFirstPanel","addedPanels","item","insertingIdx","panelsPushed","panelsInserted","_createPanel","_insertPanelElements","increaseIndex","updatePosition","allPanelsRemoved","batchRemoveDefer","removingIdx","panelsPulled","panelsRemoved","decreaseIndex","_removePanelElements","resetActive","panelsAdded","_updateCameraAndControl","targetIndex","checkPanelContentsReady","checkingPanels","resizeOnContentsReady","hasContents","contentsReadyChecker","ImReady","loading","prevProgressInPanel","getProgressInPanel","panelBehind","initialized","updateRange","updateAnchors","readyCount","totalCount","check","resetNeedPanelHistory","visibleIndexes","visibles","markForHide","referencePanel","gap","panelSizeObj","firstPanelSizeObj","noPanelStyleOverride","updatePanelSizes","nextSibling","nextSiblingElement","insertBefore","updateRenderingPanels","renderPanels","_resetPanelElementOrder","_removeAllTextNodes","collectPanels","createPanel","reversedElements","getRenderingElementsByOrder","reverse","nextEl","nextElementSibling","childNodes","node","TEXT_NODE","Renderer","elementProvider","_elProvider","_removed","_loading","_resetInternalStates","_size","_margin","_toggled","_toggleDirection","cameraRangeDiff","progress","camPos","disappearPosNext","disappearPosPrev","checkingRange","show","hide","cached","offsetWidth","offsetHeight","marginLeft","marginRight","marginTop","marginBottom","_updateAlignPos","includeMargin","includeRange","moveTo","togglePosition","_togglePosition","prevToggled","camRange","camAlignPosition","camVisibleRange","camVisibleSize","minimumVisible","maximumVisible","shouldBeVisibleAtMin","shouldBeVisibleAtMax","providerCtor","_providerCtor","renderedPanels","notToggled","__spread","getRenderingIndexesByOrder","renderOnlyVisible","_showOnlyVisiblePanels","Panel","_cachedInnerHTML","virtualElCount","result","newInnerHTML","cacheRenderResult","virtualManager","invisibleIndexes","sort","panel1","panel2","_","VirtualPanel","VirtualElementProvider","root","_c","_d","defaultIndex","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","preventEventsBeforeInit","_q","_r","_s","pow","_t","_u","moveType","_v","_w","_x","_y","_z","preventClickOnDrag","_0","disableOnInit","_1","_2","_3","autoInit","_4","autoResize","_5","_6","_7","_8","_9","_initialized","_plugins","_defaultIndex","_horizontal","_circular","_circularFallback","_bound","_adaptive","_panelsPerView","_noPanelStyleOverride","_resizeOnContentsReady","_virtual","_needPanelThreshold","_preventEventsBeforeInit","_deceleration","_duration","_easing","_inputType","_moveType","_threshold","_interruptable","_bounce","_iOSEdgeSwipeThreshold","_preventClickOnDrag","_disableOnInit","_renderOnlyVisible","_autoInit","_autoResize","_useResizeObserver","_resizeDebounce","_maxResizeDebounce","_externalRenderer","_renderExternal","_viewport","Viewport","_autoResizer","AutoResizer","_renderer","_createRenderer","_camera","_createCamera","_control","_createControl","_virtualManager","VirtualManager","prevVal","addPreventClickHandler","originalTrigger","_initialResize","_moveToInitialPanel","disableInput","plugin","includePanelHTML","visiblePanelsOnly","status","panelInfo","html","outerHTML","visibleOffset","panelIndex","newCameraPos","plugins","foundIndex","prevWidth","prevHeight","forceRenderAllPanels","updatePanelSize","updateAlignPos","sizeChanged","moveTypes","moveTypeStr","moveTypeOptions","JSON","stringify","SnapControl","FreeControl","StrictControl","console","warn","Camera","_createExternalRenderer","_createVanillaRenderer","rendererOptions","VanillaRenderer","VirtualRenderingStrategy","NormalRenderingStrategy","VanillaElementProvider","initialPanel","Flicking","Component","withFlickingMethods","flickingName","getOwnPropertyNames","indexOf","descriptor","getOwnPropertyDescriptor","defineProperty","args","getterDescriptor","diffResult","prevList","endIdx_1","prevIdx_1","removedIdx","ordered","__read","from","to","indexDiff","startIdx_1","prevIdx_2","addedElements_1","addedIdx","addedElements","startIdx","endIdx","elIdx","removedPanels","maintainedMap","maintained","current","list","firstPanelSize","cameraAlign","getCameraAlign","getPanelAlign","camPosition","Core","Constants","CFC","Utils"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}