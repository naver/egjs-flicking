{"version":3,"file":"flicking.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e8d2426817cc3d27be4d","webpack:///src/browser.js","webpack:///src/consts.js","webpack:///src/Flicking.js","webpack:///src/config.js","webpack:///src/eventHandler.js","webpack:///src/index.js","webpack:///src/utils.js","webpack:///external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}","webpack:///external {\"commonjs\":\"@egjs/movablecoord\",\"commonjs2\":\"@egjs/movablecoord\",\"amd\":\"@egjs/movablecoord\",\"root\":[\"eg\",\"MovableCoord\"]}"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@egjs/component\"), require(\"@egjs/movablecoord\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Flicking\", [\"@egjs/component\", \"@egjs/movablecoord\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Flicking\"] = factory(require(\"@egjs/component\"), require(\"@egjs/movablecoord\"));\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"Flicking\"] = factory(root[\"eg\"][\"Component\"], root[\"eg\"][\"MovableCoord\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e8d2426817cc3d27be4d","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable no-new-func, no-nested-ternary */\nconst win = typeof window !== \"undefined\" &&\n\twindow.Math === Math ?\n        window : typeof self !== \"undefined\" && self.Math === Math ?\n            self : Function(\"return this\")();\n/* eslint-enable no-new-func, no-nested-ternary */\n\nconst document = win.document;\n\nexport {\n    win as window,\n    document\n};\n\n\n\n// WEBPACK FOOTER //\n// src/browser.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport {window as global, document as doc} from \"./browser\";\n\n// define custom events name\nconst EVENTS = {\n\tbeforeFlickStart: \"beforeFlickStart\",\n\tbeforeRestore: \"beforeRestore\",\n\tflick: \"flick\",\n\tflickEnd: \"flickEnd\",\n\trestore: \"restore\"\n};\n\n// check for css transform support\nconst SUPPORT_TRANSFORM = (() => {\n\tconst style = doc.documentElement.style;\n\n\treturn \"transform\" in style || \"webkitTransform\" in style;\n})();\n\n// check for will-change support\nconst SUPPORT_WILLCHANGE = global.CSS && global.CSS.supports &&\n\tglobal.CSS.supports(\"will-change\", \"transform\");\n\n// check for Android 2.x\nconst IS_ANDROID2 = /Android 2\\./.test(navigator.userAgent);\n\n// data-height attribute's name for adaptiveHeight option\nconst DATA_HEIGHT = \"data-height\";\n\nexport {\n\tEVENTS,\n\tSUPPORT_TRANSFORM,\n\tSUPPORT_WILLCHANGE,\n\tIS_ANDROID2,\n\tDATA_HEIGHT\n};\n\n\n\n// WEBPACK FOOTER //\n// src/consts.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component from \"@egjs/component\";\nimport MovableCoord from \"@egjs/movablecoord\";\nimport {utils, Mixin} from \"./utils\";\nimport * as consts from \"./consts\";\nimport {CONFIG, OPTIONS} from \"./config\";\nimport {document} from \"./browser\";\nimport eventHandler from \"./eventHandler\";\n\n/**\n * A module used to implement flicking interactions. With this module, you can make flicking gestures, which are ways to navigate left and right to move between panels arranged side by side.\n * @ko 플리킹 UI를 구현하는 모듈. 나란히 배치한 패널을 쓸어 넘겨 다음 패널이나 이전 패널로 이동하는 플리킹 UI를 만들 수 있다.\n * @alias eg.Flicking\n * @extends eg.Component\n *\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.3+ (except 3.x)\"}\n */\nexport default class Flicking extends Mixin(Component).with(eventHandler) {\n\t/**\n\t * Constructor\n\t * @param {HTMLElement|String|jQuery} element A base element for the eg.Flicking module <ko>eg.Flicking 모듈을 사용할 기준 엘리먼트</ko>\n\t* @param {Object} options The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n\t* @param {Boolean} [options.hwAccelerable=eg.isHWAccelerable()] Force hardware compositing <ko>하드웨어 가속 사용 여부</ko>\n\t* @param {String} [options.prefix=eg-flick] A prefix for class names of the panel elements <ko>패널 엘리먼트의 클래스 이름에 설정할 접두사</ko>\n\t* @param {Number} [options.deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>\n\t* @param {Boolean} [options.horizontal=true] Direction of the panel movement (true: horizontal, false: vertical) <ko>패널 이동 방향 (true 가로방향, false 세로방향)</ko>\n\t* @param {Boolean} [options.circular=false] Indicates whether a circular panel is available <ko>패널 순환 여부</ko>\n\t* @param {Number|Array} [options.previewPadding=[0,0]] The preview size for the previous or next panel. If direction is set to \"horizontal\", the preview section will be displayed on the left and right of the panel. If direction is set to \"vertical\", it will be displayed on the top and bottom of the panel <ko>이전 패널과 다음 패널을 미리 보는 영역의 크기. 패널 이동 방향이 가로 방향이면 패널 왼쪽과 오른쪽에 미리 보는 영역이 나타난다. 패널 이동 방향이 세로 방향이면 패널 위쪽과 아래쪽에 미리 보는 영역이 나타난다</ko>\n\t* @param {Number|Array} [options.bounce=[10,10]] −\tThe size of bouncing area. If a panel is set to \"non-circulable\", the start and end panels can exceed the base element area and move further as much as the bouncing area. If a panel is dragged to the bouncing area and then dropped, the panel where bouncing effects are applied is retuned back into the base element area. <ko>바운스 영역의 크기. 패널이 순환하지 않도록 설정됐다면 시작 패널과 마지막 패널은 기준 엘리먼트 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 패널을 바운스 영역까지 끌었다가 놓으면, 바운스 효과가 적용된 패널이 다시 기준 엘리먼트 영역 안으로 들어온다</ko>\n\t* @param {Number} [options.threshold=40] Distance threshold. If the drag exceeds the threshold value, it will be changed to the next panel <ko>다음 패널로 바뀌는 기준 이동 거리. 패널을 기준 이동 거리 이상 끌었다 놓으면 패널이 다음 패널로 바뀐다</ko>\n\t* @param {Number} [options.duration=100] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t* @param {Function} [options.panelEffect=easeOutCubic] The easing function to apply to a panel moving animation <ko>패널 이동 애니메이션에 적용할 easing 함수</ko>\n\t* @param {Number} [options.defaultIndex=0] The index number of a panel to be selected upon module initialization <ko>모듈이 초기화될 때 선택할 패널의 인덱스 번호</ko>\n\t* @param {Array} [options.inputType] Types of input devices.<br>- touch: A touch screen can be used to move a panel.<br>- mouse: A mouse can be used to move a panel. <ko>입력 장치 종류.<br>- touch: 터치 입력 장치로 패널을 이동할 수 있다.<br>- mouse: 마우스로 패널을 이동할 수 있다.</ko>\n\t* @param {Number} [options.thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>\n\t* @param {Boolean} [options.adaptiveHeight=false] Set container's height be adaptive according panel's height.<br>(Note: on Android 4.1.x stock browser, has rendering bug which not correctly render height value on panel with single node. To avoid just append another empty node at the end.)<ko>컨테이너 영역이 패널의 높이값에 따라 변경될지 여부<br>(참고: Android 4.1.x 스톡 브라우저에서 단일 노드로 구성된 패널의 높이값 변경이 제대로 렌더링 되지 않는 버그가 있음. 비어있는 노드를 추가하면 해결이 가능하다.)</ko>\n\t*\n * @see Easing Functions Cheat Sheet {@link http://easings.net/}\n * @see If you want to try a different easing function, use the jQuery easing plugin ({@link http://gsgd.co.uk/sandbox/jquery/easing}) or the jQuery UI easing library ({@link https://jqueryui.com/easing}). <ko>다른 easing 함수를 사용하려면 jQuery easing 플러그인({@link http://gsgd.co.uk/sandbox/jquery/easing})이나, jQuery UI easing 라이브러리({@link https://jqueryui.com/easing})를 사용한다</ko>\n\t*/\n\tconstructor(element, options, _prefix) {\n\t\tsuper();\n\n\t\tthis.$wrapper = utils.$(element);\n\t\tconst $children = this.$wrapper && this.$wrapper.children;\n\n\t\tif (!this.$wrapper || !$children || !$children.length) {\n\t\t\t// eslint-disable validateLineBreaks, maximumLineLength\n\t\t\tthrow new Error(\"Given base element doesn't exist or it hasn't proper DOM structure to be initialized.\");\n\n\t\t\t// eslint-enable validateLineBreaks, maximumLineLength\n\t\t}\n\n\t\tthis._setOptions(options);\n\t\tthis._setConfig($children, _prefix);\n\n\t\t!utils.hasClickBug() && (this._setPointerEvents = () => {});\n\n\t\tthis._build();\n\t\tthis._bindEvents(true);\n\n\t\tthis._applyPanelsCss();\n\t\tthis._arrangePanels();\n\n\t\tthis.options.hwAccelerable && consts.SUPPORT_WILLCHANGE && this._setHint();\n\t\tthis.options.adaptiveHeight && this._setAdaptiveHeight();\n\n\t\tthis._adjustContainerCss(\"end\");\n\t}\n\n\t/**\n\t * Set options values\n\t * @param {Object} options\n\t */\n\t_setOptions(options) {\n\t\t// default value of previewPadding and bounce\n\t\tconst arrVal = {\n\t\t\tpreviewPadding: [0, 0],\n\t\t\tbounce: [10, 10]\n\t\t};\n\n\t\tthis.options = utils.extend(utils.extend({}, OPTIONS), arrVal, options);\n\n\t\tfor (const key in arrVal) {\n\t\t\tlet val = this.options[key];\n\n\t\t\tif (typeof(val) === \"number\") {\n\t\t\t\tval = [val, val];\n\t\t\t} else if (!utils.isArray(val)) {\n\t\t\t\tval = arrVal[key];\n\t\t\t}\n\n\t\t\tthis.options[key] = val;\n\t\t}\n\t}\n\n\t/**\n\t * Set config values\n\t * @param {HTMLCollection} $children wrappers' children elements\n\t * @param {String} _prefix event prefix\n\t * @return {HTMLElement}\n\t */\n\t_setConfig($children, _prefix) {\n\t\tconst options = this.options;\n\t\tconst padding = options.previewPadding;\n\t\tlet $nodes = $children;\n\n\t\tif ($nodes[0].classList.contains(`${options.prefix}-container`)) {\n\t\t\t$nodes = $nodes[0];\n\t\t\tthis.$container = $nodes;\n\t\t\t$nodes = $nodes.children;\n\t\t}\n\n\t\t// convert to array\n\t\t$nodes = [].slice.call($nodes);\n\n\t\t// config value\n\t\tconst conf = this._conf = utils.extend(utils.extend({}, CONFIG), {\n\t\t\tpanel: {\n\t\t\t\t$list: $nodes,\n\t\t\t\tminCount: padding[0] + padding[1] > 0 ? 5 : 3  // minimum panel count\n\t\t\t},\n\t\t\t// remember original class and inline style in case of restoration on destroy()\n\t\t\torigPanelStyle: {\n\t\t\t\twrapper: {\n\t\t\t\t\tclassName: this.$wrapper.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: this.$wrapper.getAttribute(\"style\") || null\n\t\t\t\t},\n\t\t\t\tcontainer: {\n\t\t\t\t\tclassName: (this.$container && this.$container.getAttribute(\"class\")) || null,\n\t\t\t\t\tstyle: (this.$container && this.$container.getAttribute(\"style\")) || null\n\t\t\t\t},\n\t\t\t\tlist: $nodes.map(v => ({\n\t\t\t\t\tclassName: v.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: v.getAttribute(\"style\") || null\n\t\t\t\t}))\n\t\t\t},\n\t\t\tuseLayerHack: options.hwAccelerable && !consts.SUPPORT_WILLCHANGE,\n\t\t\teventPrefix: _prefix || \"\"\n\t\t});\n\n\t\t[[\"LEFT\", \"RIGHT\"], [\"UP\", \"DOWN\"]][+!options.horizontal]\n\t\t\t.forEach(v => conf.dirData.push(MovableCoord[`DIRECTION_${v}`]));\n\t}\n\n\t/**\n\t * Build and set panel nodes to make flicking structure\n\t */\n\t_build() {\n\t\tconst panel = this._conf.panel;\n\t\tconst options = this.options;\n\t\tconst $children = panel.$list;\n\t\tconst padding = options.previewPadding.concat();\n\t\tconst prefix = options.prefix;\n\t\tconst horizontal = options.horizontal;\n\t\tlet panelCount = panel.count = panel.origCount = $children.length;\n\t\tconst bounce = options.bounce;\n\n\t\tthis._setPadding(padding, true);\n\t\tconst sizeValue = this._getDataByDirection([panel.size, \"100%\"]);\n\n\t\t// container element style\n\t\tconst cssValue = {\n\t\t\tposition: \"relative\",\n\t\t\tzIndex: 2000,\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\"\n\t\t};\n\n\t\thorizontal && (cssValue.top = \"0px\");\n\n\t\tif (this.$container) {\n\t\t\tutils.css(this.$container, cssValue);\n\t\t} else {\n\t\t\tconst $parent = $children[0].parentNode;\n\t\t\tconst $container = document.createElement(\"div\");\n\n\t\t\t$container.className = `${prefix}-container`;\n\t\t\tutils.css($container, cssValue);\n\n\t\t\t$children.forEach(v => $container.appendChild(v));\n\n\t\t\t$parent.appendChild($container);\n\t\t\tthis.$container = $container;\n\t\t}\n\n\t\t// panels' css values\n\t\t$children.forEach(v => {\n\t\t\tv.classList.add(`${prefix}-panel`);\n\n\t\t\tutils.css(v, {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\twidth: utils.getUnitValue(sizeValue[0]),\n\t\t\t\theight: utils.getUnitValue(sizeValue[1]),\n\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t});\n\t\t});\n\n\t\tif (this._addClonePanels()) {\n\t\t\tpanelCount = panel.count = (\n\t\t\t\tpanel.$list = [].slice.call(this.$container.children)\n\t\t\t).length;\n\t\t}\n\n\t\t// create MovableCoord instance\n\t\tthis._mcInst = new MovableCoord({\n\t\t\tmin: [0, 0],\n\t\t\tmax: this._getDataByDirection([panel.size * (panelCount - 1), 0]),\n\t\t\tmargin: 0,\n\t\t\tcircular: false,\n\t\t\teasing: options.panelEffect,\n\t\t\tdeceleration: options.deceleration,\n\t\t\tbounce: this._getDataByDirection([0, bounce[1], 0, bounce[0]])\n\t\t});\n\n\t\tthis._setDefaultPanel(options.defaultIndex);\n\t}\n\n\t/**\n\t * Set preview padding value\n\t * @param {Array} padding\n\t * @param {Boolean} build\n\t */\n\t_setPadding(padding, build) {\n\t\tconst horizontal = this.options.horizontal;\n\t\tconst panel = this._conf.panel;\n\t\tconst paddingSum = padding[0] + padding[1];\n\t\tconst cssValue = {};\n\n\t\tif (paddingSum || !build) {\n\t\t\tcssValue.padding = horizontal ?\n\t\t\t\t`0 ${padding.reverse().join(\"px 0 \")}px` :\n\t\t\t\t`${padding.join(\"px 0 \")}px`;\n\t\t}\n\n\t\tif (build) {\n\t\t\tcssValue.overflow = \"hidden\";\n\t\t\tcssValue.boxSizing = \"border-box\";\n\t\t}\n\n\t\tObject.keys(cssValue).length &&\n\t\tutils.css(this.$wrapper, cssValue);\n\n\t\tconst wrapperStyle = getComputedStyle(this.$wrapper);\n\t\tconst paddingType = horizontal ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"];\n\n\t\tpanel.size = utils.getNumValue(wrapperStyle[horizontal ? \"width\" : \"height\"]) - (\n\t\t\t\tutils.getNumValue(wrapperStyle[`padding${paddingType[0]}`]) +\n\t\t\t\tutils.getNumValue(wrapperStyle[`padding${paddingType[1]}`])\n\t\t\t);\n\t}\n\n\t/**\n\t * To fulfill minimum panel count cloning original node when circular or previewPadding option are set\n\t * @return {Boolean} true : added clone node, false : not added\n\t */\n\t_addClonePanels() {\n\t\tconst panel = this._conf.panel;\n\t\tconst panelCount = panel.origCount;\n\t\tconst cloneCount = panel.minCount - panelCount;\n\t\tconst list = panel.$list;\n\t\tlet cloneNodes;\n\n\t\t// if panels are given less than required when circular option is set, then clone node to apply circular mode\n\t\tif (this.options.circular && panelCount < panel.minCount) {\n\t\t\tcloneNodes = list.map(v => v.cloneNode(true));\n\n\t\t\twhile (cloneNodes.length < cloneCount) {\n\t\t\t\tcloneNodes = cloneNodes.concat(\n\t\t\t\t\tlist.map(v => v.cloneNode(true))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcloneNodes.forEach(v => this.$container.appendChild(v));\n\n\t\t\treturn !!cloneNodes.length;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Move panel's position within array\n\t * @param {Number} count element counts to move\n\t * @param {Boolean} append where the list to be appended(moved) (true: to the end, false: to the beginning)\n\t */\n\t_movePanelPosition(count, append) {\n\t\tconst panel = this._conf.panel;\n\t\tconst list = panel.$list;\n\t\tconst listToMove = list.splice(append ? 0 : panel.count - count, count);\n\n\t\tpanel.$list = append ?\n\t\t\tlist.concat(listToMove) :\n\t\t\tlistToMove.concat(list);\n\t}\n\n\t/**\n\t * Set default panel to show\n\t * @param {Number} index\n\t */\n\t_setDefaultPanel(index) {\n\t\tconst panel = this._conf.panel;\n\t\tconst lastIndex = panel.count - 1;\n\t\tlet coords;\n\t\tlet baseIndex;\n\n\t\tif (this.options.circular) {\n\t\t\t// if default index is given, then move correspond panel to the first position\n\t\t\tif (index > 0 && index <= lastIndex) {\n\t\t\t\tthis._movePanelPosition(index, true);\n\t\t\t}\n\n\t\t\t// set first panel's position according physical node length\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\t\t\tthis._movePanelPosition(baseIndex, false);\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tno: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\t\t\t// if defaultIndex option is given, then move to that index panel\n\t\t} else if (index > 0 && index <= lastIndex) {\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex,\n\t\t\t\tno: index,\n\t\t\t\tcurrIndex: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\n\t\t\tcoords = [-(panel.size * index), 0];\n\n\t\t\tthis._setTranslate(coords);\n\t\t\tthis._setMovableCoord(\"setTo\", [\n\t\t\t\tMath.abs(coords[0]), Math.abs(coords[1])\n\t\t\t], true, 0);\n\t\t}\n\t}\n\n\t/**\n\t * Arrange panels' position\n\t * @param {Boolean} sort Need to sort panel's position\n\t * @param {Number} indexToMove Number to move from current position (negative: left, positive: right)\n\t */\n\t_arrangePanels(sort, indexToMove) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst touch = conf.touch;\n\t\tconst dirData = conf.dirData;\n\t\tlet baseIndex;\n\n\t\tif (this.options.circular) {\n\t\t\t// when arranging panels, set flag to not trigger flick custom event\n\t\t\tconf.customEvent.flick = false;\n\n\t\t\t// move elements according direction\n\t\t\tif (sort) {\n\t\t\t\tindexToMove && (touch.direction = dirData[+!(indexToMove > 0)]);\n\t\t\t\tthis._arrangePanelPosition(touch.direction, indexToMove);\n\t\t\t}\n\n\t\t\t// set index for base element's position\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex: baseIndex,\n\t\t\t\tcurrIndex: baseIndex\n\t\t\t});\n\n\t\t\t// arrange MovableCoord's coord position\n\t\t\tconf.customEvent.flick = !!this._setMovableCoord(\"setTo\", [\n\t\t\t\tpanel.size * panel.index, 0\n\t\t\t], true, 0);\n\t\t}\n\n\t\tthis._applyPanelsPos();\n\t}\n\n\t/**\n\t * Set each panel's position in DOM\n\t */\n\t_applyPanelsPos() {\n\t\tthis._conf.panel.$list.forEach(this._applyPanelsCss.bind(this));\n\t}\n\n\t/**\n\t * Set CSS style values to move elements\n\t *\n\t * Initialize setting up checking if browser support transform css property.\n\t * If browser doesn't support transform, then use left/top properties instead.\n\t * @param {HTMLElement} $element\n\t * @param {Array} coords\n\t */\n\t_setMoveStyle($el, coordsValue) {\n\t\tthis._setMoveStyle = consts.SUPPORT_TRANSFORM ?\n\t\t\tfunction moveStyle($element, coords) {\n\t\t\t\tutils.css($element, {\n\t\t\t\t\ttransform: utils.translate(coords[0], coords[1], this._conf.useLayerHack)\n\t\t\t\t});\n\t\t\t} : ($element, coords) => {\n\t\t\t\tutils.css($element, {left: coords[0], top: coords[1]});\n\t\t\t};\n\n\t\tthis._setMoveStyle($el, coordsValue);\n\t}\n\n\t/**\n\t * Callback function for applying CSS values to each panels\n\t *\n\t * Need to be initialized before use, to set up for Android 2.x browsers or others.\n\t */\n\t_applyPanelsCss() {\n\t\tconst conf = this._conf;\n\t\tconst dummyAnchorClassName = \"__dummy_anchor\";\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tconf.$dummyAnchor = utils.$(`.${dummyAnchorClassName}`);\n\n\t\t\t!conf.$dummyAnchor && this.$wrapper.appendChild(\n\t\t\t\t\tconf.$dummyAnchor = utils.$(`<a href=\"javascript:void(0)\" class=\"${dummyAnchorClassName}\" style=\"position:absolute;height:0px;width:0px\">`)\n\t\t\t\t);\n\n\t\t\tthis._applyPanelsCss = function applyCss(v, i) {\n\t\t\t\tconst coords = this._getDataByDirection([\n\t\t\t\t\t`${this._conf.panel.size * i}px`, 0\n\t\t\t\t]);\n\n\t\t\t\tutils.css(v, {\n\t\t\t\t\tleft: coords[0],\n\t\t\t\t\ttop: coords[1]\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis._applyPanelsCss = function applyCss(v, i) {\n\t\t\t\tconst coords = this._getDataByDirection([\n\t\t\t\t\tconsts.SUPPORT_TRANSFORM ?\n\t\t\t\t\t\t`${100 * i}%` :\n\t\t\t\t\t\t`${this._conf.panel.size * i}px`, 0\n\t\t\t\t]);\n\n\t\t\t\tthis._setMoveStyle(v, coords);\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Adjust container's css value to handle Android 2.x link highlighting bug\n\t *\n\t * @param {String} phase\n\t *    start - set left/top value to 0\n\t *    end - set translate value to 0\n\t * @param {Array} coordValue coordinate value\n\t */\n\t_adjustContainerCss(phase, coordValue) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst options = this.options;\n\t\tconst horizontal = options.horizontal;\n\t\tconst paddingTop = options.previewPadding[0];\n\t\tlet container = this.$container;\n\t\tlet coords = coordValue;\n\t\tlet value;\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tif (!coords) {\n\t\t\t\tcoords = [-panel.size * panel.index, 0];\n\t\t\t}\n\n\t\t\tif (phase === \"start\") {\n\t\t\t\tcontainer = container.style;\n\t\t\t\tvalue = parseInt(container[horizontal ? \"left\" : \"top\"], 10);\n\n\t\t\t\tif (horizontal) {\n\t\t\t\t\tvalue && (container.left = \"0px\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue !== paddingTop && (container.top = \"0px\");\n\t\t\t\t}\n\n\t\t\t\tthis._setTranslate([-coords[+!options.horizontal], 0]);\n\t\t\t} else if (phase === \"end\") {\n\t\t\t\tcoords = this._getCoordsValue(coords);\n\n\t\t\t\tutils.css(container, {\n\t\t\t\t\tleft: coords.x,\n\t\t\t\t\ttop: coords.y,\n\t\t\t\t\ttransform: utils.translate(0, 0, conf.useLayerHack)\n\t\t\t\t});\n\n\t\t\t\tconf.$dummyAnchor.focus();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set MovableCoord coord value\n\t * @param {String} method\n\t * @param {Array} coordValue\n\t * @param {Boolean} isDirVal\n\t * @param {Number} duration\n\t * @return {eg.MovableCoord} MovableCoord instance\n\t */\n\t_setMovableCoord(method, coordValue, isDirVal, duration) {\n\t\tlet coord = coordValue;\n\n\t\tif (isDirVal) {\n\t\t\tcoord = this._getDataByDirection(coord);\n\t\t}\n\n\t\treturn this._mcInst[method](coord[0], coord[1], duration);\n\t}\n\n\t/**\n\t * Set hint for browser to decide efficient way of doing transform changes(or animation)\n\t * https://dev.opera.com/articles/css-will-change-property/\n\t */\n\t_setHint() {\n\t\tconst style = {willChange: \"transform\"};\n\n\t\tutils.css(this.$container, style);\n\t\tutils.css(this._conf.panel.$list, style);\n\t}\n\n\t/**\n\t * Get data according options.horizontal value\n\t *\n\t * @param {Array} value primary data to handle\n\t * @return {Array}\n\t */\n\t_getDataByDirection(value) {\n\t\tconst data = value.concat();\n\n\t\t!this.options.horizontal && data.reverse();\n\t\treturn data;\n\t}\n\n\t/**\n\t * Move nodes\n\t * @param {Boolean} direction\n\t * @param {Number} indexToMove\n\t */\n\t_arrangePanelPosition(direction, indexToMove) {\n\t\tconst next = direction === this._conf.dirData[0];\n\n\t\tthis._movePanelPosition(Math.abs(indexToMove || 1), next);\n\t}\n\n\t/**\n\t * Get the base position index of the panel\n\t */\n\t_getBasePositionIndex() {\n\t\treturn Math.floor(this._conf.panel.count / 2 - 0.1);\n\t}\n\n\t/**\n\t * Bind events\n\t * @param {Boolean} bind\n\t */\n\t_bindEvents(bind) {\n\t\tconst options = this.options;\n\t\tconst $wrapper = this.$wrapper;\n\t\tconst mcInst = this._mcInst;\n\n\t\tif (bind) {\n\t\t\tmcInst.bind($wrapper, {\n\t\t\t\tscale: this._getDataByDirection([-1, 0]),\n\t\t\t\tdirection: MovableCoord[`DIRECTION_${options.horizontal ? \"HORIZONTAL\" : \"VERTICAL\"}`],\n\t\t\t\tinterruptable: false,\n\t\t\t\tinputType: options.inputType,\n\t\t\t\tthresholdAngle: options.thresholdAngle\n\t\t\t}).on({\n\t\t\t\thold: this._holdHandler.bind(this),\n\t\t\t\tchange: this._changeHandler.bind(this),\n\t\t\t\trelease: this._releaseHandler.bind(this),\n\t\t\t\tanimationStart: this._animationStartHandler.bind(this),\n\t\t\t\tanimationEnd: this._animationEndHandler.bind(this)\n\t\t\t});\n\t\t} else {\n\t\t\tmcInst.unbind($wrapper).off();\n\t\t}\n\t}\n\n\t/**\n\t * Set container's height value according to children's height\n\t * @param {Number} direction\n\t */\n\t_setAdaptiveHeight(direction) {\n\t\tconst conf = this._conf;\n\t\tconst indexToMove = conf.indexToMove;\n\t\tlet $children;\n\t\tlet height;\n\n\t\tconst $panel = indexToMove === 0 ?\n\n\t\t\t// panel moved by 1\n\t\t\tthis[`get${\n\t\t\t\t(direction === MovableCoord.DIRECTION_LEFT && \"Next\") ||\n\t\t\t\t(direction === MovableCoord.DIRECTION_RIGHT && \"Prev\") || \"\"\n\t\t\t}Element`]() :\n\n\t\t\t// panel moved by .moveTo()\n\t\t\tconf.panel.$list[\n\t\t\t\tconf.panel.currIndex + indexToMove\n\t\t\t];\n\n\t\tconst $first = $panel.querySelector(\":first-child\");\n\n\t\tif ($first) {\n\t\t\theight = $first.getAttribute(consts.DATA_HEIGHT);\n\n\t\t\tif (!height) {\n\t\t\t\t$children = $panel.children;\n\n\t\t\t\theight = utils.outerHeight(\n\t\t\t\t\t$children.length > 1 ? ($panel.style.height = \"auto\", $panel) : $first\n\t\t\t\t);\n\n\t\t\t\theight > 0 && $first.setAttribute(consts.DATA_HEIGHT, height);\n\t\t\t}\n\n\t\t\theight > 0 && (this.$wrapper.style.height = `${height}px`);\n\t\t}\n\t}\n\n\t/**\n\t * Trigger beforeRestore event\n\t * @param {Object} e event object\n\t */\n\t_triggerBeforeRestore(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\n\t\t// reverse direction value when restore\n\t\ttouch.direction = ~~conf.dirData.join(\"\").replace(touch.direction, \"\");\n\n\t\t/**\n\t\t * This event is fired before an element is restored to its original position when user action is done while the element is not dragged until a certain distance threshold is reached\n\t\t * @ko 다음 패널로 바뀌는 기준 이동 거리만큼 이동하기 전에 사용자의 동작이 끝났을 때 원래 패널로 복원되기 전에 발생하는 이벤트\n\t\t * @name eg.Flicking#beforeRestore\n\t\t * @event\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM. (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다. (@deprecated since 1.3.0)</ko>\n\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content.<ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t * @param {Array} param.depaPos Start coordinate <ko>출발점 좌표</ko>\n\t\t * @param {Number} param.depaPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t * @param {Number} param.depaPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t * @param {Array} param.destPos End coordinate <ko>도착점 좌표</ko>\n\t\t * @param {Number} param.destPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t * @param {Number} param.destPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t */\n\t\tconf.customEvent.restore = this._triggerEvent(consts.EVENTS.beforeRestore, {\n\t\t\tdepaPos: e.depaPos,\n\t\t\tdestPos: e.destPos\n\t\t});\n\n\t\tif (!conf.customEvent.restore) {\n\t\t\t\"stop\" in e && e.stop();\n\t\t\tconf.panel.animating = false;\n\t\t}\n\t}\n\n\t/**\n\t * Trigger restore event\n\t */\n\t_triggerRestore() {\n\t\tconst customEvent = this._conf.customEvent;\n\n\t\t/**\n\t\t * This event is fired after an element is restored to its original position when user action is done while the element is not dragged until a certain distance threshold is reached.\n\t\t * @ko 다음 패널로 바뀌는 기준 이동 거리만큼 이동하기 전에 사용자의 동작이 끝났을 때 원래 패널로 복원된 다음 발생하는 이벤트\n\t\t * @name eg.Flicking#restore\n\t\t * @event\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM(@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content. <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t * @param {Number} param.direction Direction of the panel move (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t */\n\t\tcustomEvent.restore && this._triggerEvent(consts.EVENTS.restore);\n\t\tcustomEvent.restoreCall = false;\n\t}\n\n\t/**\n\t * Set value when panel changes\n\t * @param {String} phase - [start|end]\n\t * @param {Object} pos\n\t */\n\t_setPhaseValue(phase, pos) {\n\t\tconst conf = this._conf;\n\t\tconst options = this.options;\n\t\tconst panel = conf.panel;\n\n\t\tif (phase === \"start\" && (panel.changed = this._isMovable())) {\n\t\t\t/**\n\t\t\t * This event is fired before flicking starts\n\t\t\t * @ko 플리킹이 시작하기 전에 발생하는 이벤트\n\t\t\t * @name eg.Flicking#beforeFlickStart\n\t\t\t * @event\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM. (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content.<ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t\t * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>−\t이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t\t * @param {Array} param.depaPos Start coordinate <ko>출발점 좌표</ko>\n\t\t\t * @param {Number} param.depaPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t\t * @param {Number} param.depaPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t\t * @param {Array} param.destPos End coordinate <ko>도착점 좌표</ko>\n\t\t\t * @param {Number} param.destPos.0 x-coordinate <ko>x 좌표</ko>\n\t\t\t * @param {Number} param.destPos.1 y-coordinate <ko>y 좌표</ko>\n\t\t\t */\n\t\t\tif (!this._triggerEvent(consts.EVENTS.beforeFlickStart, pos)) {\n\t\t\t\tpanel.changed = panel.animating = false;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\toptions.adaptiveHeight && this._setAdaptiveHeight(conf.touch.direction);\n\t\t\t}\n\n\t\t\tconf.indexToMove === 0 && this._setPanelNo();\n\t\t} else if (phase === \"end\") {\n\t\t\tif (options.circular && panel.changed) {\n\t\t\t\tthis._arrangePanels(true, conf.indexToMove);\n\t\t\t}\n\n\t\t\t!consts.IS_ANDROID2 && this._setTranslate([-panel.size * panel.index, 0]);\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\n\t\t\t/**\n\t\t\t * This event is fired after panel moves.\n\t\t\t * @ko 패널이 이동한 다음 발생하는 이벤트\n\t\t\t * @name eg.Flicking#flickEnd\n\t\t\t * @event\n\t\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t\t * @param {String} param.eventType The name of the event <ko>이름명</ko>\n\t\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content. <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t\t\t * @param {Number} param.direction Direction of the movemen (see eg.MovableCoord.DIRECTION_* constant) <ko>−\t이동 방향(eg.MovableCoord.DIRECTION_* constant 참고</ko>\n\t\t\t */\n\t\t\tpanel.changed && this._triggerEvent(consts.EVENTS.flickEnd);\n\t\t}\n\n\t\tthis._adjustContainerCss(phase);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get positive or negative according direction\n\t */\n\t_getNumByDirection() {\n\t\tconst conf = this._conf;\n\n\t\treturn conf.touch.direction === conf.dirData[0] ? 1 : -1;\n\t}\n\n\t/**\n\t * Revert panel number\n\t */\n\t_revertPanelNo() {\n\t\tconst panel = this._conf.panel;\n\t\tconst num = this._getNumByDirection();\n\n\t\tconst index = panel.currIndex >= 0 ? panel.currIndex : panel.index - num;\n\t\tconst no = panel.currNo >= 0 ? panel.currNo : panel.no - num;\n\n\t\tthis._setPanelNo({\n\t\t\tindex,\n\t\t\tno\n\t\t});\n\t}\n\n\t/**\n\t * Set the panel number\n\t * @param {Object} obj number object\n\t */\n\t_setPanelNo(obj) {\n\t\tconst panel = this._conf.panel;\n\t\tconst count = panel.origCount - 1;\n\t\tconst num = this._getNumByDirection();\n\n\t\tif (utils.isObject(obj)) {\n\t\t\tfor (const key in obj) {\n\t\t\t\tpanel[key] = obj[key];\n\t\t\t}\n\t\t} else {\n\t\t\t// remember current value\n\t\t\tpanel.currIndex = panel.index;\n\t\t\tpanel.currNo = panel.no;\n\n\t\t\tpanel.index += num;\n\t\t\tpanel.no += num;\n\t\t}\n\n\t\tif (panel.no > count) {\n\t\t\tpanel.no = 0;\n\t\t} else if (panel.no < 0) {\n\t\t\tpanel.no = count;\n\t\t}\n\t}\n\n\t/**\n\t * Set pointerEvents css property on container element due to the iOS click bug\n\t * @param {Event} e\n\t */\n\t_setPointerEvents(e) {\n\t\tconst pointer = utils.css(this.$container, \"pointerEvents\");\n\t\tlet val;\n\n\t\tif (e && e.holding &&\n\t\t\te.hammerEvent && e.hammerEvent.preventSystemEvent &&\n\t\t\tpointer !== \"none\"\n\t\t) {\n\t\t\tval = \"none\";\n\t\t} else if (!e && pointer !== \"auto\") {\n\t\t\tval = \"auto\";\n\t\t}\n\n\t\tval && utils.css(this.$container, {pointerEvents: val});\n\t}\n\n\t/**\n\t * Get coordinate value with unit\n\t * @param coords {Array} x,y numeric value\n\t * @return {Object} x,y coordinate value with unit\n\t */\n\t_getCoordsValue(coordsValue) {\n\t\t// the param comes as [ val, 0 ], whatever the direction. So reorder the value depend the direction.\n\t\tconst coords = this._getDataByDirection(coordsValue);\n\n\t\treturn {\n\t\t\tx: utils.getUnitValue(coords[0]),\n\t\t\ty: utils.getUnitValue(coords[1])\n\t\t};\n\t}\n\n\t/**\n\t * Set translate property value\n\t * @param {Array} coords coordinate x,y value\n\t */\n\t_setTranslate(coordsValue) {\n\t\tconst coords = this._getCoordsValue(coordsValue);\n\n\t\tthis._setMoveStyle(this.$container, [coords.x, coords.y]);\n\t}\n\n\t/**\n\t * Check if panel passed through threshold pixel\n\t */\n\t_isMovable() {\n\t\tconst options = this.options;\n\t\tconst mcInst = this._mcInst;\n\t\tconst isMovable = Math.abs(this._conf.touch.distance) >= options.threshold;\n\t\tlet max;\n\t\tlet currPos;\n\n\t\tif (!options.circular && isMovable) {\n\t\t\tmax = this._getDataByDirection(mcInst.options.max)[0];\n\t\t\tcurrPos = this._getDataByDirection(mcInst.get())[0];\n\n\t\t\t// if current position out of range\n\t\t\tif (currPos < 0 || currPos > max) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn isMovable;\n\t}\n\n\t/**\n\t * Trigger custom events\n\t * @param {String} name - event name\n\t * @param {Object} param - additional event value\n\t * @return {Boolean}\n\t */\n\t_triggerEvent(name, param) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\n\t\t// pass changed panel no only on 'flickEnd' event\n\t\tif (name === consts.EVENTS.flickEnd) {\n\t\t\tpanel.currNo = panel.no;\n\t\t\tpanel.currIndex = panel.index;\n\t\t}\n\n\t\treturn this.trigger(conf.eventPrefix + name, utils.extend({\n\t\t\teventType: name,\n\t\t\tindex: panel.currIndex,\n\t\t\tno: panel.currNo,\n\t\t\tdirection: conf.touch.direction\n\t\t}, param));\n\t}\n\n\t/**\n\t * Get next/prev panel element/index.\n\t * @param {Boolean} direction\n\t * @param {Boolean} element - true:to get element, false:to get index\n\t * @param {Number} physical - true : physical, false : logical\n\t * @return {HTMLElement|Number}\n\t */\n\t_getElement(direction, element, physical) {\n\t\tconst panel = this._conf.panel;\n\t\tconst circular = this.options.circular;\n\t\tconst pos = panel.currIndex;\n\t\tconst next = direction === this._conf.dirData[0];\n\t\tlet result = null;\n\t\tlet total;\n\t\tlet index;\n\n\t\tif (physical) {\n\t\t\ttotal = panel.count;\n\t\t\tindex = pos;\n\t\t} else {\n\t\t\ttotal = panel.origCount;\n\t\t\tindex = panel.currNo;\n\t\t}\n\n\t\tconst currentIndex = index;\n\n\t\tif (next) {\n\t\t\tif (index < total - 1) {\n\t\t\t\tindex++;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (index > 0) {\n\t\t\t\tindex--;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = total - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (currentIndex !== index) {\n\t\t\tresult = element ? panel.$list[next ? pos + 1 : pos - 1] : index;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Set value to force move panels when duration is 0\n\t * @param {Boolean} next\n\t */\n\t_setValueToMove(next) {\n\t\tconst conf = this._conf;\n\n\t\tconf.touch.distance = this.options.threshold + 1;\n\t\tconf.touch.direction = conf.dirData[+!next];\n\t}\n\n\t/**\n\t * Returns the index number of the current panel element.\n\t * @ko 현재 패널 엘리먼트의 인덱스 번호를 반환한다\n\t * @method eg.Flicking#getIndex\n\t * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t * @return {Number} Index number of the current panel element <ko>현재 패널의 인덱스 번호</ko>\n\t */\n\tgetIndex(physical) {\n\t\treturn this._conf.panel[physical ? \"currIndex\" : \"currNo\"];\n\t}\n\n\t/**\n\t * Returns the reference of the current panel element.\n\t * @ko 현재 패널 엘리먼트의 레퍼런스를 반환한다\n\t * @method eg.Flicking#getElement\n\t * @return {HTMLElement} Current element <ko>현재 엘리먼트</ko>\n\t */\n\tgetElement() {\n\t\tconst panel = this._conf.panel;\n\n\t\treturn panel.$list[panel.currIndex];\n\t}\n\n\t/**\n\t * Returns the reference of the next panel element.\n\t * @ko 다음 패널 엘리먼트의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getNextElement\n\t * @return {HTMLElement|null} Next panel element or null if it does not exist.<ko>다음 패널 엘리먼트. 패널이 없으면 'null'을 반환한다.</ko>\n\t */\n\tgetNextElement() {\n\t\treturn this._getElement(this._conf.dirData[0], true);\n\t}\n\n\t/**\n\t * Returns the index number of the next panel element.\n\t * @ko 다음 패널 엘리먼트의 인덱스 번호를 반환한다\n\t * @method eg.Flicking#getNextIndex\n\t * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t * @return {Number|null} Index number of the next panel element or null if it does not exist. <ko>다음 패널 엘리먼트의 인덱스 번호. 패널이 없으면 'null'을 반환한다</ko>\n\t */\n\tgetNextIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[0], false, physical);\n\t}\n\n\t/**\n\t * Returns the references of whole panel elements.\n\t * @ko 패널을 구성하는 모든 엘리먼트의 레퍼런스를 반환한다\n\t * @method eg.Flicking#getAllElements\n\t * @return {HTMLElement} Whole panel elements <ko>모든 패널 엘리먼트</ko>\n\t */\n\tgetAllElements() {\n\t\treturn this._conf.panel.$list;\n\t}\n\n\t/**\n\t * Returns the reference of the previous panel element.\n\t * @ko 이전 패널 엘리먼트의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getPrevElement\n\t * @return {HTMLElement|null} Previous panel element or null if it does not exist. <ko>이전 패널 엘리먼트. 패널이 없으면 'null'을 반환한다</ko>\n\t */\n\tgetPrevElement() {\n\t\treturn this._getElement(this._conf.dirData[1], true);\n\t}\n\n\t/**\n\t * Returns the index number of the previous panel element.\n\t * @ko 이전 패널 엘리먼트의 인덱스 번호를 반환한다\n\t * @method eg.Flicking#getPrevIndex\n\t * @param {Boolean} [physical=false] Types of index numbers<br>- true: Indicates physical index numbers relative to DOM.<br>- false: Indicates logical index numbers relative to the panel content. <ko>−\t인덱스 번호의 종류<br>- true: 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다.<br>- false: 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다.</ko>\n\t * @return {Number|null} Previous element index value or null if no more element exist<ko>이전 패널 인덱스 번호. 패널이 없는 경우에는 null</ko>\n\t */\n\tgetPrevIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[1], false, physical);\n\t}\n\n\t/**\n\t * Returns the total number of whole panel elements.\n\t * @ko 전체 패널 엘리먼트의 개수를 반환한다\n\t * @method eg.Flicking#getTotalCount\n\t * @deprecated since 1.3.0\n\t * @param {Boolean} [physical=false] Number of elements relative to (true: DOM, false: panel content)<ko>엘리먼트 개수의 기준(true: DOM 엘리먼트 기준, false: 패널 콘텐츠 기준)</ko>\n\t * @return {Number} Total number of whole panel elements <ko>모든 패널 엘리먼트의 개수</ko>\n\t */\n\tgetTotalCount(physical) {\n\t\treturn this._conf.panel[physical ? \"count\" : \"origCount\"];\n\t}\n\n\t/**\n\t * Checks whether the animated panel is playing.\n\t * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n\t * @method eg.Flicking#isPlaying\n\t * @return {Boolean} Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n\t */\n\tisPlaying() {\n\t\treturn this._conf.panel.animating;\n\t}\n\n\t/**\n\t * Move panel to the given direction\n\t * @param {Boolean} next\n\t * @param {Number} duration\n\t */\n\t_movePanel(next, duration) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst options = this.options;\n\n\t\tif (panel.animating || conf.touch.holding) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._setValueToMove(next);\n\n\t\tif (options.circular ||\n\t\t\tthis[next ? \"getNextIndex\" : \"getPrevIndex\"]() != null\n\t\t) {\n\t\t\tthis._movePanelByPhase(\"setBy\", [\n\t\t\t\tpanel.size * (next ? 1 : -1), 0\n\t\t\t], duration);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Move panel applying start/end phase value\n\t * @param {String} method movableCoord method name\n\t * @param {Object} coords coordinate array value\n\t * @param {Number} durationValue duration value\n\t */\n\t_movePanelByPhase(method, coords, durationValue) {\n\t\tconst duration = utils.getNumValue(durationValue, this.options.duration);\n\n\t\tif (this._setPhaseValue(\"start\") !== false) {\n\t\t\tthis._setMovableCoord(method, coords, true, duration);\n\t\t\t!duration && this._setPhaseValue(\"end\");\n\t\t}\n\t}\n\n\t/**\n\t * Moves an element to the next panel.\n\t * @ko 다음 패널로 이동한다.\n\t * @method eg.Flicking#next\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t */\n\tnext(duration) {\n\t\treturn this._movePanel(true, duration);\n\t}\n\n\t/**\n\t * Moves an element to the previous panel.\n\t * @ko 이전 패널로 이동한다.\n\t * @method eg.Flicking#prev\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tprev(duration) {\n\t\treturn this._movePanel(false, duration);\n\t}\n\n\t/**\n\t * Moves an element to the indicated panel.\n\t * @ko 지정한 패널로 이동한다.\n\t * @method eg.Flicking#moveTo\n\t * @param {Number} no Logical index number of the target panel element, which is relative to the panel content. <ko>이동할 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t */\n\tmoveTo(noValue, duration) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst circular = this.options.circular;\n\t\tconst currentIndex = panel.index;\n\t\tlet indexToMove;\n\t\tlet isPositive;\n\t\tlet no = noValue;\n\n\t\tno = utils.getNumValue(no, -1);\n\n\t\tif (no < 0 || no >= panel.origCount || no === panel.no ||\n\t\t\tpanel.animating || conf.touch.holding) {\n\t\t\treturn this;\n\t\t}\n\n\t\tindexToMove = no - (circular ? panel.no : currentIndex);\n\t\tisPositive = indexToMove > 0;\n\n\t\t// check for real panel count which can be moved on each sides in circular mode\n\t\tif (circular &&\n\t\t\tMath.abs(indexToMove) >\n\t\t\t(isPositive ? panel.count - (currentIndex + 1) : currentIndex)) {\n\t\t\tindexToMove += (isPositive ? -1 : 1) * panel.count;\n\t\t\tisPositive = indexToMove > 0;\n\t\t}\n\n\t\tthis._setPanelNo(circular ? {no} : {no, index: no});\n\t\tthis._conf.indexToMove = indexToMove;\n\t\tthis._setValueToMove(isPositive);\n\n\t\tthis._movePanelByPhase(\n\t\t\tcircular ? \"setBy\" : \"setTo\",\n\t\t\t[panel.size * (circular ? indexToMove : no), 0],\n\t\t\tduration\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Updates the size of the panel.\n\t * @ko 패널의 크기를 갱신한다\n\t * @method eg.Flicking#resize\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t let some = new eg.Flicking(\"#mflick\", {\n\t\t\t\t\tpreviewPadding: [10,10]\n\t\t\t\t});\n\n\t // when device orientaion changes\n\t some.resize();\n\n\t // or when changes previewPadding option from its original value\n\t some.options.previewPadding = [20, 30];\n\t some.resize();\n\t */\n\tresize() {\n\t\tconst conf = this._conf;\n\t\tconst options = this.options;\n\t\tconst panel = conf.panel;\n\t\tconst horizontal = options.horizontal;\n\t\tlet panelSize;\n\n\t\tif (~~options.previewPadding.join(\"\")) {\n\t\t\tthis._setPadding(options.previewPadding.concat());\n\t\t\tpanelSize = panel.size;\n\t\t} else if (horizontal) {\n\t\t\tpanelSize = panel.size = utils.css(this.$wrapper, \"width\", true);\n\t\t}\n\n\t\tconst maxCoords = this._getDataByDirection(\n\t\t\t[panelSize * (panel.count - 1), 0]\n\t\t);\n\n\t\t// resize elements\n\t\thorizontal && utils.css(this.$container, {width: `${maxCoords[0] + panelSize}px`});\n\t\tutils.css(panel.$list, {\n\t\t\t[horizontal ? \"width\" : \"height\"]: utils.getUnitValue(panelSize)\n\t\t});\n\n\t\t// remove data-height attribute and re-evaluate panel's height\n\t\tif (options.adaptiveHeight) {\n\t\t\tconst $panel = this.$container.querySelectorAll(`[${consts.DATA_HEIGHT}]`);\n\n\t\t\tif ($panel.length) {\n\t\t\t\t[].slice.call($panel)\n\t\t\t\t\t.forEach(v => v.removeAttribute(consts.DATA_HEIGHT));\n\n\t\t\t\tthis._setAdaptiveHeight();\n\t\t\t}\n\t\t}\n\n\t\tthis._mcInst.options.max = maxCoords;\n\t\tthis._setMovableCoord(\"setTo\", [panelSize * panel.index, 0], true, 0);\n\n\t\tif (consts.IS_ANDROID2) {\n\t\t\tthis._applyPanelsPos();\n\t\t\tthis._adjustContainerCss(\"end\");\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restores an element to its original position when it movement stops while the element is not dragged until a certain distance threshold is reached.\n\t * @ko 다음 패널로 바뀌기 전에 패널 이동이 멈췄을 때 원래 패널로 복원한다\n\t * @method eg.Flicking#restore\n\t * @param {Number} [durationValue=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * let some = new eg.Flicking(\"#mflick\").on({\n\t *\t\t\t\tbeforeFlickStart : function(e) {\n\t *\t\t\t\t\tif(e.no === 2) {\n\t *\t\t\t\t\t\te.stop();  // stop flicking\n\t *\t\t\t\t\t\tthis.restore(100);  // restoring to previous position\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t);\n\t */\n\trestore(durationValue) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst currPos = this._getDataByDirection(this._mcInst.get());\n\t\tlet duration = durationValue;\n\t\tlet destPos;\n\n\t\t// check if the panel isn't in right position\n\t\tif (currPos[0] !== panel.currIndex * panel.size) {\n\t\t\tconf.customEvent.restoreCall = true;\n\t\t\tduration = utils.getNumValue(duration, this.options.duration);\n\n\t\t\tthis._revertPanelNo();\n\t\t\tdestPos = this._getDataByDirection([panel.size * panel.index, 0]);\n\n\t\t\tthis._triggerBeforeRestore({depaPos: currPos, destPos});\n\t\t\tthis._setMovableCoord(\"setTo\", destPos, true, duration);\n\n\t\t\tif (!duration) {\n\t\t\t\tthis._adjustContainerCss(\"end\");\n\t\t\t\tthis._triggerRestore();\n\t\t\t}\n\n\t\t\t// to handle on api call\n\t\t} else if (panel.changed) {\n\t\t\tthis._revertPanelNo();\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enables input devices.\n\t * @ko 입력 장치를 사용할 수 있게 한다\n\t * @method eg.Flicking#enableInput\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t */\n\tenableInput() {\n\t\tthis._mcInst.enableInput();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Disables input devices.\n\t * @ko 입력 장치를 사용할 수 없게 한다.\n\t * @method eg.Flicking#disableInput\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t */\n\tdisableInput() {\n\t\tthis._mcInst.disableInput();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get current flicking status\n\t * @ko 현재의 상태 값을 반환한다.\n\t * @method eg.Flicking#getStatus\n\t * @param {Boolean} stringify Set true if want get stringified status value <ko>상태 값을 문자열로 전달받고자 하는지 여부</ko>\n\t * @return {{panel: {index: (*|number), no: (*|number), currIndex: number, currNo: number}, $list}}\n\t */\n\tgetStatus(stringify) {\n\t\tconst panel = this._conf.panel;\n\t\tconst rxStyle = /(transform|left|top|will-change|box-sizing|width):[^;]*;/g;\n\t\tconst status = {\n\t\t\t// current panel position\n\t\t\tpanel: {\n\t\t\t\tindex: panel.index,\n\t\t\t\tno: panel.no,\n\t\t\t\tcurrIndex: panel.currIndex,\n\t\t\t\tcurrNo: panel.currNo\n\t\t\t},\n\n\t\t\t// panel's html\n\t\t\t$list: panel.$list.map(v => ({\n\t\t\t\tstyle: v.style.cssText.replace(rxStyle, \"\").trim(),\n\t\t\t\tclassName: v.className,\n\t\t\t\thtml: v.innerHTML\n\t\t\t}))\n\t\t};\n\n\t\treturn stringify ?\n\t\t\tJSON.stringify(status) : status;\n\t}\n\n\t/**\n\t * Set flicking as given status\n\t * @method eg.Flicking#setStatus\n\t * @param {Object|String} statusValue status value to be restored <ko>복원할 상태 값</ko>\n\t */\n\tsetStatus(statusValue) {\n\t\tconst panel = this._conf.panel;\n\t\tconst isAdaptiveHeight = this.options.adaptiveHeight;\n\t\tconst status = typeof statusValue === \"string\" ?\n\t\t\tJSON.parse(statusValue) : statusValue;\n\n\t\tif (status) {\n\t\t\tfor (const x in status.panel) {\n\t\t\t\tx in panel && (panel[x] = status.panel[x]);\n\t\t\t}\n\n\t\t\tpanel.$list.forEach((v, i) => {\n\t\t\t\tconst data = status.$list[i];\n\t\t\t\tconst style = data.style;\n\t\t\t\tconst className = data.className;\n\t\t\t\tconst html = data.html;\n\n\t\t\t\tstyle && (v.style.cssText += style);\n\t\t\t\tclassName && (v.className = className);\n\t\t\t\thtml && (v.innerHTML = html);\n\t\t\t});\n\n\t\t\tisAdaptiveHeight && this._setAdaptiveHeight();\n\t\t}\n\t}\n\n\t/**\n\t * Destroys elements, properties, and events used in a panel.\n\t * @ko 패널에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n\t * @method eg.Flicking#destroy\n\t */\n\tdestroy() {\n\t\tconst conf = this._conf;\n\t\tconst origPanelStyle = conf.origPanelStyle;\n\t\tconst wrapper = origPanelStyle.wrapper;\n\t\tconst container = origPanelStyle.container;\n\t\tconst list = origPanelStyle.list;\n\n\t\t// unwrap container element and restore original inline style\n\t\t// restore wrapper style\n\t\tconst $wrapper = this.$wrapper;\n\n\t\t$wrapper.setAttribute(\"class\", wrapper.className);\n\t\t$wrapper[wrapper.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", wrapper.style);\n\n\t\t// restore container style\n\t\tconst $container = this.$container;\n\t\tconst $children = []\n\t\t\t.slice.call($container.children);\n\n\t\tif (origPanelStyle.container.className) {\n\t\t\t$container.setAttribute(\"class\", container.className);\n\t\t\t$container[container.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", container.style);\n\t\t} else {\n\t\t\t$children.forEach(v => $wrapper.appendChild(v));\n\t\t\t$container.parentNode.removeChild($container);\n\t\t}\n\n\t\tfor (let i = 0, $el; ($el = $children[i]); i++) {\n\t\t\tif (i > list.length - 1) {\n\t\t\t\t$el.parentNode.removeChild($el);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst className = list[i].className;\n\t\t\tconst style = list[i].style;\n\n\t\t\t$el[className ? \"setAttribute\" : \"removeAttribute\"](\"class\", className);\n\t\t\t$el[style ? \"setAttribute\" : \"removeAttribute\"](\"style\", style);\n\t\t}\n\n\t\t// unbind events\n\t\tthis._bindEvents(false);\n\t\tthis.off();\n\n\t\t// release resources\n\t\tfor (const x in this) {\n\t\t\tthis[x] = null;\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// src/Flicking.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n// internal config values\nconst CONFIG = {\n\tpanel: {\n\t\t$list: null,\t    // panel list\n\t\tindex: 0,\t\t\t// dom index used among process\n\t\tno: 0,\t\t\t\t// panel no used among process\n\t\tcurrIndex: 0,       // current physical dom index\n\t\tcurrNo: 0,          // current logical panel number\n\t\tsize: 0,\t\t\t// panel size\n\t\tcount: 0,\t\t\t// total physical panel count\n\t\torigCount: 0,\t\t// total count of given original panels\n\t\tchanged: false,\t\t// if panel changed\n\t\tanimating: false,\t// current animating status boolean\n\t\tminCount: 3         // minimum panel count\n\t},\n\ttouch: {\n\t\tholdPos: [0, 0],    // hold x,y coordinate\n\t\tdestPos: [0, 0],\t// destination x,y coordinate\n\t\tdistance: 0,\t\t// touch distance pixel of start to end touch\n\t\tdirection: null,\t// touch direction\n\t\tlastPos: 0,\t\t\t// to determine move on holding\n\t\tholding: false\n\t},\n\tcustomEvent: {          // for custom events value\n\t\tflick: true,\n\t\trestore: false,\n\t\trestoreCall: false\n\t},\n\tdirData: [],\t\t\t// direction constant value according horizontal or vertical\n\tindexToMove: 0,\n\t$dummyAnchor: null      // For buggy link highlighting on Android 2.x\n};\n\n\n// default options\nconst OPTIONS = {\n\thwAccelerable: true,    // ns.isHWAccelerable(),  // check weather hw acceleration is available\n\tprefix: \"eg-flick\",     // prefix value of class name\n\tdeceleration: 0.0006,   // deceleration value\n\thorizontal: true,       // move direction (true == horizontal, false == vertical)\n\tcircular: false,        // circular mode. In this mode at least 3 panels are required.\n\tpreviewPadding: null,   // preview padding value in left(up) to right(down) order. In this mode at least 5 panels are required.\n\tbounce: null,           // bounce value in left(up) to right(down) order. Works only in non-circular mode.\n\tthreshold: 40,          // the distance pixel threshold value for change panel\n\tduration: 100,          // duration ms for animation\n\tpanelEffect: x => 1 - Math.pow(1 - x, 3),  // easing function for panel change animation\n\tdefaultIndex: 0,        // initial panel index to be shown\n\tinputType: [            // input type\n\t\t\"touch\", \"mouse\"\n\t],\n\tthresholdAngle: 45,     // the threshold value that determines whether user action is horizontal or vertical (0~90)\n\tadaptiveHeight: false   // Set container's height be adaptive according panel's height\n};\n\nexport {\n\tCONFIG,\n\tOPTIONS\n};\n\n\n\n// WEBPACK FOOTER //\n// src/config.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport * as consts from \"./consts\";\n\nexport default superclass => class extends superclass {\n\n\t/**\n\t * 'hold' event handler\n\t */\n\t_holdHandler(e) {\n\t\tconst conf = this._conf;\n\n\t\tconf.touch.holdPos = e.pos;\n\t\tconf.touch.holding = true;\n\t\tconf.panel.changed = false;\n\n\t\tthis._adjustContainerCss(\"start\", e.pos);\n\t}\n\n\t/**\n\t * 'change' event handler\n\t */\n\t_changeHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\t\tconst posIndex = +!this.options.horizontal;\n\t\tconst pos = e.pos[posIndex];\n\t\tconst holdPos = touch.holdPos[posIndex];\n\t\tlet direction;\n\t\tlet eventRes = null;\n\t\tlet movedPx;\n\n\t\tthis._setPointerEvents(e);  // for \"click\" bug\n\n\t\t/**\n\t\t * This event is fired when panel moves.\n\t\t * @ko 패널이 이동할 때 발생하는 이벤트\n\t\t * @name eg.Flicking#flick\n\t\t * @event\n\t\t * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n\t\t * @param {String} param.eventType The name of the event<ko>이름명</ko>\n\t\t * @param {Number} param.index Physical index number of the current panel element, which is relative to DOM (@deprecated since 1.3.0)<ko>현재 패널 엘리먼트의 물리적 인덱스 번호. DOM 엘리먼트를 기준으로 하는 인덱스 번호다 (@deprecated since 1.3.0)</ko>\n\t\t * @param {Number} param.no Logical index number of the current panel element, which is relative to the panel content <ko>현재 패널 엘리먼트의 논리적 인덱스 번호. 패널 콘텐츠를 기준으로 하는 인덱스 번호다</ko>\n\t\t * @param {Number} param.direction Direction of the movement (see eg.MovableCoord.DIRECTION_* constant) <ko>이동 방향(eg.MovableCoord.DIRECTION_* constant 참고)</ko>\n\t\t * @param {Array} param.pos Start coordinate <ko>출발점 좌표</ko>\n\t\t * @param {Number} param.pos.0 x-coordinate <ko>x 좌표</ko>\n\t\t * @param {Number} param.pos.1 y-coordinate <ko>y 좌표</ko>\n\t\t * @param {Boolean} param.holding Indicates whether a user holds an element on the screen of the device. <ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>\n\t\t * @param {Number} param.distance Distance moved from then starting point. According the move direction, positive on eg.MovableCoord.DIRECTION_LEFT/UP and negative on eg.MovableCoord.DIRECTION_RIGHT/DOWN <ko>시작점부터 이동된 거리의 값. 이동 방향에 따라 eg.MovableCoord.DIRECTION_LEFT/UP의 경우 양수를 eg.MovableCoord.DIRECTION_RIGHT/DOWN의 경우는 음수를 반환</ko>\n\t\t */\n\t\tif (e.hammerEvent) {\n\t\t\tdirection = e.hammerEvent.direction;\n\n\t\t\t// Adjust direction in case of diagonal touch move\n\t\t\tmovedPx = e.hammerEvent[this.options.horizontal ? \"deltaX\" : \"deltaY\"];\n\n\t\t\tif (!~conf.dirData.indexOf(direction)) {\n\t\t\t\tdirection = conf.dirData[+(Math.abs(touch.lastPos) <= movedPx)];\n\t\t\t}\n\n\t\t\ttouch.lastPos = movedPx;\n\t\t} else {\n\t\t\ttouch.lastPos = null;\n\t\t}\n\n\t\tconf.customEvent.flick && (eventRes =\n\t\t\tthis._triggerEvent(consts.EVENTS.flick, {\n\t\t\t\tpos: e.pos,\n\t\t\t\tholding: e.holding,\n\t\t\t\tdirection: direction || touch.direction,\n\t\t\t\tdistance: pos - (holdPos || (touch.holdPos[posIndex] = pos))\n\t\t\t}\n\t\t));\n\n\t\t(eventRes || eventRes === null) && this._setTranslate([-pos, 0]);\n\t}\n\n\t/**\n\t * 'release' event handler\n\t */\n\t_releaseHandler(e) {\n\t\tconst touch = this._conf.touch;\n\t\tconst pos = e.destPos;\n\t\tconst posIndex = +!this.options.horizontal;\n\t\tconst holdPos = touch.holdPos[posIndex];\n\t\tconst panelSize = this._conf.panel.size;\n\n\t\ttouch.distance = e.depaPos[posIndex] - touch.holdPos[posIndex];\n\n\t\ttouch.direction = this._conf.dirData[\n\t\t\t+!(touch.holdPos[posIndex] < e.depaPos[posIndex])\n\t\t];\n\n\t\tpos[posIndex] = Math.max(\n\t\t\tholdPos - panelSize, Math.min(holdPos, pos[posIndex])\n\t\t);\n\n\t\ttouch.destPos[posIndex] =\n\t\t\tpos[posIndex] = Math.round(pos[posIndex] / panelSize) * panelSize;\n\n\t\ttouch.distance === 0 && this._adjustContainerCss(\"end\");\n\t\ttouch.holding = false;\n\n\t\tthis._setPointerEvents();  // for \"click\" bug\n\t}\n\n\t/**\n\t * 'animationStart' event handler\n\t */\n\t_animationStartHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst customEvent = conf.customEvent;\n\n\t\tpanel.animating = true;\n\n\t\tif (!customEvent.restoreCall && e.hammerEvent &&\n\t\t\tthis._setPhaseValue(\"start\", {\n\t\t\t\tdepaPos: e.depaPos,\n\t\t\t\tdestPos: e.destPos\n\t\t\t}) === false) {\n\t\t\te.stop();\n\t\t}\n\n\t\tif (e.hammerEvent) {\n\t\t\te.duration = this.options.duration;\n\n\t\t\te.destPos[+!this.options.horizontal] =\n\t\t\t\tpanel.size * (\n\t\t\t\t\tpanel.index + conf.indexToMove\n\t\t\t\t);\n\t\t}\n\n\t\tif (this._isMovable()) {\n\t\t\t!customEvent.restoreCall && (customEvent.restore = false);\n\t\t} else {\n\t\t\tthis._triggerBeforeRestore(e);\n\t\t}\n\t}\n\n\t/**\n\t * 'animationEnd' event handler\n\t */\n\t_animationEndHandler() {\n\t\tthis._setPhaseValue(\"end\");\n\n\t\tthis._conf.panel.animating = false;\n\t\tthis._triggerRestore();\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// src/eventHandler.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"./Flicking\";\n\nFlicking.VERSION = \"2.0.0-rc.3\";\nmodule.exports = Flicking;\n\n\n\n// WEBPACK FOOTER //\n// src/index.js","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport {window, document} from \"./browser\";\n\nconst utils = {\n\t/**\n\t * Select or create element\n\t * @param {String|HTMLElement} param\n\t *  when string given is as HTML tag, then create element\n\t *  otherwise it returns selected elements\n\t * @returns {HTMLElement}\n\t */\n\t$(param) {\n\t\tlet el = null;\n\n\t\tif (typeof param === \"string\") {\n\t\t\t// check if string is HTML tag format\n\t\t\tconst match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n\t\t\t// creating element\n\t\t\tif (match) {\n\t\t\t\tel = document.createElement(match[1]);\n\n\t\t\t\t// attributes\n\t\t\t\tmatch.length === 3 &&\n\t\t\t\t\tmatch[2].split(\" \").forEach(v => {\n\t\t\t\t\t\tconst attr = v.split(\"=\");\n\n\t\t\t\t\t\tel.setAttribute(attr[0], attr[1].trim().replace(/(^[\"']|[\"']$)/g, \"\"));\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel = document.querySelectorAll(param);\n\n\t\t\t\tif (!el.length) {\n\t\t\t\t\tel = null;\n\t\t\t\t} else if (el.length === 1) {\n\t\t\t\t\tel = el[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (param.nodeName && param.nodeType === 1) {\n\t\t\tel = param;\n\t\t}\n\n\t\treturn el;\n\t},\n\n\t/**\n\t * Check if is array\n\t * @param arr\n\t * @returns {Boolean}\n\t */\n\tisArray(arr) {\n\t\treturn arr && arr.constructor === Array;\n\t},\n\n\t/**\n\t * Check if is object\n\t * @param {Object} obj\n\t * @returns {Boolean}\n\t */\n\tisObject(obj) {\n\t\treturn obj && !obj.nodeType && typeof obj === \"object\" && !this.isArray(obj);\n\t},\n\n\t/**\n\t * Merge object returning new object\n\t * @param {Object} target\n\t * @param {Object} objectN\n\t * @returns {Object} merged target object\n\t * @example\n\t *  var target = { a: 1 };\n\t *  utils.extend(target, { b: 2, c: 3 });\n\t *  target;  // { a: 1, b: 2, c: 3 };\n\t */\n\textend(target, ...objectN) {\n\t\tif (!objectN.length || (objectN.length === 1 && !objectN[0])) {\n\t\t\treturn target;\n\t\t}\n\n\t\tconst source = objectN.shift();\n\n\t\tif (this.isObject(target) && this.isObject(source)) {\n\t\t\tObject.keys(source).forEach(key => {\n\t\t\t\tconst value = source[key];\n\n\t\t\t\tif (this.isObject(value)) {\n\t\t\t\t\t!target[key] && (target[key] = {});\n\n\t\t\t\t\ttarget[key] = this.extend(target[key], value);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = this.isArray(value) ?\n\t\t\t\t\t\tvalue.concat() : value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this.extend(target, ...objectN);\n\t},\n\n\t/**\n\t * Get or set the style value or apply\n\t * @param {HTMLElement} el\n\t * @param {String|Object} style\n\t *  String: return style property value\n\t *  Object: set style value\n\t * @param {Boolean} getAsNumber Get the value as number\n\t * @returns {String|HTMLElement}\n\t */\n\tcss(el, style, getAsNumber) {\n\t\tif (typeof(style) === \"string\") {\n\t\t\tconst value = window.getComputedStyle(el)[style];\n\n\t\t\treturn getAsNumber ? this.getNumValue(value) : value;\n\t\t} else {\n\t\t\tconst applyStyle = (target, source) =>\n\t\t\t\tObject.keys(source).forEach(v => {\n\t\t\t\t\ttarget[v] = source[v];\n\t\t\t\t});\n\n\t\t\tthis.isArray(el) ?\n\t\t\t\tel.forEach(v => applyStyle(v.style, style)) :\n\t\t\t\tapplyStyle(el.style, style);\n\t\t}\n\n\t\treturn el;\n\t},\n\n\t/**\n\t * Check and parse value to number\n\t * @param {Number|String} val\n\t * @param {Number} defVal\n\t * @return {Number}\n\t */\n\tgetNumValue(val, defVal) {\n\t\tlet num = val;\n\n\t\treturn isNaN(num = parseInt(num, 10)) ? defVal : num;\n\t},\n\n\t/**\n\t * Return unit formatted value\n\t * @param {Number|String} val\n\t * @return {String} val Value formatted with unit\n\t */\n\tgetUnitValue(val) {\n\t\tconst rx = /(?:[a-z]{2,}|%)$/;\n\n\t\treturn (parseInt(val, 10) || 0) + (String(val).match(rx) || \"px\");\n\t},\n\n\t/**\n\t * Get element's outer value\n\t * @param {HTMLElement} el\n\t * @param {String} type - [outerWidth|outerHeight]\n\t * @returns {Number} outer's value\n\t */\n\tgetOuter(el, type) {\n\t\tconst style = window.getComputedStyle(el);\n\t\tconst margin = type === \"outerWidth\" ?\n\t\t\t[\"marginLeft\", \"marginRight\"] : [\"marginTop\", \"marginBottom\"];\n\n\t\treturn this.getNumValue(style[type.replace(\"outer\", \"\").toLocaleLowerCase()]) +\n\t\t\tthis.getNumValue(style[margin[0]]) +\n\t\t\tthis.getNumValue(style[margin[1]]);\n\t},\n\n\t/**\n\t * Get element's outerWidth value with margin\n\t * @param {HTMLElement} el\n\t * @returns {Number}\n\t */\n\touterWidth(el) {\n\t\treturn this.getOuter(el, \"outerWidth\");\n\t},\n\n\t/**\n\t * Get element's outerHeight value with margin\n\t * @param {HTMLElement} el\n\t * @returns {Number}\n\t */\n\touterHeight(el) {\n\t\treturn this.getOuter(el, \"outerHeight\");\n\t},\n\n\t/**\n\t * Checks whether hardware acceleration is enabled.\n\t *\n\t * @ko 하드웨어 가속을 사용할 수 있는 환경인지 확인한다\n\t * @method eg#isHWAccelerable\n\t * @return {Boolean} Indicates whether hardware acceleration is enabled. <ko>하드웨어 가속 사용 가능 여부</ko>\n\t */\n\tisHWAccelerable() {\n\t\tconst ua = window.navigator.userAgent;\n\t\tlet result = false;\n\t\tlet match;\n\n\t\t// chrome 25- has a text blur bug (except Samsung's sbrowser)\n\t\tif ((match = ua.match(/Chrome\\/(\\d+)/))) {\n\t\t\tresult = match[1] >= \"25\";\n\t\t} else if (/ie|edge|firefox|safari|inapp/.test(ua)) {\n\t\t\tresult = true;\n\t\t} else if ((match = ua.match(/Android ([\\d.]+)/))) {\n\t\t\tconst version = match[1];\n\t\t\tconst useragent = (ua.match(/\\(.*\\)/) || [null])[0];\n\n\t\t\t// android 4.1+ blacklist\n\t\t\t// EK-GN120 : Galaxy Camera, SM-G386F : Galaxy Core LTE\n\t\t\t// SHW-M420 : Galaxy Nexus , SHW-M200 : NexusS , GT-S7562 : Galaxy S duos\n\t\t\tresult = (version >= \"4.1.0\" && !/EK-GN120|SM-G386F/.test(useragent)) ||\n\t\t\t\t(\n\t\t\t\t\tversion >= \"4.0.3\" &&\n\t\t\t\t\t/SHW-|SHV-|GT-|SCH-|SGH-|SPH-|LG-F160|LG-F100|LG-F180|LG-F200|EK-|IM-A|LG-F240|LG-F260/.test(useragent) &&\n\t\t\t\t\t!/SHW-M420|SHW-M200|GT-S7562/.test(useragent)\n\t\t\t\t);\n\t\t}\n\n\t\tthis.isHWAccelerable = () => result;\n\t\treturn result;\n\t},\n\n\t/**\n\t * Returns the syntax of the translate style which is applied to CSS transition properties.\n\t *\n\t * @ko CSS 트랜지션 속성에 적용할 translate 스타일 구문을 반환한다\n\t * @method eg#translate\n\t * @param {String} x Distance to move along the X axis <ko>x축을 따라 이동할 거리</ko>\n\t * @param {String} y Distance to move along the Y axis <ko>y축을 따라 이동할 거리</ko>\n\t * @param {Boolean} [isHA] Force hardware acceleration <ko>하드웨어 가속 사용 여부</ko>\n\t * @return {String} Syntax of the translate style <ko>translate 스타일 구문</ko>\n\t */\n\ttranslate(x, y, isHA) {\n\t\treturn isHA || false ?\n\t\t\t`translate3d(${x},${y},0)` : `translate(${x},${y})`;\n\t},\n\n\t// 1. user press one position on screen.\n\t// 2. user moves to the other position on screen.\n\t// 3. when user releases fingers on screen, 'click' event is fired at previous position.\n\thasClickBug() {\n\t\tconst ua = window.navigator.userAgent;\n\t\tconst result = /Safari/.test(ua);\n\n\t\tthis.hasClickBug = () => result;\n\t\treturn result;\n\t}\n};\n\nclass MixinBuilder {\n\tconstructor(superclass) {\n\t\tthis.superclass = superclass || class {};\n\t}\n\n\twith(...mixins) {\n\t\treturn mixins.reduce((c, m) => m(c), this.superclass);\n\t}\n}\n\nconst Mixin = superclass => new MixinBuilder(superclass);\n\nexport {utils, Mixin};\n\n\n\n// WEBPACK FOOTER //\n// src/utils.js","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}\n// module id = 7\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@egjs/movablecoord\",\"commonjs2\":\"@egjs/movablecoord\",\"amd\":\"@egjs/movablecoord\",\"root\":[\"eg\",\"MovableCoord\"]}\n// module id = 8\n// module chunks = 0 1"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;AChEA;;;;AAIA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAOA;AAfA;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjCA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAXA;;;;;;AAYA;;;;;;;;AAQA;;;AACA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3BA;AA4BA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AAAA;AACA;AACA;AAFA;AAAA;AATA;AAcA;AACA;AArBA;AACA;AAuBA;AACA;AAAA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AASA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAQA;AACA;AAEA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AAVA;AACA;AAgBA;AAEA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAh3CA;AACA;AADA;;;;;;;;;;;ACpBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AA7BA;AACA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAhBA;AACA;AAmBA;AACA;;;;;;;;;;;ACxDA;AACA;AADA;AACA;;;;;;;AALA;;;;;;AAMA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AACA;;;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAfA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AACA;AAOA;AACA;AACA;AACA;;;;;AAzEA;AA6EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAtGA;AA0GA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAxIA;AA4IA;AACA;AACA;AACA;AACA;AACA;AAjJA;AAAA;AAAA;AACA;;;;;;;;;;ACHA;AACA;;;;;AACA;;;;;AACA;;;;;;;;;;;;ACPA;;;;;;AAIA;AACA;;;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;AAUA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAHA;AACA;AAIA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;AAUA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAhPA;AACA;AAkPA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;;;;;;ACrQA;;;;;;ACAA;;;;A","sourceRoot":""}